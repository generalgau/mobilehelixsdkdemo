/*
* jQuery Mobile 1.3.1
* Git HEAD hash: 74b4bec049fd93e4fe40205e6157de16eb64eb46 <> Date: Mon Apr 8 2013 19:41:28 UTC
* http://jquerymobile.com
*
* Copyright 2010, 2013 jQuery Foundation, Inc. and other contributors
* Released under the MIT license.
* http://jquery.org/license
*
*/


(function ( root, doc, factory ) {
	if ( typeof define === "function" && define.amd ) {
		// AMD. Register as an anonymous module.
		define( [ "jquery" ], function ( $ ) {
			factory( $, root, doc );
			return $.mobile;
		});
	} else {
		// Browser globals
		factory( root.jQuery, root, doc );
	}
}( this, document, function ( jQuery, window, document, undefined ) {
(function( $ ) {
	$.mobile = {};
}( jQuery ));
(function( $, window, undefined ) {
	var nsNormalizeDict = {};

	// jQuery.mobile configurable options
	$.mobile = $.extend($.mobile, {

		// Version of the jQuery Mobile Framework
		version: "1.3.1",

		// Namespace used framework-wide for data-attrs. Default is no namespace
		ns: "",

		// Define the url parameter used for referencing widget-generated sub-pages.
		// Translates to to example.html&ui-page=subpageIdentifier
		// hash segment before &ui-page= is used to make Ajax request
		subPageUrlKey: "ui-page",

		// Class assigned to page currently in view, and during transitions
		activePageClass: "ui-page-active",

		// Class used for "active" button state, from CSS framework
		activeBtnClass: "ui-btn-active",

		// Class used for "focus" form element state, from CSS framework
		focusClass: "ui-focus",

		// Automatically handle clicks and form submissions through Ajax, when same-domain
		ajaxEnabled: true,

		// Automatically load and show pages based on location.hash
		hashListeningEnabled: true,

		// disable to prevent jquery from bothering with links
		linkBindingEnabled: true,

		// Set default page transition - 'none' for no transitions
		defaultPageTransition: "fade",

		// Set maximum window width for transitions to apply - 'false' for no limit
		maxTransitionWidth: false,

		// Minimum scroll distance that will be remembered when returning to a page
		minScrollBack: 250,

		// DEPRECATED: the following property is no longer in use, but defined until 2.0 to prevent conflicts
		touchOverflowEnabled: false,

		// Set default dialog transition - 'none' for no transitions
		defaultDialogTransition: "pop",

		// Error response message - appears when an Ajax page request fails
		pageLoadErrorMessage: "Error Loading Page",

		// For error messages, which theme does the box uses?
		pageLoadErrorMessageTheme: "e",

		// replace calls to window.history.back with phonegaps navigation helper
		// where it is provided on the window object
		phonegapNavigationEnabled: false,

		//automatically initialize the DOM when it's ready
		autoInitializePage: true,

		pushStateEnabled: true,

		// allows users to opt in to ignoring content by marking a parent element as
		// data-ignored
		ignoreContentEnabled: false,

		// turn of binding to the native orientationchange due to android orientation behavior
		orientationChangeEnabled: true,

		buttonMarkup: {
			hoverDelay: 200
		},

		// define the window and the document objects
		window: $( window ),
		document: $( document ),

		// TODO might be useful upstream in jquery itself ?
		keyCode: {
			ALT: 18,
			BACKSPACE: 8,
			CAPS_LOCK: 20,
			COMMA: 188,
			COMMAND: 91,
			COMMAND_LEFT: 91, // COMMAND
			COMMAND_RIGHT: 93,
			CONTROL: 17,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			INSERT: 45,
			LEFT: 37,
			MENU: 93, // COMMAND_RIGHT
			NUMPAD_ADD: 107,
			NUMPAD_DECIMAL: 110,
			NUMPAD_DIVIDE: 111,
			NUMPAD_ENTER: 108,
			NUMPAD_MULTIPLY: 106,
			NUMPAD_SUBTRACT: 109,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SHIFT: 16,
			SPACE: 32,
			TAB: 9,
			UP: 38,
			WINDOWS: 91 // COMMAND
		},

		// Place to store various widget extensions
		behaviors: {},

		// Scroll page vertically: scroll to 0 to hide iOS address bar, or pass a Y value
		silentScroll: function( ypos ) {
			if ( $.type( ypos ) !== "number" ) {
				ypos = $.mobile.defaultHomeScroll;
			}

			// prevent scrollstart and scrollstop events
			$.event.special.scrollstart.enabled = false;

			setTimeout( function() {
				window.scrollTo( 0, ypos );
				$.mobile.document.trigger( "silentscroll", { x: 0, y: ypos });
			}, 20 );

			setTimeout( function() {
				$.event.special.scrollstart.enabled = true;
			}, 150 );
		},

		// Expose our cache for testing purposes.
		nsNormalizeDict: nsNormalizeDict,

		// Take a data attribute property, prepend the namespace
		// and then camel case the attribute string. Add the result
		// to our nsNormalizeDict so we don't have to do this again.
		nsNormalize: function( prop ) {
			if ( !prop ) {
				return;
			}

			return nsNormalizeDict[ prop ] || ( nsNormalizeDict[ prop ] = $.camelCase( $.mobile.ns + prop ) );
		},

		// Find the closest parent with a theme class on it. Note that
		// we are not using $.fn.closest() on purpose here because this
		// method gets called quite a bit and we need it to be as fast
		// as possible.
		getInheritedTheme: function( el, defaultTheme ) {
			var e = el[ 0 ],
				ltr = "",
				re = /ui-(bar|body|overlay)-([a-z])\b/,
				c, m;

			while ( e ) {
				c = e.className || "";
				if ( c && ( m = re.exec( c ) ) && ( ltr = m[ 2 ] ) ) {
					// We found a parent with a theme class
					// on it so bail from this loop.
					break;
				}

				e = e.parentNode;
			}

			// Return the theme letter we found, if none, return the
			// specified default.

			return ltr || defaultTheme || "a";
		},

		// TODO the following $ and $.fn extensions can/probably should be moved into jquery.mobile.core.helpers
		//
		// Find the closest javascript page element to gather settings data jsperf test
		// http://jsperf.com/single-complex-selector-vs-many-complex-selectors/edit
		// possibly naive, but it shows that the parsing overhead for *just* the page selector vs
		// the page and dialog selector is negligable. This could probably be speed up by
		// doing a similar parent node traversal to the one found in the inherited theme code above
		closestPageData: function( $target ) {
			return $target
				.closest( ':jqmData(role="page"), :jqmData(role="dialog")' )
				.data( "mobile-page" );
		},

		enhanceable: function( $set ) {
			return this.haveParents( $set, "enhance" );
		},

		hijackable: function( $set ) {
			return this.haveParents( $set, "ajax" );
		},

		haveParents: function( $set, attr ) {
			if ( !$.mobile.ignoreContentEnabled ) {
				return $set;
			}

			var count = $set.length,
				$newSet = $(),
				e, $element, excluded;

			for ( var i = 0; i < count; i++ ) {
				$element = $set.eq( i );
				excluded = false;
				e = $set[ i ];

				while ( e ) {
					var c = e.getAttribute ? e.getAttribute( "data-" + $.mobile.ns + attr ) : "";

					if ( c === "false" ) {
						excluded = true;
						break;
					}

					e = e.parentNode;
				}

				if ( !excluded ) {
					$newSet = $newSet.add( $element );
				}
			}

			return $newSet;
		},

		getScreenHeight: function() {
			// Native innerHeight returns more accurate value for this across platforms,
			// jQuery version is here as a normalized fallback for platforms like Symbian
			return window.innerHeight || $.mobile.window.height();
		}
	}, $.mobile );

	// Mobile version of data and removeData and hasData methods
	// ensures all data is set and retrieved using jQuery Mobile's data namespace
	$.fn.jqmData = function( prop, value ) {
		var result;
		if ( typeof prop !== "undefined" ) {
			if ( prop ) {
				prop = $.mobile.nsNormalize( prop );
			}

			// undefined is permitted as an explicit input for the second param
			// in this case it returns the value and does not set it to undefined
			if( arguments.length < 2 || value === undefined ){
				result = this.data( prop );
			} else {
				result = this.data( prop, value );
			}
		}
		return result;
	};

	$.jqmData = function( elem, prop, value ) {
		var result;
		if ( typeof prop !== "undefined" ) {
			result = $.data( elem, prop ? $.mobile.nsNormalize( prop ) : prop, value );
		}
		return result;
	};

	$.fn.jqmRemoveData = function( prop ) {
		return this.removeData( $.mobile.nsNormalize( prop ) );
	};

	$.jqmRemoveData = function( elem, prop ) {
		return $.removeData( elem, $.mobile.nsNormalize( prop ) );
	};

	$.fn.removeWithDependents = function() {
		$.removeWithDependents( this );
	};

	$.removeWithDependents = function( elem ) {
		var $elem = $( elem );

		( $elem.jqmData( 'dependents' ) || $() ).remove();
		$elem.remove();
	};

	$.fn.addDependents = function( newDependents ) {
		$.addDependents( $( this ), newDependents );
	};

	$.addDependents = function( elem, newDependents ) {
		var dependents = $( elem ).jqmData( 'dependents' ) || $();

		$( elem ).jqmData( 'dependents', $.merge( dependents, newDependents ) );
	};

	// note that this helper doesn't attempt to handle the callback
	// or setting of an html element's text, its only purpose is
	// to return the html encoded version of the text in all cases. (thus the name)
	$.fn.getEncodedText = function() {
		return $( "<div/>" ).text( $( this ).text() ).html();
	};

	// fluent helper function for the mobile namespaced equivalent
	$.fn.jqmEnhanceable = function() {
		return $.mobile.enhanceable( this );
	};

	$.fn.jqmHijackable = function() {
		return $.mobile.hijackable( this );
	};

	// Monkey-patching Sizzle to filter the :jqmData selector
	var oldFind = $.find,
		jqmDataRE = /:jqmData\(([^)]*)\)/g;

	$.find = function( selector, context, ret, extra ) {
		selector = selector.replace( jqmDataRE, "[data-" + ( $.mobile.ns || "" ) + "$1]" );

		return oldFind.call( this, selector, context, ret, extra );
	};

	$.extend( $.find, oldFind );

	$.find.matches = function( expr, set ) {
		return $.find( expr, null, null, set );
	};

	$.find.matchesSelector = function( node, expr ) {
		return $.find( expr, null, null, [ node ] ).length > 0;
	};
})( jQuery, this );


/*!
 * jQuery UI Widget v1.10.0pre - 2012-11-13 (ff055a0c353c3c8ce6e5bfa07ad7cb03e8885bc5)
 * http://jqueryui.com
 *
 * Copyright 2010, 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( $.isFunction( value ) ) {
			prototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		}
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, prototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.widget", {
	// decorate the parent _createWidget to trigger `widgetinit` for users
	// who wish to do post post `widgetcreate` alterations/additions
	//
	// TODO create a pull request for jquery ui to trigger this event
	// in the original _createWidget
	_createWidget: function() {
		$.Widget.prototype._createWidget.apply( this, arguments );
		this._trigger( 'init' );
	},

	_getCreateOptions: function() {

		var elem = this.element,
			options = {};

		$.each( this.options, function( option ) {

			var value = elem.jqmData( option.replace( /[A-Z]/g, function( c ) {
							return "-" + c.toLowerCase();
						})
					);

			if ( value !== undefined ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	enhanceWithin: function( target, useKeepNative ) {
		this.enhance( $( this.options.initSelector, $( target )), useKeepNative );
	},

	enhance: function( targets, useKeepNative ) {
		var page, keepNative, $widgetElements = $( targets ), self = this;

		// if ignoreContentEnabled is set to true the framework should
		// only enhance the selected elements when they do NOT have a
		// parent with the data-namespace-ignore attribute
		$widgetElements = $.mobile.enhanceable( $widgetElements );

		if ( useKeepNative && $widgetElements.length ) {
			// TODO remove dependency on the page widget for the keepNative.
			// Currently the keepNative value is defined on the page prototype so
			// the method is as well
			page = $.mobile.closestPageData( $widgetElements );
			keepNative = ( page && page.keepNativeSelector()) || "";

			$widgetElements = $widgetElements.not( keepNative );
		}

		$widgetElements[ this.widgetName ]();
	},

	raise: function( msg ) {
		throw "Widget [" + this.widgetName + "]: " + msg;
	}
});

})( jQuery );


(function( $, window ) {
	// DEPRECATED
	// NOTE global mobile object settings
	$.extend( $.mobile, {
		// DEPRECATED Should the text be visble in the loading message?
		loadingMessageTextVisible: undefined,

		// DEPRECATED When the text is visible, what theme does the loading box use?
		loadingMessageTheme: undefined,

		// DEPRECATED default message setting
		loadingMessage: undefined,

		// DEPRECATED
		// Turn on/off page loading message. Theme doubles as an object argument
		// with the following shape: { theme: '', text: '', html: '', textVisible: '' }
		// NOTE that the $.mobile.loading* settings and params past the first are deprecated
		showPageLoadingMsg: function( theme, msgText, textonly ) {
			$.mobile.loading( 'show', theme, msgText, textonly );
		},

		// DEPRECATED
		hidePageLoadingMsg: function() {
			$.mobile.loading( 'hide' );
		},

		loading: function() {
			this.loaderWidget.loader.apply( this.loaderWidget, arguments );
		}
	});

	// TODO move loader class down into the widget settings
	var loaderClass = "ui-loader", $html = $( "html" ), $window = $.mobile.window;

	$.widget( "mobile.loader", {
		// NOTE if the global config settings are defined they will override these
		//      options
		options: {
			// the theme for the loading message
			theme: "a",

			// whether the text in the loading message is shown
			textVisible: false,

			// custom html for the inner content of the loading message
			html: "",

			// the text to be displayed when the popup is shown
			text: "loading"
		},

		defaultHtml: "<div class='" + loaderClass + "'>" +
			"<span class='ui-icon ui-icon-loading'></span>" +
			"<h1></h1>" +
			"</div>",

		// For non-fixed supportin browsers. Position at y center (if scrollTop supported), above the activeBtn (if defined), or just 100px from top
		fakeFixLoader: function() {
			var activeBtn = $( "." + $.mobile.activeBtnClass ).first();

			this.element
				.css({
					top: $.support.scrollTop && $window.scrollTop() + $window.height() / 2 ||
						activeBtn.length && activeBtn.offset().top || 100
				});
		},

		// check position of loader to see if it appears to be "fixed" to center
		// if not, use abs positioning
		checkLoaderPosition: function() {
			var offset = this.element.offset(),
				scrollTop = $window.scrollTop(),
				screenHeight = $.mobile.getScreenHeight();

			if ( offset.top < scrollTop || ( offset.top - scrollTop ) > screenHeight ) {
				this.element.addClass( "ui-loader-fakefix" );
				this.fakeFixLoader();
				$window
					.unbind( "scroll", this.checkLoaderPosition )
					.bind( "scroll", $.proxy( this.fakeFixLoader, this ) );
			}
		},

		resetHtml: function() {
			this.element.html( $( this.defaultHtml ).html() );
		},

		// Turn on/off page loading message. Theme doubles as an object argument
		// with the following shape: { theme: '', text: '', html: '', textVisible: '' }
		// NOTE that the $.mobile.loading* settings and params past the first are deprecated
		// TODO sweet jesus we need to break some of this out
		show: function( theme, msgText, textonly ) {
			var textVisible, message, $header, loadSettings;

			this.resetHtml();

			// use the prototype options so that people can set them globally at
			// mobile init. Consistency, it's what's for dinner
			if ( $.type(theme) === "object" ) {
				loadSettings = $.extend( {}, this.options, theme );

				// prefer object property from the param then the old theme setting
				theme = loadSettings.theme || $.mobile.loadingMessageTheme;
			} else {
				loadSettings = this.options;

				// here we prefer the them value passed as a string argument, then
				// we prefer the global option because we can't use undefined default
				// prototype options, then the prototype option
				theme = theme || $.mobile.loadingMessageTheme || loadSettings.theme;
			}

			// set the message text, prefer the param, then the settings object
			// then loading message
			message = msgText || $.mobile.loadingMessage || loadSettings.text;

			// prepare the dom
			$html.addClass( "ui-loading" );

			if ( $.mobile.loadingMessage !== false || loadSettings.html ) {
				// boolean values require a bit more work :P, supports object properties
				// and old settings
				if ( $.mobile.loadingMessageTextVisible !== undefined ) {
					textVisible = $.mobile.loadingMessageTextVisible;
				} else {
					textVisible = loadSettings.textVisible;
				}

				// add the proper css given the options (theme, text, etc)
				// Force text visibility if the second argument was supplied, or
				// if the text was explicitly set in the object args
				this.element.attr("class", loaderClass +
					" ui-corner-all ui-body-" + theme +
					" ui-loader-" + ( textVisible || msgText || theme.text ? "verbose" : "default" ) +
					( loadSettings.textonly || textonly ? " ui-loader-textonly" : "" ) );

				// TODO verify that jquery.fn.html is ok to use in both cases here
				//      this might be overly defensive in preventing unknowing xss
				// if the html attribute is defined on the loading settings, use that
				// otherwise use the fallbacks from above
				if ( loadSettings.html ) {
					this.element.html( loadSettings.html );
				} else {
					this.element.find( "h1" ).text( message );
				}

				// attach the loader to the DOM
				this.element.appendTo( $.mobile.pageContainer );

				// check that the loader is visible
				this.checkLoaderPosition();

				// on scroll check the loader position
				$window.bind( "scroll", $.proxy( this.checkLoaderPosition, this ) );
			}
		},

		hide: function() {
			$html.removeClass( "ui-loading" );

			if ( $.mobile.loadingMessage ) {
				this.element.removeClass( "ui-loader-fakefix" );
			}

			$.mobile.window.unbind( "scroll", this.fakeFixLoader );
			$.mobile.window.unbind( "scroll", this.checkLoaderPosition );
		}
	});

	$window.bind( 'pagecontainercreate', function() {
		$.mobile.loaderWidget = $.mobile.loaderWidget || $( $.mobile.loader.prototype.defaultHtml ).loader();
	});
})(jQuery, this);


// Script: jQuery hashchange event
// 
// *Version: 1.3, Last updated: 7/21/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and
// robust, there are a few unfortunate browser bugs surrounding expected
// hashchange event-based behaviors, independent of any JavaScript
// window.onhashchange abstraction. See the following examples for more
// information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// Also note that should a browser natively support the window.onhashchange 
// event, but not report that it does, the fallback polling loop will be used.
// 
// About: Release History
// 
// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
//         "removable" for mobile-only development. Added IE6/7 document.title
//         support. Attempted to make Iframe as hidden as possible by using
//         techniques from http://www.paciellogroup.com/blog/?p=604. Added 
//         support for the "shortcut" format $(window).hashchange( fn ) and
//         $(window).hashchange() like jQuery provides for built-in events.
//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
//         file to address access denied issues when setting document.domain in
//         IE6/7.
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function( $, window, undefined ) {
  // Reused string.
  var str_hashchange = 'hashchange',
    
    // Method / object references.
    doc = document,
    fake_onhashchange,
    special = $.event.special,
    
    // Does the browser support window.onhashchange? Note that IE8 running in
    // IE7 compatibility mode reports true for 'onhashchange' in window, even
    // though the event isn't supported, so also test document.documentMode.
    doc_mode = doc.documentMode,
    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || location.href;
    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Method: jQuery.fn.hashchange
  // 
  // Bind a handler to the window.onhashchange event or trigger all bound
  // window.onhashchange event handlers. This behavior is consistent with
  // jQuery's built-in event handlers.
  // 
  // Usage:
  // 
  // > jQuery(window).hashchange( [ handler ] );
  // 
  // Arguments:
  // 
  //  handler - (Function) Optional handler to be bound to the hashchange
  //    event. This is a "shortcut" for the more verbose form:
  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
  //    all bound window.onhashchange event handlers will be triggered. This
  //    is a shortcut for the more verbose
  //    jQuery(window).trigger( 'hashchange' ). These forms are described in
  //    the <hashchange event> section.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements.
  
  // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
  // $(elem).hashchange() for triggering, like jQuery does for built-in events.
  $.fn[ str_hashchange ] = function( fn ) {
    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
  };
  
  // Property: jQuery.fn.hashchange.delay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 50.
  
  // Property: jQuery.fn.hashchange.domain
  // 
  // If you're setting document.domain in your JavaScript, and you want hash
  // history to work in IE6/7, not only must this property be set, but you must
  // also set document.domain BEFORE jQuery is loaded into the page. This
  // property is only applicable if you are supporting IE6/7 (or IE8 operating
  // in "IE7 compatibility" mode).
  // 
  // In addition, the <jQuery.fn.hashchange.src> property must be set to the
  // path of the included "document-domain.html" file, which can be renamed or
  // modified if necessary (note that the document.domain specified must be the
  // same in both your main JavaScript as well as in this file).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.domain = document.domain;
  
  // Property: jQuery.fn.hashchange.src
  // 
  // If, for some reason, you need to specify an Iframe src file (for example,
  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
  // do so using this property. Note that when using this property, history
  // won't be recorded in IE6/7 until the Iframe src file loads. This property
  // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
  // compatibility" mode).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.src = 'path/to/file.html';
  
  $.fn[ str_hashchange ].delay = 50;
  /*
  $.fn[ str_hashchange ].domain = null;
  $.fn[ str_hashchange ].src = null;
  */
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // HTML5 window.onhashchange event is used, otherwise a polling loop is
  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
  // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
  // compatibility" mode), a hidden Iframe is created to allow the back button
  // and hash-based history to work.
  // 
  // Usage as described in <jQuery.fn.hashchange>:
  // 
  // > // Bind an event handler.
  // > jQuery(window).hashchange( function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).hashchange();
  // 
  // A more verbose usage that allows for event namespacing:
  // 
  // > // Bind an event handler.
  // > jQuery(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).trigger( 'hashchange' );
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one handler
  //   is actually bound to the 'hashchange' event.
  // * If you need the bound handler(s) to execute immediately, in cases where
  //   a location.hash exists on page load, via bookmark or page refresh for
  //   example, use jQuery(window).hashchange() or the more verbose 
  //   jQuery(window).trigger( 'hashchange' ).
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a DOM ready handler.
  
  // Override existing $.event.special.hashchange methods (allowing this plugin
  // to be defined after jQuery BBQ in BBQ's source code).
  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function() {
    var self = {},
      timeout_id,
      
      // Remember the initial hash so it doesn't get triggered immediately.
      last_hash = get_fragment(),
      
      fn_retval = function( val ) { return val; },
      history_set = fn_retval,
      history_get = fn_retval;
    
    // Start the polling loop.
    self.start = function() {
      timeout_id || poll();
    };
    
    // Stop the polling loop.
    self.stop = function() {
      timeout_id && clearTimeout( timeout_id );
      timeout_id = undefined;
    };
    
    // This polling loop checks every $.fn.hashchange.delay milliseconds to see
    // if location.hash has changed, and triggers the 'hashchange' event on
    // window when necessary.
    function poll() {
      var hash = get_fragment(),
        history_hash = history_get( last_hash );
      
      if ( hash !== last_hash ) {
        history_set( last_hash = hash, history_hash );
        
        $(window).trigger( str_hashchange );
        
      } else if ( history_hash !== last_hash ) {
        location.href = location.href.replace( /#.*/, '' ) + history_hash;
      }
      
      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
    };
    
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    window.attachEvent && !window.addEventListener && !supports_onhashchange && (function() {
      // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
      // when running in "IE7 compatibility" mode.
      
      var iframe,
        iframe_src;
      
      // When the event is bound and polling starts in IE 6/7, create a hidden
      // Iframe for history handling.
      self.start = function() {
        if ( !iframe ) {
          iframe_src = $.fn[ str_hashchange ].src;
          iframe_src = iframe_src && iframe_src + get_fragment();
          
          // Create hidden Iframe. Attempt to make Iframe as hidden as possible
          // by using techniques from http://www.paciellogroup.com/blog/?p=604.
          iframe = $('<iframe tabindex="-1" title="empty"/>').hide()
            
            // When Iframe has completely loaded, initialize the history and
            // start polling.
            .one( 'load', function() {
              iframe_src || history_set( get_fragment() );
              poll();
            })
            
            // Load Iframe src if specified, otherwise nothing.
            .attr( 'src', iframe_src || 'javascript:0' )
            
            // Append Iframe after the end of the body to prevent unnecessary
            // initial page scrolling (yes, this works).
            .insertAfter( 'body' )[0].contentWindow;
          
          // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with "Unspecified error" the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.
          doc.onpropertychange = function() {
            try {
              if ( event.propertyName === 'title' ) {
                iframe.document.title = doc.title;
              }
            } catch(e) {}
          };
          
        }
      };
      
      // Override the "stop" method since an IE6/7 Iframe was created. Even
      // if there are no longer any bound event handlers, the polling loop
      // is still necessary for back/next to work at all!
      self.stop = fn_retval;
      
      // Get history by looking at the hidden Iframe's location.hash.
      history_get = function() {
        return get_fragment( iframe.location.href );
      };
      
      // Set a new history item by opening and then closing the Iframe
      // document, *then* setting its location.hash. If document.domain has
      // been set, update that as well.
      history_set = function( hash, history_hash ) {
        var iframe_doc = iframe.document,
          domain = $.fn[ str_hashchange ].domain;
        
        if ( hash !== history_hash ) {
          // Update Iframe with any initial `document.title` that might be set.
          iframe_doc.title = doc.title;
          
          // Opening the Iframe's document after it has been closed is what
          // actually adds a history entry.
          iframe_doc.open();
          
          // Set document.domain for the Iframe document as well, if necessary.
          domain && iframe_doc.write( '<script>document.domain="' + domain + '"</script>' );
          
          iframe_doc.close();
          
          // Update the Iframe's hash, for great justice.
          iframe.location.hash = hash;
        }
      };
      
    })();
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    return self;
  })();
  
})(jQuery,this);

(function( $, undefined ) {

	/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas. Dual MIT/BSD license */
	window.matchMedia = window.matchMedia || (function( doc, undefined ) {

		

		var bool,
			docElem = doc.documentElement,
			refNode = docElem.firstElementChild || docElem.firstChild,
			// fakeBody required for <FF4 when executed in <head>
			fakeBody = doc.createElement( "body" ),
			div = doc.createElement( "div" );

		div.id = "mq-test-1";
		div.style.cssText = "position:absolute;top:-100em";
		fakeBody.style.background = "none";
		fakeBody.appendChild(div);

		return function(q){

			div.innerHTML = "&shy;<style media=\"" + q + "\"> #mq-test-1 { width: 42px; }</style>";

			docElem.insertBefore( fakeBody, refNode );
			bool = div.offsetWidth === 42;
			docElem.removeChild( fakeBody );

			return {
				matches: bool,
				media: q
			};

		};

	}( document ));

	// $.mobile.media uses matchMedia to return a boolean.
	$.mobile.media = function( q ) {
		return window.matchMedia( q ).matches;
	};

})(jQuery);

	(function( $, undefined ) {
		var support = {
			touch: "ontouchend" in document
		};

		$.mobile.support = $.mobile.support || {};
		$.extend( $.support, support );
		$.extend( $.mobile.support, support );
	}( jQuery ));

	(function( $, undefined ) {
		$.extend( $.support, {
			orientation: "orientation" in window && "onorientationchange" in window
		});
	}( jQuery ));

(function( $, undefined ) {

// thx Modernizr
function propExists( prop ) {
	var uc_prop = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ),
		props = ( prop + " " + vendors.join( uc_prop + " " ) + uc_prop ).split( " " );

	for ( var v in props ) {
		if ( fbCSS[ props[ v ] ] !== undefined ) {
			return true;
		}
	}
}

var fakeBody = $( "<body>" ).prependTo( "html" ),
	fbCSS = fakeBody[ 0 ].style,
	vendors = [ "Webkit", "Moz", "O" ],
	webos = "palmGetResource" in window, //only used to rule out scrollTop
	opera = window.opera,
	operamini = window.operamini && ({}).toString.call( window.operamini ) === "[object OperaMini]",
	bb = window.blackberry && !propExists( "-webkit-transform" ); //only used to rule out box shadow, as it's filled opaque on BB 5 and lower


function validStyle( prop, value, check_vend ) {
	var div = document.createElement( 'div' ),
		uc = function( txt ) {
			return txt.charAt( 0 ).toUpperCase() + txt.substr( 1 );
		},
		vend_pref = function( vend ) {
			if( vend === "" ) {
				return "";
			} else {
				return  "-" + vend.charAt( 0 ).toLowerCase() + vend.substr( 1 ) + "-";
			}
		},
		check_style = function( vend ) {
			var vend_prop = vend_pref( vend ) + prop + ": " + value + ";",
				uc_vend = uc( vend ),
				propStyle = uc_vend + ( uc_vend === "" ? prop : uc( prop ) );

			div.setAttribute( "style", vend_prop );

			if ( !!div.style[ propStyle ] ) {
				ret = true;
			}
		},
		check_vends = check_vend ? check_vend : vendors,
		ret;

	for( var i = 0; i < check_vends.length; i++ ) {
		check_style( check_vends[i] );
	}
	return !!ret;
}

function transform3dTest() {
	var mqProp = "transform-3d",
		// Because the `translate3d` test below throws false positives in Android:
		ret = $.mobile.media( "(-" + vendors.join( "-" + mqProp + "),(-" ) + "-" + mqProp + "),(" + mqProp + ")" );

	if( ret ) {
		return !!ret;
	}

	var el = document.createElement( "div" ),
		transforms = {
			// Were omitting Opera for the time being; MS uses unprefixed.
			'MozTransform':'-moz-transform',
			'transform':'transform'
		};

	fakeBody.append( el );

	for ( var t in transforms ) {
		if( el.style[ t ] !== undefined ){
			el.style[ t ] = 'translate3d( 100px, 1px, 1px )';
			ret = window.getComputedStyle( el ).getPropertyValue( transforms[ t ] );
		}
	}
	return ( !!ret && ret !== "none" );
}

// Test for dynamic-updating base tag support ( allows us to avoid href,src attr rewriting )
function baseTagTest() {
	var fauxBase = location.protocol + "//" + location.host + location.pathname + "ui-dir/",
		base = $( "head base" ),
		fauxEle = null,
		href = "",
		link, rebase;

	if ( !base.length ) {
		base = fauxEle = $( "<base>", { "href": fauxBase }).appendTo( "head" );
	} else {
		href = base.attr( "href" );
	}

	link = $( "<a href='testurl' />" ).prependTo( fakeBody );
	rebase = link[ 0 ].href;
	base[ 0 ].href = href || location.pathname;

	if ( fauxEle ) {
		fauxEle.remove();
	}
	return rebase.indexOf( fauxBase ) === 0;
}

// Thanks Modernizr
function cssPointerEventsTest() {
	var element = document.createElement( 'x' ),
		documentElement = document.documentElement,
		getComputedStyle = window.getComputedStyle,
		supports;

	if ( !( 'pointerEvents' in element.style ) ) {
		return false;
	}

	element.style.pointerEvents = 'auto';
	element.style.pointerEvents = 'x';
	documentElement.appendChild( element );
	supports = getComputedStyle &&
	getComputedStyle( element, '' ).pointerEvents === 'auto';
	documentElement.removeChild( element );
	return !!supports;
}

function boundingRect() {
	var div = document.createElement( "div" );
	return typeof div.getBoundingClientRect !== "undefined";
}

// non-UA-based IE version check by James Padolsey, modified by jdalton - from http://gist.github.com/527683
// allows for inclusion of IE 6+, including Windows Mobile 7
$.extend( $.mobile, { browser: {} } );
$.mobile.browser.oldIE = (function() {
	var v = 3,
		div = document.createElement( "div" ),
		a = div.all || [];

	do {
		div.innerHTML = "<!--[if gt IE " + ( ++v ) + "]><br><![endif]-->";
	} while( a[0] );

	return v > 4 ? v : !v;
})();

function fixedPosition() {
	var w = window,
		ua = navigator.userAgent,
		platform = navigator.platform,
		// Rendering engine is Webkit, and capture major version
		wkmatch = ua.match( /AppleWebKit\/([0-9]+)/ ),
		wkversion = !!wkmatch && wkmatch[ 1 ],
		ffmatch = ua.match( /Fennec\/([0-9]+)/ ),
		ffversion = !!ffmatch && ffmatch[ 1 ],
		operammobilematch = ua.match( /Opera Mobi\/([0-9]+)/ ),
		omversion = !!operammobilematch && operammobilematch[ 1 ];

	if(
		// iOS 4.3 and older : Platform is iPhone/Pad/Touch and Webkit version is less than 534 (ios5)
		( ( platform.indexOf( "iPhone" ) > -1 || platform.indexOf( "iPad" ) > -1  || platform.indexOf( "iPod" ) > -1 ) && wkversion && wkversion < 534 ) ||
		// Opera Mini
		( w.operamini && ({}).toString.call( w.operamini ) === "[object OperaMini]" ) ||
		( operammobilematch && omversion < 7458 )	||
		//Android lte 2.1: Platform is Android and Webkit version is less than 533 (Android 2.2)
		( ua.indexOf( "Android" ) > -1 && wkversion && wkversion < 533 ) ||
		// Firefox Mobile before 6.0 -
		( ffversion && ffversion < 6 ) ||
		// WebOS less than 3
		( "palmGetResource" in window && wkversion && wkversion < 534 )	||
		// MeeGo
		( ua.indexOf( "MeeGo" ) > -1 && ua.indexOf( "NokiaBrowser/8.5.0" ) > -1 ) ) {
		return false;
	}

	return true;
}

$.extend( $.support, {
	cssTransitions: "WebKitTransitionEvent" in window ||
		validStyle( 'transition', 'height 100ms linear', [ "Webkit", "Moz", "" ] ) &&
		!$.mobile.browser.oldIE && !opera,

	// Note, Chrome for iOS has an extremely quirky implementation of popstate.
	// We've chosen to take the shortest path to a bug fix here for issue #5426
	// See the following link for information about the regex chosen
	// https://developers.google.com/chrome/mobile/docs/user-agent#chrome_for_ios_user-agent
	pushState: "pushState" in history &&
		"replaceState" in history &&
		// When running inside a FF iframe, calling replaceState causes an error
		!( window.navigator.userAgent.indexOf( "Firefox" ) >= 0 && window.top !== window ) &&
		( window.navigator.userAgent.search(/CriOS/) === -1 ),

	mediaquery: $.mobile.media( "only all" ),
	cssPseudoElement: !!propExists( "content" ),
	touchOverflow: !!propExists( "overflowScrolling" ),
	cssTransform3d: transform3dTest(),
	boxShadow: !!propExists( "boxShadow" ) && !bb,
	fixedPosition: fixedPosition(),
	scrollTop: ("pageXOffset" in window ||
		"scrollTop" in document.documentElement ||
		"scrollTop" in fakeBody[ 0 ]) && !webos && !operamini,

	dynamicBaseTag: baseTagTest(),
	cssPointerEvents: cssPointerEventsTest(),
	boundingRect: boundingRect()
});

fakeBody.remove();


// $.mobile.ajaxBlacklist is used to override ajaxEnabled on platforms that have known conflicts with hash history updates (BB5, Symbian)
// or that generally work better browsing in regular http for full page refreshes (Opera Mini)
// Note: This detection below is used as a last resort.
// We recommend only using these detection methods when all other more reliable/forward-looking approaches are not possible
var nokiaLTE7_3 = (function() {

	var ua = window.navigator.userAgent;

	//The following is an attempt to match Nokia browsers that are running Symbian/s60, with webkit, version 7.3 or older
	return ua.indexOf( "Nokia" ) > -1 &&
			( ua.indexOf( "Symbian/3" ) > -1 || ua.indexOf( "Series60/5" ) > -1 ) &&
			ua.indexOf( "AppleWebKit" ) > -1 &&
			ua.match( /(BrowserNG|NokiaBrowser)\/7\.[0-3]/ );
})();

// Support conditions that must be met in order to proceed
// default enhanced qualifications are media query support OR IE 7+

$.mobile.gradeA = function() {
	return ( $.support.mediaquery || $.mobile.browser.oldIE && $.mobile.browser.oldIE >= 7 ) && ( $.support.boundingRect || $.fn.jquery.match(/1\.[0-7+]\.[0-9+]?/) !== null );
};

$.mobile.ajaxBlacklist =
			// BlackBerry browsers, pre-webkit
			window.blackberry && !window.WebKitPoint ||
			// Opera Mini
			operamini ||
			// Symbian webkits pre 7.3
			nokiaLTE7_3;

// Lastly, this workaround is the only way we've found so far to get pre 7.3 Symbian webkit devices
// to render the stylesheets when they're referenced before this script, as we'd recommend doing.
// This simply reappends the CSS in place, which for some reason makes it apply
if ( nokiaLTE7_3 ) {
	$(function() {
		$( "head link[rel='stylesheet']" ).attr( "rel", "alternate stylesheet" ).attr( "rel", "stylesheet" );
	});
}

// For ruling out shadows via css
if ( !$.support.boxShadow ) {
	$( "html" ).addClass( "ui-mobile-nosupport-boxshadow" );
}

})( jQuery );


(function( $, undefined ) {
	var $win = $.mobile.window, self, history;

	$.event.special.navigate = self = {
		bound: false,

		pushStateEnabled: true,

		originalEventName: undefined,

		// If pushstate support is present and push state support is defined to
		// be true on the mobile namespace.
		isPushStateEnabled: function() {
			return $.support.pushState &&
				$.mobile.pushStateEnabled === true &&
				this.isHashChangeEnabled();
		},

		// !! assumes mobile namespace is present
		isHashChangeEnabled: function() {
			return $.mobile.hashListeningEnabled === true;
		},

		// TODO a lot of duplication between popstate and hashchange
		popstate: function( event ) {
			var newEvent = new $.Event( "navigate" ),
				beforeNavigate = new $.Event( "beforenavigate" ),
				state = event.originalEvent.state || {},
				href = location.href;

			$win.trigger( beforeNavigate );

			if( beforeNavigate.isDefaultPrevented() ){
				return;
			}

			if( event.historyState ){
				$.extend(state, event.historyState);
			}

			// Make sure the original event is tracked for the end
			// user to inspect incase they want to do something special
			newEvent.originalEvent = event;

			// NOTE we let the current stack unwind because any assignment to
			//      location.hash will stop the world and run this event handler. By
			//      doing this we create a similar behavior to hashchange on hash
			//      assignment
			setTimeout(function() {
				$win.trigger( newEvent, {
					state: state
				});
			}, 0);
		},

		hashchange: function( event, data ) {
			var newEvent = new $.Event( "navigate" ),
				beforeNavigate = new $.Event( "beforenavigate" );

			$win.trigger( beforeNavigate );

			if( beforeNavigate.isDefaultPrevented() ){
				return;
			}

			// Make sure the original event is tracked for the end
			// user to inspect incase they want to do something special
			newEvent.originalEvent = event;

			// Trigger the hashchange with state provided by the user
			// that altered the hash
			$win.trigger( newEvent, {
				// Users that want to fully normalize the two events
				// will need to do history management down the stack and
				// add the state to the event before this binding is fired
				// TODO consider allowing for the explicit addition of callbacks
				//      to be fired before this value is set to avoid event timing issues
				state: event.hashchangeState || {}
			});
		},

		// TODO We really only want to set this up once
		//      but I'm not clear if there's a beter way to achieve
		//      this with the jQuery special event structure
		setup: function( data, namespaces ) {
			if( self.bound ) {
				return;
			}

			self.bound = true;

			if( self.isPushStateEnabled() ) {
				self.originalEventName = "popstate";
				$win.bind( "popstate.navigate", self.popstate );
			} else if ( self.isHashChangeEnabled() ){
				self.originalEventName = "hashchange";
				$win.bind( "hashchange.navigate", self.hashchange );
			}
		}
	};
})( jQuery );



(function( $, undefined ) {
		var path, documentBase, $base, dialogHashKey = "&ui-state=dialog";

		$.mobile.path = path = {
			uiStateKey: "&ui-state",

			// This scary looking regular expression parses an absolute URL or its relative
			// variants (protocol, site, document, query, and hash), into the various
			// components (protocol, host, path, query, fragment, etc that make up the
			// URL as well as some other commonly used sub-parts. When used with RegExp.exec()
			// or String.match, it parses the URL into a results array that looks like this:
			//
			//     [0]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread#msg-content
			//     [1]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread
			//     [2]: http://jblas:password@mycompany.com:8080/mail/inbox
			//     [3]: http://jblas:password@mycompany.com:8080
			//     [4]: http:
			//     [5]: //
			//     [6]: jblas:password@mycompany.com:8080
			//     [7]: jblas:password
			//     [8]: jblas
			//     [9]: password
			//    [10]: mycompany.com:8080
			//    [11]: mycompany.com
			//    [12]: 8080
			//    [13]: /mail/inbox
			//    [14]: /mail/
			//    [15]: inbox
			//    [16]: ?msg=1234&type=unread
			//    [17]: #msg-content
			//
			urlParseRE: /^\s*(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/,

			// Abstraction to address xss (Issue #4787) by removing the authority in
			// browsers that auto	decode it. All references to location.href should be
			// replaced with a call to this method so that it can be dealt with properly here
			getLocation: function( url ) {
				var uri = url ? this.parseUrl( url ) : location,
					hash = this.parseUrl( url || location.href ).hash;

				// mimic the browser with an empty string when the hash is empty
				hash = hash === "#" ? "" : hash;

				// Make sure to parse the url or the location object for the hash because using location.hash
				// is autodecoded in firefox, the rest of the url should be from the object (location unless
				// we're testing) to avoid the inclusion of the authority
				return uri.protocol + "//" + uri.host + uri.pathname + uri.search + hash;
			},

			parseLocation: function() {
				return this.parseUrl( this.getLocation() );
			},

			//Parse a URL into a structure that allows easy access to
			//all of the URL components by name.
			parseUrl: function( url ) {
				// If we're passed an object, we'll assume that it is
				// a parsed url object and just return it back to the caller.
				if ( $.type( url ) === "object" ) {
					return url;
				}

				var matches = path.urlParseRE.exec( url || "" ) || [];

					// Create an object that allows the caller to access the sub-matches
					// by name. Note that IE returns an empty string instead of undefined,
					// like all other browsers do, so we normalize everything so its consistent
					// no matter what browser we're running on.
					return {
						href:         matches[  0 ] || "",
						hrefNoHash:   matches[  1 ] || "",
						hrefNoSearch: matches[  2 ] || "",
						domain:       matches[  3 ] || "",
						protocol:     matches[  4 ] || "",
						doubleSlash:  matches[  5 ] || "",
						authority:    matches[  6 ] || "",
						username:     matches[  8 ] || "",
						password:     matches[  9 ] || "",
						host:         matches[ 10 ] || "",
						hostname:     matches[ 11 ] || "",
						port:         matches[ 12 ] || "",
						pathname:     matches[ 13 ] || "",
						directory:    matches[ 14 ] || "",
						filename:     matches[ 15 ] || "",
						search:       matches[ 16 ] || "",
						hash:         matches[ 17 ] || ""
					};
			},

			//Turn relPath into an asbolute path. absPath is
			//an optional absolute path which describes what
			//relPath is relative to.
			makePathAbsolute: function( relPath, absPath ) {
				if ( relPath && relPath.charAt( 0 ) === "/" ) {
					return relPath;
				}

				relPath = relPath || "";
				absPath = absPath ? absPath.replace( /^\/|(\/[^\/]*|[^\/]+)$/g, "" ) : "";

				var absStack = absPath ? absPath.split( "/" ) : [],
					relStack = relPath.split( "/" );
				for ( var i = 0; i < relStack.length; i++ ) {
					var d = relStack[ i ];
					switch ( d ) {
						case ".":
							break;
						case "..":
							if ( absStack.length ) {
								absStack.pop();
							}
							break;
						default:
							absStack.push( d );
							break;
					}
				}
				return "/" + absStack.join( "/" );
			},

			//Returns true if both urls have the same domain.
			isSameDomain: function( absUrl1, absUrl2 ) {
				return path.parseUrl( absUrl1 ).domain === path.parseUrl( absUrl2 ).domain;
			},

			//Returns true for any relative variant.
			isRelativeUrl: function( url ) {
				// All relative Url variants have one thing in common, no protocol.
				return path.parseUrl( url ).protocol === "";
			},

			//Returns true for an absolute url.
			isAbsoluteUrl: function( url ) {
				return path.parseUrl( url ).protocol !== "";
			},

			//Turn the specified realtive URL into an absolute one. This function
			//can handle all relative variants (protocol, site, document, query, fragment).
			makeUrlAbsolute: function( relUrl, absUrl ) {
				if ( !path.isRelativeUrl( relUrl ) ) {
					return relUrl;
				}

				if ( absUrl === undefined ) {
					absUrl = this.documentBase;
				}

				var relObj = path.parseUrl( relUrl ),
					absObj = path.parseUrl( absUrl ),
					protocol = relObj.protocol || absObj.protocol,
					doubleSlash = relObj.protocol ? relObj.doubleSlash : ( relObj.doubleSlash || absObj.doubleSlash ),
					authority = relObj.authority || absObj.authority,
					hasPath = relObj.pathname !== "",
					pathname = path.makePathAbsolute( relObj.pathname || absObj.filename, absObj.pathname ),
					search = relObj.search || ( !hasPath && absObj.search ) || "",
					hash = relObj.hash;

				return protocol + doubleSlash + authority + pathname + search + hash;
			},

			//Add search (aka query) params to the specified url.
			addSearchParams: function( url, params ) {
				var u = path.parseUrl( url ),
					p = ( typeof params === "object" ) ? $.param( params ) : params,
					s = u.search || "?";
				return u.hrefNoSearch + s + ( s.charAt( s.length - 1 ) !== "?" ? "&" : "" ) + p + ( u.hash || "" );
			},

			convertUrlToDataUrl: function( absUrl ) {
				var u = path.parseUrl( absUrl );
				if ( path.isEmbeddedPage( u ) ) {
					// For embedded pages, remove the dialog hash key as in getFilePath(),
					// and remove otherwise the Data Url won't match the id of the embedded Page.
					return u.hash
						.split( dialogHashKey )[0]
						.replace( /^#/, "" )
						.replace( /\?.*$/, "" );
				} else if ( path.isSameDomain( u, this.documentBase ) ) {
					return u.hrefNoHash.replace( this.documentBase.domain, "" ).split( dialogHashKey )[0];
				}

				return window.decodeURIComponent(absUrl);
			},

			//get path from current hash, or from a file path
			get: function( newPath ) {
				if ( newPath === undefined ) {
					newPath = path.parseLocation().hash;
				}
				return path.stripHash( newPath ).replace( /[^\/]*\.[^\/*]+$/, '' );
			},

			//set location hash to path
			set: function( path ) {
				location.hash = path;
			},

			//test if a given url (string) is a path
			//NOTE might be exceptionally naive
			isPath: function( url ) {
				return ( /\// ).test( url );
			},

			//return a url path with the window's location protocol/hostname/pathname removed
			clean: function( url ) {
				return url.replace( this.documentBase.domain, "" );
			},

			//just return the url without an initial #
			stripHash: function( url ) {
				return url.replace( /^#/, "" );
			},

			stripQueryParams: function( url ) {
				return url.replace( /\?.*$/, "" );
			},

			//remove the preceding hash, any query params, and dialog notations
			cleanHash: function( hash ) {
				return path.stripHash( hash.replace( /\?.*$/, "" ).replace( dialogHashKey, "" ) );
			},

			isHashValid: function( hash ) {
				return ( /^#[^#]+$/ ).test( hash );
			},

			//check whether a url is referencing the same domain, or an external domain or different protocol
			//could be mailto, etc
			isExternal: function( url ) {
				var u = path.parseUrl( url );
				return u.protocol && u.domain !== this.documentUrl.domain ? true : false;
			},

			hasProtocol: function( url ) {
				return ( /^(:?\w+:)/ ).test( url );
			},

			isEmbeddedPage: function( url ) {
				var u = path.parseUrl( url );

				//if the path is absolute, then we need to compare the url against
				//both the this.documentUrl and the documentBase. The main reason for this
				//is that links embedded within external documents will refer to the
				//application document, whereas links embedded within the application
				//document will be resolved against the document base.
				if ( u.protocol !== "" ) {
					return ( !this.isPath(u.hash) && u.hash && ( u.hrefNoHash === this.documentUrl.hrefNoHash || ( this.documentBaseDiffers && u.hrefNoHash === this.documentBase.hrefNoHash ) ) );
				}
				return ( /^#/ ).test( u.href );
			},

			squash: function( url, resolutionUrl ) {
				var state, href, cleanedUrl, search, stateIndex,
					isPath = this.isPath( url ),
					uri = this.parseUrl( url ),
					preservedHash = uri.hash,
					uiState = "";

				// produce a url against which we can resole the provided path
				resolutionUrl = resolutionUrl || (path.isPath(url) ? path.getLocation() : path.getDocumentUrl());

				// If the url is anything but a simple string, remove any preceding hash
				// eg #foo/bar -> foo/bar
				//    #foo -> #foo
				cleanedUrl = isPath ? path.stripHash( url ) : url;

				// If the url is a full url with a hash check if the parsed hash is a path
				// if it is, strip the #, and use it otherwise continue without change
				cleanedUrl = path.isPath( uri.hash ) ? path.stripHash( uri.hash ) : cleanedUrl;

				// Split the UI State keys off the href
				stateIndex = cleanedUrl.indexOf( this.uiStateKey );

				// store the ui state keys for use
				if( stateIndex > -1 ){
					uiState = cleanedUrl.slice( stateIndex );
					cleanedUrl = cleanedUrl.slice( 0, stateIndex );
				}

				// make the cleanedUrl absolute relative to the resolution url
				href = path.makeUrlAbsolute( cleanedUrl, resolutionUrl );

				// grab the search from the resolved url since parsing from
				// the passed url may not yield the correct result
				search = this.parseUrl( href ).search;

				// TODO all this crap is terrible, clean it up
				if ( isPath ) {
					// reject the hash if it's a path or it's just a dialog key
					if( path.isPath( preservedHash ) || preservedHash.replace("#", "").indexOf( this.uiStateKey ) === 0) {
						preservedHash = "";
					}

					// Append the UI State keys where it exists and it's been removed
					// from the url
					if( uiState && preservedHash.indexOf( this.uiStateKey ) === -1){
						preservedHash += uiState;
					}

					// make sure that pound is on the front of the hash
					if( preservedHash.indexOf( "#" ) === -1 && preservedHash !== "" ){
						preservedHash = "#" + preservedHash;
					}

					// reconstruct each of the pieces with the new search string and hash
					href = path.parseUrl( href );
					href = href.protocol + "//" + href.host + href.pathname + search + preservedHash;
				} else {
					href += href.indexOf( "#" ) > -1 ? uiState : "#" + uiState;
				}

				return href;
			},

			isPreservableHash: function( hash ) {
				return hash.replace( "#", "" ).indexOf( this.uiStateKey ) === 0;
			}
		};

		path.documentUrl = path.parseLocation();

		$base = $( "head" ).find( "base" );

		path.documentBase = $base.length ?
			path.parseUrl( path.makeUrlAbsolute( $base.attr( "href" ), path.documentUrl.href ) ) :
			path.documentUrl;

		path.documentBaseDiffers = (path.documentUrl.hrefNoHash !== path.documentBase.hrefNoHash);

		//return the original document url
		path.getDocumentUrl = function( asParsedObject ) {
			return asParsedObject ? $.extend( {}, path.documentUrl ) : path.documentUrl.href;
		};

		//return the original document base url
		path.getDocumentBase = function( asParsedObject ) {
			return asParsedObject ? $.extend( {}, path.documentBase ) : path.documentBase.href;
		};
})( jQuery );



(function( $, undefined ) {
	var path = $.mobile.path;

	$.mobile.History = function( stack, index ) {
		this.stack = stack || [];
		this.activeIndex = index || 0;
	};

	$.extend($.mobile.History.prototype, {
		getActive: function() {
			return this.stack[ this.activeIndex ];
		},

		getLast: function() {
			return this.stack[ this.previousIndex ];
		},

		getNext: function() {
			return this.stack[ this.activeIndex + 1 ];
		},

		getPrev: function() {
			return this.stack[ this.activeIndex - 1 ];
		},

		// addNew is used whenever a new page is added
		add: function( url, data ){
			data = data || {};

			//if there's forward history, wipe it
			if ( this.getNext() ) {
				this.clearForward();
			}

			// if the hash is included in the data make sure the shape
			// is consistent for comparison
			if( data.hash && data.hash.indexOf( "#" ) === -1) {
				data.hash = "#" + data.hash;
			}

			data.url = url;
			this.stack.push( data );
			this.activeIndex = this.stack.length - 1;
		},

		//wipe urls ahead of active index
		clearForward: function() {
			this.stack = this.stack.slice( 0, this.activeIndex + 1 );
		},

		find: function( url, stack, earlyReturn ) {
			stack = stack || this.stack;

			var entry, i, length = stack.length, index;

			for ( i = 0; i < length; i++ ) {
				entry = stack[i];

				if ( decodeURIComponent(url) === decodeURIComponent(entry.url) ||
					decodeURIComponent(url) === decodeURIComponent(entry.hash) ) {
					index = i;

					if( earlyReturn ) {
						return index;
					}
				}
			}

			return index;
		},

		closest: function( url ) {
			var closest, a = this.activeIndex;

			// First, take the slice of the history stack before the current index and search
			// for a url match. If one is found, we'll avoid avoid looking through forward history
			// NOTE the preference for backward history movement is driven by the fact that
			//      most mobile browsers only have a dedicated back button, and users rarely use
			//      the forward button in desktop browser anyhow
			closest = this.find( url, this.stack.slice(0, a) );

			// If nothing was found in backward history check forward. The `true`
			// value passed as the third parameter causes the find method to break
			// on the first match in the forward history slice. The starting index
			// of the slice must then be added to the result to get the element index
			// in the original history stack :( :(
			//
			// TODO this is hyper confusing and should be cleaned up (ugh so bad)
			if( closest === undefined ) {
				closest = this.find( url, this.stack.slice(a), true );
				closest = closest === undefined ? closest : closest + a;
			}

			return closest;
		},

		direct: function( opts ) {
			var newActiveIndex = this.closest( opts.url ), a = this.activeIndex;

			// save new page index, null check to prevent falsey 0 result
			// record the previous index for reference
			if( newActiveIndex !== undefined ) {
				this.activeIndex = newActiveIndex;
				this.previousIndex = a;
			}

			// invoke callbacks where appropriate
			//
			// TODO this is also convoluted and confusing
			if ( newActiveIndex < a ) {
				( opts.present || opts.back || $.noop )( this.getActive(), 'back' );
			} else if ( newActiveIndex > a ) {
				( opts.present || opts.forward || $.noop )( this.getActive(), 'forward' );
			} else if ( newActiveIndex === undefined && opts.missing ){
				opts.missing( this.getActive() );
			}
		}
	});
})( jQuery );


(function( $, undefined ) {
	var path = $.mobile.path,
		initialHref = location.href;

	$.mobile.Navigator = function( history ) {
		this.history = history;
		this.ignoreInitialHashChange = true;

		$.mobile.window.bind({
			"popstate.history": $.proxy( this.popstate, this ),
			"hashchange.history": $.proxy( this.hashchange, this )
		});
	};

	$.extend($.mobile.Navigator.prototype, {
		squash: function( url, data ) {
			var state, href, hash = path.isPath(url) ? path.stripHash(url) : url;

			href = path.squash( url );

			// make sure to provide this information when it isn't explicitly set in the
			// data object that was passed to the squash method
			state = $.extend({
				hash: hash,
				url: href
			}, data);

			// replace the current url with the new href and store the state
			// Note that in some cases we might be replacing an url with the
			// same url. We do this anyways because we need to make sure that
			// all of our history entries have a state object associated with
			// them. This allows us to work around the case where $.mobile.back()
			// is called to transition from an external page to an embedded page.
			// In that particular case, a hashchange event is *NOT* generated by the browser.
			// Ensuring each history entry has a state object means that onPopState()
			// will always trigger our hashchange callback even when a hashchange event
			// is not fired.
			window.history.replaceState( state, state.title || document.title, href );

			return state;
		},

		hash: function( url, href ) {
			var parsed, loc, hash;

			// Grab the hash for recording. If the passed url is a path
			// we used the parsed version of the squashed url to reconstruct,
			// otherwise we assume it's a hash and store it directly
			parsed = path.parseUrl( url );
			loc = path.parseLocation();

			if( loc.pathname + loc.search === parsed.pathname + parsed.search ) {
				// If the pathname and search of the passed url is identical to the current loc
				// then we must use the hash. Otherwise there will be no event
				// eg, url = "/foo/bar?baz#bang", location.href = "http://example.com/foo/bar?baz"
				hash = parsed.hash ? parsed.hash : parsed.pathname + parsed.search;
			} else if ( path.isPath(url) ) {
				var resolved = path.parseUrl( href );
				// If the passed url is a path, make it domain relative and remove any trailing hash
				hash = resolved.pathname + resolved.search + (path.isPreservableHash( resolved.hash )? resolved.hash.replace( "#", "" ) : "");
			} else {
				hash = url;
			}

			return hash;
		},

		// TODO reconsider name
		go: function( url, data, noEvents ) {
			var state, href, hash, popstateEvent,
				isPopStateEvent = $.event.special.navigate.isPushStateEnabled();

			// Get the url as it would look squashed on to the current resolution url
			href = path.squash( url );

			// sort out what the hash sould be from the url
			hash = this.hash( url, href );

			// Here we prevent the next hash change or popstate event from doing any
			// history management. In the case of hashchange we don't swallow it
			// if there will be no hashchange fired (since that won't reset the value)
			// and will swallow the following hashchange
			if( noEvents && hash !== path.stripHash(path.parseLocation().hash) ) {
				this.preventNextHashChange = noEvents;
			}

			// IMPORTANT in the case where popstate is supported the event will be triggered
			//      directly, stopping further execution - ie, interupting the flow of this
			//      method call to fire bindings at this expression. Below the navigate method
			//      there is a binding to catch this event and stop its propagation.
			//
			//      We then trigger a new popstate event on the window with a null state
			//      so that the navigate events can conclude their work properly
			//
			// if the url is a path we want to preserve the query params that are available on
			// the current url.
			this.preventHashAssignPopState = true;
			window.location.hash = hash;

			// If popstate is enabled and the browser triggers `popstate` events when the hash
			// is set (this often happens immediately in browsers like Chrome), then the
			// this flag will be set to false already. If it's a browser that does not trigger
			// a `popstate` on hash assignement or `replaceState` then we need avoid the branch
			// that swallows the event created by the popstate generated by the hash assignment
			// At the time of this writing this happens with Opera 12 and some version of IE
			this.preventHashAssignPopState = false;

			state = $.extend({
				url: href,
				hash: hash,
				title: document.title
			}, data);

			if( isPopStateEvent ) {
				popstateEvent = new $.Event( "popstate" );
				popstateEvent.originalEvent = {
					type: "popstate",
					state: null
				};

				this.squash( url, state );

				// Trigger a new faux popstate event to replace the one that we
				// caught that was triggered by the hash setting above.
				if( !noEvents ) {
					this.ignorePopState = true;
					$.mobile.window.trigger( popstateEvent );
				}
			}

			// record the history entry so that the information can be included
			// in hashchange event driven navigate events in a similar fashion to
			// the state that's provided by popstate
			this.history.add( state.url, state );
		},


		// This binding is intended to catch the popstate events that are fired
		// when execution of the `$.navigate` method stops at window.location.hash = url;
		// and completely prevent them from propagating. The popstate event will then be
		// retriggered after execution resumes
		//
		// TODO grab the original event here and use it for the synthetic event in the
		//      second half of the navigate execution that will follow this binding
		popstate: function( event ) {
			var active, hash, state, closestIndex;

			// Partly to support our test suite which manually alters the support
			// value to test hashchange. Partly to prevent all around weirdness
			if( !$.event.special.navigate.isPushStateEnabled() ){
				return;
			}

			// If this is the popstate triggered by the actual alteration of the hash
			// prevent it completely. History is tracked manually
			if( this.preventHashAssignPopState ) {
				this.preventHashAssignPopState = false;
				event.stopImmediatePropagation();
				return;
			}

			// if this is the popstate triggered after the `replaceState` call in the go
			// method, then simply ignore it. The history entry has already been captured
			if( this.ignorePopState ) {
				this.ignorePopState = false;
				return;
			}

			// If there is no state, and the history stack length is one were
			// probably getting the page load popstate fired by browsers like chrome
			// avoid it and set the one time flag to false.
			// TODO: Do we really need all these conditions? Comparing location hrefs
			// should be sufficient.
			if( !event.originalEvent.state &&
				this.history.stack.length === 1 &&
				this.ignoreInitialHashChange ) {
				this.ignoreInitialHashChange = false;

				if ( location.href === initialHref ) {
					event.preventDefault();
					return;
				}
			}

			// account for direct manipulation of the hash. That is, we will receive a popstate
			// when the hash is changed by assignment, and it won't have a state associated. We
			// then need to squash the hash. See below for handling of hash assignment that
			// matches an existing history entry
			// TODO it might be better to only add to the history stack
			//      when the hash is adjacent to the active history entry
			hash = path.parseLocation().hash;
			if( !event.originalEvent.state && hash ) {
				// squash the hash that's been assigned on the URL with replaceState
				// also grab the resulting state object for storage
				state = this.squash( hash );

				// record the new hash as an additional history entry
				// to match the browser's treatment of hash assignment
				this.history.add( state.url, state );

				// pass the newly created state information
				// along with the event
				event.historyState = state;

				// do not alter history, we've added a new history entry
				// so we know where we are
				return;
			}

			// If all else fails this is a popstate that comes from the back or forward buttons
			// make sure to set the state of our history stack properly, and record the directionality
			this.history.direct({
				url: (event.originalEvent.state || {}).url || hash,

				// When the url is either forward or backward in history include the entry
				// as data on the event object for merging as data in the navigate event
				present: function( historyEntry, direction ) {
					// make sure to create a new object to pass down as the navigate event data
					event.historyState = $.extend({}, historyEntry);
					event.historyState.direction = direction;
				}
			});
		},

		// NOTE must bind before `navigate` special event hashchange binding otherwise the
		//      navigation data won't be attached to the hashchange event in time for those
		//      bindings to attach it to the `navigate` special event
		// TODO add a check here that `hashchange.navigate` is bound already otherwise it's
		//      broken (exception?)
		hashchange: function( event ) {
			var history, hash;

			// If hashchange listening is explicitly disabled or pushstate is supported
			// avoid making use of the hashchange handler.
			if(!$.event.special.navigate.isHashChangeEnabled() ||
				$.event.special.navigate.isPushStateEnabled() ) {
				return;
			}

			// On occasion explicitly want to prevent the next hash from propogating because we only
			// with to alter the url to represent the new state do so here
			if( this.preventNextHashChange ){
				this.preventNextHashChange = false;
				event.stopImmediatePropagation();
				return;
			}

			history = this.history;
			hash = path.parseLocation().hash;

			// If this is a hashchange caused by the back or forward button
			// make sure to set the state of our history stack properly
			this.history.direct({
				url: hash,

				// When the url is either forward or backward in history include the entry
				// as data on the event object for merging as data in the navigate event
				present: function( historyEntry, direction ) {
					// make sure to create a new object to pass down as the navigate event data
					event.hashchangeState = $.extend({}, historyEntry);
					event.hashchangeState.direction = direction;
				},

				// When we don't find a hash in our history clearly we're aiming to go there
				// record the entry as new for future traversal
				//
				// NOTE it's not entirely clear that this is the right thing to do given that we
				//      can't know the users intention. It might be better to explicitly _not_
				//      support location.hash assignment in preference to $.navigate calls
				// TODO first arg to add should be the href, but it causes issues in identifying
				//      embeded pages
				missing: function() {
					history.add( hash, {
						hash: hash,
						title: document.title
					});
				}
			});
		}
	});
})( jQuery );



(function( $, undefined ) {
	// TODO consider queueing navigation activity until previous activities have completed
	//      so that end users don't have to think about it. Punting for now
	// TODO !! move the event bindings into callbacks on the navigate event
	$.mobile.navigate = function( url, data, noEvents ) {
		$.mobile.navigate.navigator.go( url, data, noEvents );
	};

	// expose the history on the navigate method in anticipation of full integration with
	// existing navigation functionalty that is tightly coupled to the history information
	$.mobile.navigate.history = new $.mobile.History();

	// instantiate an instance of the navigator for use within the $.navigate method
	$.mobile.navigate.navigator = new $.mobile.Navigator( $.mobile.navigate.history );

	var loc = $.mobile.path.parseLocation();
	$.mobile.navigate.history.add( loc.href, {hash: loc.hash} );
})( jQuery );


// This plugin is an experiment for abstracting away the touch and mouse
// events so that developers don't have to worry about which method of input
// the device their document is loaded on supports.
//
// The idea here is to allow the developer to register listeners for the
// basic mouse events, such as mousedown, mousemove, mouseup, and click,
// and the plugin will take care of registering the correct listeners
// behind the scenes to invoke the listener at the fastest possible time
// for that device, while still retaining the order of event firing in
// the traditional mouse environment, should multiple handlers be registered
// on the same element for different events.
//
// The current version exposes the following virtual events to jQuery bind methods:
// "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

(function( $, window, document, undefined ) {

var dataPropertyName = "virtualMouseBindings",
	touchTargetPropertyName = "virtualTouchID",
	virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split( " " ),
	touchEventProps = "clientX clientY pageX pageY screenX screenY".split( " " ),
	mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
	mouseEventProps = $.event.props.concat( mouseHookProps ),
	activeDocHandlers = {},
	resetTimerID = 0,
	startX = 0,
	startY = 0,
	didScroll = false,
	clickBlockList = [],
	blockMouseTriggers = false,
	blockTouchTriggers = false,
	eventCaptureSupported = "addEventListener" in document,
	$document = $( document ),
	nextTouchID = 1,
	lastTouchID = 0, threshold;

$.vmouse = {
	moveDistanceThreshold: 10,
	clickDistanceThreshold: 10,
	resetTimerDuration: 1500
};

function getNativeEvent( event ) {

	while ( event && typeof event.originalEvent !== "undefined" ) {
		event = event.originalEvent;
	}
	return event;
}

function createVirtualEvent( event, eventType ) {

	var t = event.type,
		oe, props, ne, prop, ct, touch, i, j, len;

	event = $.Event( event );
	event.type = eventType;

	oe = event.originalEvent;
	props = $.event.props;

	// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
	// https://github.com/jquery/jquery-mobile/issues/3280
	if ( t.search( /^(mouse|click)/ ) > -1 ) {
		props = mouseEventProps;
	}

	// copy original event properties over to the new event
	// this would happen if we could call $.event.fix instead of $.Event
	// but we don't have a way to force an event to be fixed multiple times
	if ( oe ) {
		for ( i = props.length, prop; i; ) {
			prop = props[ --i ];
			event[ prop ] = oe[ prop ];
		}
	}

	// make sure that if the mouse and click virtual events are generated
	// without a .which one is defined
	if ( t.search(/mouse(down|up)|click/) > -1 && !event.which ) {
		event.which = 1;
	}

	if ( t.search(/^touch/) !== -1 ) {
		ne = getNativeEvent( oe );
		t = ne.touches;
		ct = ne.changedTouches;
		touch = ( t && t.length ) ? t[0] : ( ( ct && ct.length ) ? ct[ 0 ] : undefined );

		if ( touch ) {
			for ( j = 0, len = touchEventProps.length; j < len; j++) {
				prop = touchEventProps[ j ];
				event[ prop ] = touch[ prop ];
			}
		}
	}

	return event;
}

function getVirtualBindingFlags( element ) {

	var flags = {},
		b, k;

	while ( element ) {

		b = $.data( element, dataPropertyName );

		for (  k in b ) {
			if ( b[ k ] ) {
				flags[ k ] = flags.hasVirtualBinding = true;
			}
		}
		element = element.parentNode;
	}
	return flags;
}

function getClosestElementWithVirtualBinding( element, eventType ) {
	var b;
	while ( element ) {

		b = $.data( element, dataPropertyName );

		if ( b && ( !eventType || b[ eventType ] ) ) {
			return element;
		}
		element = element.parentNode;
	}
	return null;
}

function enableTouchBindings() {
	blockTouchTriggers = false;
}

function disableTouchBindings() {
	blockTouchTriggers = true;
}

function enableMouseBindings() {
	lastTouchID = 0;
	clickBlockList.length = 0;
	blockMouseTriggers = false;

	// When mouse bindings are enabled, our
	// touch bindings are disabled.
	disableTouchBindings();
}

function disableMouseBindings() {
	// When mouse bindings are disabled, our
	// touch bindings are enabled.
	enableTouchBindings();
}

function startResetTimer() {
	clearResetTimer();
	resetTimerID = setTimeout( function() {
		resetTimerID = 0;
		enableMouseBindings();
	}, $.vmouse.resetTimerDuration );
}

function clearResetTimer() {
	if ( resetTimerID ) {
		clearTimeout( resetTimerID );
		resetTimerID = 0;
	}
}

function triggerVirtualEvent( eventType, event, flags ) {
	var ve;

	if ( ( flags && flags[ eventType ] ) ||
				( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {

		ve = createVirtualEvent( event, eventType );

		$( event.target).trigger( ve );
	}

	return ve;
}

function mouseEventCallback( event ) {
	var touchID = $.data( event.target, touchTargetPropertyName );

	if ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ) {
		var ve = triggerVirtualEvent( "v" + event.type, event );
		if ( ve ) {
			if ( ve.isDefaultPrevented() ) {
				event.preventDefault();
			}
			if ( ve.isPropagationStopped() ) {
				event.stopPropagation();
			}
			if ( ve.isImmediatePropagationStopped() ) {
				event.stopImmediatePropagation();
			}
		}
	}
}

function handleTouchStart( event ) {

	var touches = getNativeEvent( event ).touches,
		target, flags;

	if ( touches && touches.length === 1 ) {

		target = event.target;
		flags = getVirtualBindingFlags( target );

		if ( flags.hasVirtualBinding ) {

			lastTouchID = nextTouchID++;
			$.data( target, touchTargetPropertyName, lastTouchID );

			clearResetTimer();

			disableMouseBindings();
			didScroll = false;

			var t = getNativeEvent( event ).touches[ 0 ];
			startX = t.pageX;
			startY = t.pageY;

			triggerVirtualEvent( "vmouseover", event, flags );
			triggerVirtualEvent( "vmousedown", event, flags );
		}
	}
}

function handleScroll( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	if ( !didScroll ) {
		triggerVirtualEvent( "vmousecancel", event, getVirtualBindingFlags( event.target ) );
	}

	didScroll = true;
	startResetTimer();
}

function handleTouchMove( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	var t = getNativeEvent( event ).touches[ 0 ],
		didCancel = didScroll,
		moveThreshold = $.vmouse.moveDistanceThreshold,
		flags = getVirtualBindingFlags( event.target );

		didScroll = didScroll ||
			( Math.abs( t.pageX - startX ) > moveThreshold ||
				Math.abs( t.pageY - startY ) > moveThreshold );


	if ( didScroll && !didCancel ) {
		triggerVirtualEvent( "vmousecancel", event, flags );
	}

	triggerVirtualEvent( "vmousemove", event, flags );
	startResetTimer();
}

function handleTouchEnd( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	disableTouchBindings();

	var flags = getVirtualBindingFlags( event.target ),
		t;
	triggerVirtualEvent( "vmouseup", event, flags );

	if ( !didScroll ) {
		var ve = triggerVirtualEvent( "vclick", event, flags );
		if ( ve && ve.isDefaultPrevented() ) {
			// The target of the mouse events that follow the touchend
			// event don't necessarily match the target used during the
			// touch. This means we need to rely on coordinates for blocking
			// any click that is generated.
			t = getNativeEvent( event ).changedTouches[ 0 ];
			clickBlockList.push({
				touchID: lastTouchID,
				x: t.clientX,
				y: t.clientY
			});

			// Prevent any mouse events that follow from triggering
			// virtual event notifications.
			blockMouseTriggers = true;
		}
	}
	triggerVirtualEvent( "vmouseout", event, flags);
	didScroll = false;

	startResetTimer();
}

function hasVirtualBindings( ele ) {
	var bindings = $.data( ele, dataPropertyName ),
		k;

	if ( bindings ) {
		for ( k in bindings ) {
			if ( bindings[ k ] ) {
				return true;
			}
		}
	}
	return false;
}

function dummyMouseHandler() {}

function getSpecialEventObject( eventType ) {
	var realType = eventType.substr( 1 );

	return {
		setup: function( data, namespace ) {
			// If this is the first virtual mouse binding for this element,
			// add a bindings object to its data.

			if ( !hasVirtualBindings( this ) ) {
				$.data( this, dataPropertyName, {} );
			}

			// If setup is called, we know it is the first binding for this
			// eventType, so initialize the count for the eventType to zero.
			var bindings = $.data( this, dataPropertyName );
			bindings[ eventType ] = true;

			// If this is the first virtual mouse event for this type,
			// register a global handler on the document.

			activeDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;

			if ( activeDocHandlers[ eventType ] === 1 ) {
				$document.bind( realType, mouseEventCallback );
			}

			// Some browsers, like Opera Mini, won't dispatch mouse/click events
			// for elements unless they actually have handlers registered on them.
			// To get around this, we register dummy handlers on the elements.

			$( this ).bind( realType, dummyMouseHandler );

			// For now, if event capture is not supported, we rely on mouse handlers.
			if ( eventCaptureSupported ) {
				// If this is the first virtual mouse binding for the document,
				// register our touchstart handler on the document.

				activeDocHandlers[ "touchstart" ] = ( activeDocHandlers[ "touchstart" ] || 0) + 1;

				if ( activeDocHandlers[ "touchstart" ] === 1 ) {
					$document.bind( "touchstart", handleTouchStart )
						.bind( "touchend", handleTouchEnd )

						// On touch platforms, touching the screen and then dragging your finger
						// causes the window content to scroll after some distance threshold is
						// exceeded. On these platforms, a scroll prevents a click event from being
						// dispatched, and on some platforms, even the touchend is suppressed. To
						// mimic the suppression of the click event, we need to watch for a scroll
						// event. Unfortunately, some platforms like iOS don't dispatch scroll
						// events until *AFTER* the user lifts their finger (touchend). This means
						// we need to watch both scroll and touchmove events to figure out whether
						// or not a scroll happenens before the touchend event is fired.

						.bind( "touchmove", handleTouchMove )
						.bind( "scroll", handleScroll );
				}
			}
		},

		teardown: function( data, namespace ) {
			// If this is the last virtual binding for this eventType,
			// remove its global handler from the document.

			--activeDocHandlers[ eventType ];

			if ( !activeDocHandlers[ eventType ] ) {
				$document.unbind( realType, mouseEventCallback );
			}

			if ( eventCaptureSupported ) {
				// If this is the last virtual mouse binding in existence,
				// remove our document touchstart listener.

				--activeDocHandlers[ "touchstart" ];

				if ( !activeDocHandlers[ "touchstart" ] ) {
					$document.unbind( "touchstart", handleTouchStart )
						.unbind( "touchmove", handleTouchMove )
						.unbind( "touchend", handleTouchEnd )
						.unbind( "scroll", handleScroll );
				}
			}

			var $this = $( this ),
				bindings = $.data( this, dataPropertyName );

			// teardown may be called when an element was
			// removed from the DOM. If this is the case,
			// jQuery core may have already stripped the element
			// of any data bindings so we need to check it before
			// using it.
			if ( bindings ) {
				bindings[ eventType ] = false;
			}

			// Unregister the dummy event handler.

			$this.unbind( realType, dummyMouseHandler );

			// If this is the last virtual mouse binding on the
			// element, remove the binding data from the element.

			if ( !hasVirtualBindings( this ) ) {
				$this.removeData( dataPropertyName );
			}
		}
	};
}

// Expose our custom events to the jQuery bind/unbind mechanism.

for ( var i = 0; i < virtualEventNames.length; i++ ) {
	$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );
}

// Add a capture click handler to block clicks.
// Note that we require event capture support for this so if the device
// doesn't support it, we punt for now and rely solely on mouse events.
if ( eventCaptureSupported ) {
	document.addEventListener( "click", function( e ) {
		var cnt = clickBlockList.length,
			target = e.target,
			x, y, ele, i, o, touchID;

		if ( cnt ) {
			x = e.clientX;
			y = e.clientY;
			threshold = $.vmouse.clickDistanceThreshold;

			// The idea here is to run through the clickBlockList to see if
			// the current click event is in the proximity of one of our
			// vclick events that had preventDefault() called on it. If we find
			// one, then we block the click.
			//
			// Why do we have to rely on proximity?
			//
			// Because the target of the touch event that triggered the vclick
			// can be different from the target of the click event synthesized
			// by the browser. The target of a mouse/click event that is syntehsized
			// from a touch event seems to be implementation specific. For example,
			// some browsers will fire mouse/click events for a link that is near
			// a touch event, even though the target of the touchstart/touchend event
			// says the user touched outside the link. Also, it seems that with most
			// browsers, the target of the mouse/click event is not calculated until the
			// time it is dispatched, so if you replace an element that you touched
			// with another element, the target of the mouse/click will be the new
			// element underneath that point.
			//
			// Aside from proximity, we also check to see if the target and any
			// of its ancestors were the ones that blocked a click. This is necessary
			// because of the strange mouse/click target calculation done in the
			// Android 2.1 browser, where if you click on an element, and there is a
			// mouse/click handler on one of its ancestors, the target will be the
			// innermost child of the touched element, even if that child is no where
			// near the point of touch.

			ele = target;

			while ( ele ) {
				for ( i = 0; i < cnt; i++ ) {
					o = clickBlockList[ i ];
					touchID = 0;

					if ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||
								$.data( ele, touchTargetPropertyName ) === o.touchID ) {
						// XXX: We may want to consider removing matches from the block list
						//      instead of waiting for the reset timer to fire.
						e.preventDefault();
						e.stopPropagation();
						return;
					}
				}
				ele = ele.parentNode;
			}
		}
	}, true);
}
})( jQuery, window, document );


(function( $, window, undefined ) {
	var $document = $( document );

	// add new event shortcuts
	$.each( ( "touchstart touchmove touchend " +
		"tap taphold " +
		"swipe swipeleft swiperight " +
		"scrollstart scrollstop" ).split( " " ), function( i, name ) {

		$.fn[ name ] = function( fn ) {
			return fn ? this.bind( name, fn ) : this.trigger( name );
		};

		// jQuery < 1.8
		if ( $.attrFn ) {
			$.attrFn[ name ] = true;
		}
	});

	var supportTouch = $.mobile.support.touch,
		scrollEvent = "touchmove scroll",
		touchStartEvent = supportTouch ? "touchstart" : "mousedown",
		touchStopEvent = supportTouch ? "touchend" : "mouseup",
		touchMoveEvent = supportTouch ? "touchmove" : "mousemove";

	function triggerCustomEvent( obj, eventType, event ) {
		var originalType = event.type;
		event.type = eventType;
		$.event.dispatch.call( obj, event );
		event.type = originalType;
	}

	// also handles scrollstop
	$.event.special.scrollstart = {

		enabled: true,

		setup: function() {

			var thisObject = this,
				$this = $( thisObject ),
				scrolling,
				timer;

			function trigger( event, state ) {
				scrolling = state;
				triggerCustomEvent( thisObject, scrolling ? "scrollstart" : "scrollstop", event );
			}

			// iPhone triggers scroll after a small delay; use touchmove instead
			$this.bind( scrollEvent, function( event ) {

				if ( !$.event.special.scrollstart.enabled ) {
					return;
				}

				if ( !scrolling ) {
					trigger( event, true );
				}

				clearTimeout( timer );
				timer = setTimeout( function() {
					trigger( event, false );
				}, 50 );
			});
		}
	};

	// also handles taphold
	$.event.special.tap = {
		tapholdThreshold: 750,

		setup: function() {
			var thisObject = this,
				$this = $( thisObject );

			$this.bind( "vmousedown", function( event ) {

				if ( event.which && event.which !== 1 ) {
					return false;
				}

				var origTarget = event.target,
					origEvent = event.originalEvent,
					timer;

				function clearTapTimer() {
					clearTimeout( timer );
				}

				function clearTapHandlers() {
					clearTapTimer();

					$this.unbind( "vclick", clickHandler )
						.unbind( "vmouseup", clearTapTimer );
					$document.unbind( "vmousecancel", clearTapHandlers );
				}

				function clickHandler( event ) {
					clearTapHandlers();

					// ONLY trigger a 'tap' event if the start target is
					// the same as the stop target.
					if ( origTarget === event.target ) {
						triggerCustomEvent( thisObject, "tap", event );
					}
				}

				$this.bind( "vmouseup", clearTapTimer )
					.bind( "vclick", clickHandler );
				$document.bind( "vmousecancel", clearTapHandlers );

				timer = setTimeout( function() {
					triggerCustomEvent( thisObject, "taphold", $.Event( "taphold", { target: origTarget } ) );
				}, $.event.special.tap.tapholdThreshold );
			});
		}
	};

	// also handles swipeleft, swiperight
	$.event.special.swipe = {
		scrollSupressionThreshold: 30, // More than this horizontal displacement, and we will suppress scrolling.

		durationThreshold: 1000, // More time than this, and it isn't a swipe.

		horizontalDistanceThreshold: 30,  // Swipe horizontal displacement must be more than this.

		verticalDistanceThreshold: 75,  // Swipe vertical displacement must be less than this.

		start: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event;
			return {
						time: ( new Date() ).getTime(),
						coords: [ data.pageX, data.pageY ],
						origin: $( event.target )
					};
		},

		stop: function( event ) {
			var data = event.originalEvent.touches ?
					event.originalEvent.touches[ 0 ] : event;
			return {
						time: ( new Date() ).getTime(),
						coords: [ data.pageX, data.pageY ]
					};
		},

		handleSwipe: function( start, stop ) {
			if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
				Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
				Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {

				start.origin.trigger( "swipe" )
					.trigger( start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight" );
			}
		},

		setup: function() {
			var thisObject = this,
				$this = $( thisObject );

			$this.bind( touchStartEvent, function( event ) {
				var start = $.event.special.swipe.start( event ),
					stop;

				function moveHandler( event ) {
					if ( !start ) {
						return;
					}

					stop = $.event.special.swipe.stop( event );

					// prevent scrolling
					if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
						event.preventDefault();
					}
				}

				$this.bind( touchMoveEvent, moveHandler )
					.one( touchStopEvent, function() {
						$this.unbind( touchMoveEvent, moveHandler );

						if ( start && stop ) {
							$.event.special.swipe.handleSwipe( start, stop );
						}
						start = stop = undefined;
					});
			});
		}
	};
	$.each({
		scrollstop: "scrollstart",
		taphold: "tap",
		swipeleft: "swipe",
		swiperight: "swipe"
	}, function( event, sourceEvent ) {

		$.event.special[ event ] = {
			setup: function() {
				$( this ).bind( sourceEvent, $.noop );
			}
		};
	});

})( jQuery, this );


	// throttled resize event
	(function( $ ) {
		$.event.special.throttledresize = {
			setup: function() {
				$( this ).bind( "resize", handler );
			},
			teardown: function() {
				$( this ).unbind( "resize", handler );
			}
		};

		var throttle = 250,
			handler = function() {
				curr = ( new Date() ).getTime();
				diff = curr - lastCall;

				if ( diff >= throttle ) {

					lastCall = curr;
					$( this ).trigger( "throttledresize" );

				} else {

					if ( heldCall ) {
						clearTimeout( heldCall );
					}

					// Promise a held call will still execute
					heldCall = setTimeout( handler, throttle - diff );
				}
			},
			lastCall = 0,
			heldCall,
			curr,
			diff;
	})( jQuery );

(function( $, window ) {
	var win = $( window ),
		event_name = "orientationchange",
		special_event,
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = { "0": true, "180": true };

	// It seems that some device/browser vendors use window.orientation values 0 and 180 to
	// denote the "default" orientation. For iOS devices, and most other smart-phones tested,
	// the default orientation is always "portrait", but in some Android and RIM based tablets,
	// the default orientation is "landscape". The following code attempts to use the window
	// dimensions to figure out what the current orientation is, and then makes adjustments
	// to the to the portrait_map if necessary, so that we can properly decode the
	// window.orientation value whenever get_orientation() is called.
	//
	// Note that we used to use a media query to figure out what the orientation the browser
	// thinks it is in:
	//
	//     initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");
	//
	// but there was an iPhone/iPod Touch bug beginning with iOS 4.2, up through iOS 5.1,
	// where the browser *ALWAYS* applied the landscape media query. This bug does not
	// happen on iPad.

	if ( $.support.orientation ) {

		// Check the window width and height to figure out what the current orientation
		// of the device is at this moment. Note that we've initialized the portrait map
		// values to 0 and 180, *AND* we purposely check for landscape so that if we guess
		// wrong, , we default to the assumption that portrait is the default orientation.
		// We use a threshold check below because on some platforms like iOS, the iPhone
		// form-factor can report a larger width than height if the user turns on the
		// developer console. The actual threshold value is somewhat arbitrary, we just
		// need to make sure it is large enough to exclude the developer console case.

		var ww = window.innerWidth || win.width(),
			wh = window.innerHeight || win.height(),
			landscape_threshold = 50;

		initial_orientation_is_landscape = ww > wh && ( ww - wh ) > landscape_threshold;


		// Now check to see if the current window.orientation is 0 or 180.
		initial_orientation_is_default = portrait_map[ window.orientation ];

		// If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
		// if the initial orientation is portrait, but window.orientation reports 90 or -90, we
		// need to flip our portrait_map values because landscape is the default orientation for
		// this device/browser.
		if ( ( initial_orientation_is_landscape && initial_orientation_is_default ) || ( !initial_orientation_is_landscape && !initial_orientation_is_default ) ) {
			portrait_map = { "-90": true, "90": true };
		}
	}

	$.event.special.orientationchange = $.extend( {}, $.event.special.orientationchange, {
		setup: function() {
			// If the event is supported natively, return false so that jQuery
			// will bind to the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Get the current orientation to avoid initial double-triggering.
			last_orientation = get_orientation();

			// Because the orientationchange event doesn't exist, simulate the
			// event by testing window dimensions on resize.
			win.bind( "throttledresize", handler );
		},
		teardown: function() {
			// If the event is not supported natively, return false so that
			// jQuery will unbind the event using DOM methods.
			if ( $.support.orientation && !$.event.special.orientationchange.disabled ) {
				return false;
			}

			// Because the orientationchange event doesn't exist, unbind the
			// resize event handler.
			win.unbind( "throttledresize", handler );
		},
		add: function( handleObj ) {
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;


			handleObj.handler = function( event ) {
				// Modify event object, adding the .orientation property.
				event.orientation = get_orientation();

				// Call the originally-bound event handler and return its result.
				return old_handler.apply( this, arguments );
			};
		}
	});

	// If the event is not supported natively, this handler will be bound to
	// the window resize event to simulate the orientationchange event.
	function handler() {
		// Get the current orientation.
		var orientation = get_orientation();

		if ( orientation !== last_orientation ) {
			// The orientation has changed, so trigger the orientationchange event.
			last_orientation = orientation;
			win.trigger( event_name );
		}
	}

	// Get the current page orientation. This method is exposed publicly, should it
	// be needed, as jQuery.event.special.orientationchange.orientation()
	$.event.special.orientationchange.orientation = get_orientation = function() {
		var isPortrait = true, elem = document.documentElement;

		// prefer window orientation to the calculation based on screensize as
		// the actual screen resize takes place before or after the orientation change event
		// has been fired depending on implementation (eg android 2.3 is before, iphone after).
		// More testing is required to determine if a more reliable method of determining the new screensize
		// is possible when orientationchange is fired. (eg, use media queries + element + opacity)
		if ( $.support.orientation ) {
			// if the window orientation registers as 0 or 180 degrees report
			// portrait, otherwise landscape
			isPortrait = portrait_map[ window.orientation ];
		} else {
			isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
		}

		return isPortrait ? "portrait" : "landscape";
	};

	$.fn[ event_name ] = function( fn ) {
		return fn ? this.bind( event_name, fn ) : this.trigger( event_name );
	};

	// jQuery < 1.8
	if ( $.attrFn ) {
		$.attrFn[ event_name ] = true;
	}

}( jQuery, this ));



(function( $, undefined ) {

$.widget( "mobile.page", $.mobile.widget, {
	options: {
		theme: "c",
		domCache: false,
		keepNativeDefault: ":jqmData(role='none'), :jqmData(role='nojs')"
	},

	_create: function() {
		// if false is returned by the callbacks do not create the page
		if ( this._trigger( "beforecreate" ) === false ) {
			return false;
		}

		this.element
			.attr( "tabindex", "0" )
			.addClass( "ui-page ui-body-" + this.options.theme );

		this._on( this.element, {
			pagebeforehide: "removeContainerBackground",
			pagebeforeshow: "_handlePageBeforeShow"
		});
	},

	_handlePageBeforeShow: function( e ) {
		this.setContainerBackground();
	},

	removeContainerBackground: function() {
		$.mobile.pageContainer.removeClass( "ui-overlay-" + $.mobile.getInheritedTheme( this.element.parent() ) );
	},

	// set the page container background to the page theme
	setContainerBackground: function( theme ) {
		if ( this.options.theme ) {
			$.mobile.pageContainer.addClass( "ui-overlay-" + ( theme || this.options.theme ) );
		}
	},

	keepNativeSelector: function() {
		var options = this.options,
			keepNativeDefined = options.keepNative && $.trim( options.keepNative );

		if ( keepNativeDefined && options.keepNative !== options.keepNativeDefault ) {
			return [options.keepNative, options.keepNativeDefault].join( ", " );
		}

		return options.keepNativeDefault;
	}
});
})( jQuery );

(function( $, window, undefined ) {

var createHandler = function( sequential ) {

	// Default to sequential
	if ( sequential === undefined ) {
		sequential = true;
	}

	return function( name, reverse, $to, $from ) {

		var deferred = new $.Deferred(),
			reverseClass = reverse ? " reverse" : "",
			active	= $.mobile.urlHistory.getActive(),
			toScroll = active.lastScroll || $.mobile.defaultHomeScroll,
			screenHeight = $.mobile.getScreenHeight(),
			maxTransitionOverride = $.mobile.maxTransitionWidth !== false && $.mobile.window.width() > $.mobile.maxTransitionWidth,
			none = !$.support.cssTransitions || maxTransitionOverride || !name || name === "none" || Math.max( $.mobile.window.scrollTop(), toScroll ) > $.mobile.getMaxScrollForTransition(),
			toPreClass = " ui-page-pre-in",
			toggleViewportClass = function() {
				$.mobile.pageContainer.toggleClass( "ui-mobile-viewport-transitioning viewport-" + name );
			},
			scrollPage = function() {
				// By using scrollTo instead of silentScroll, we can keep things better in order
				// Just to be precautios, disable scrollstart listening like silentScroll would
				$.event.special.scrollstart.enabled = false;

				window.scrollTo( 0, toScroll );

				// reenable scrollstart listening like silentScroll would
				setTimeout( function() {
					$.event.special.scrollstart.enabled = true;
				}, 150 );
			},
			cleanFrom = function() {
				$from
					.removeClass( $.mobile.activePageClass + " out in reverse " + name )
					.height( "" );
			},
			startOut = function() {
				// if it's not sequential, call the doneOut transition to start the TO page animating in simultaneously
				if ( !sequential ) {
					doneOut();
				}
				else {
					$from.animationComplete( doneOut );
				}

				// Set the from page's height and start it transitioning out
				// Note: setting an explicit height helps eliminate tiling in the transitions
				$from
					.height( screenHeight + $.mobile.window.scrollTop() )
					.addClass( name + " out" + reverseClass );
			},

			doneOut = function() {

				if ( $from && sequential ) {
					cleanFrom();
				}

				startIn();
			},

			startIn = function() {

				// Prevent flickering in phonegap container: see comments at #4024 regarding iOS
				$to.css( "z-index", -10 );

				$to.addClass( $.mobile.activePageClass + toPreClass );

				// Send focus to page as it is now display: block
				$.mobile.focusPage( $to );

				// Set to page height
				$to.height( screenHeight + toScroll );

				scrollPage();

				// Restores visibility of the new page: added together with $to.css( "z-index", -10 );
				$to.css( "z-index", "" );

				if ( !none ) {
					$to.animationComplete( doneIn );
				}

				$to
					.removeClass( toPreClass )
					.addClass( name + " in" + reverseClass );

				if ( none ) {
					doneIn();
				}

			},

			doneIn = function() {

				if ( !sequential ) {

					if ( $from ) {
						cleanFrom();
					}
				}

				$to
					.removeClass( "out in reverse " + name )
					.height( "" );

				toggleViewportClass();

				// In some browsers (iOS5), 3D transitions block the ability to scroll to the desired location during transition
				// This ensures we jump to that spot after the fact, if we aren't there already.
				if ( $.mobile.window.scrollTop() !== toScroll ) {
					scrollPage();
				}

				deferred.resolve( name, reverse, $to, $from, true );
			};

		toggleViewportClass();

		if ( $from && !none ) {
			startOut();
		}
		else {
			doneOut();
		}

		return deferred.promise();
	};
};

// generate the handlers from the above
var sequentialHandler = createHandler(),
	simultaneousHandler = createHandler( false ),
	defaultGetMaxScrollForTransition = function() {
		return $.mobile.getScreenHeight() * 3;
	};

// Make our transition handler the public default.
$.mobile.defaultTransitionHandler = sequentialHandler;

//transition handler dictionary for 3rd party transitions
$.mobile.transitionHandlers = {
	"default": $.mobile.defaultTransitionHandler,
	"sequential": sequentialHandler,
	"simultaneous": simultaneousHandler
};

$.mobile.transitionFallbacks = {};

// If transition is defined, check if css 3D transforms are supported, and if not, if a fallback is specified
$.mobile._maybeDegradeTransition = function( transition ) {
		if ( transition && !$.support.cssTransform3d && $.mobile.transitionFallbacks[ transition ] ) {
			transition = $.mobile.transitionFallbacks[ transition ];
		}

		return transition;
};

// Set the getMaxScrollForTransition to default if no implementation was set by user
$.mobile.getMaxScrollForTransition = $.mobile.getMaxScrollForTransition || defaultGetMaxScrollForTransition;
})( jQuery, this );

(function( $, undefined ) {

	//define vars for interal use
	var $window = $.mobile.window,
		$html = $( 'html' ),
		$head = $( 'head' ),

		// NOTE: path extensions dependent on core attributes. Moved here to remove deps from
		//       $.mobile.path definition
		path = $.extend($.mobile.path, {

			//return the substring of a filepath before the sub-page key, for making a server request
			getFilePath: function( path ) {
				var splitkey = '&' + $.mobile.subPageUrlKey;
				return path && path.split( splitkey )[0].split( dialogHashKey )[0];
			},

			//check if the specified url refers to the first page in the main application document.
			isFirstPageUrl: function( url ) {
				// We only deal with absolute paths.
				var u = path.parseUrl( path.makeUrlAbsolute( url, this.documentBase ) ),

					// Does the url have the same path as the document?
					samePath = u.hrefNoHash === this.documentUrl.hrefNoHash || ( this.documentBaseDiffers && u.hrefNoHash === this.documentBase.hrefNoHash ),

					// Get the first page element.
					fp = $.mobile.firstPage,

					// Get the id of the first page element if it has one.
					fpId = fp && fp[0] ? fp[0].id : undefined;

				// The url refers to the first page if the path matches the document and
				// it either has no hash value, or the hash is exactly equal to the id of the
				// first page element.
				return samePath && ( !u.hash || u.hash === "#" || ( fpId && u.hash.replace( /^#/, "" ) === fpId ) );
			},

			// Some embedded browsers, like the web view in Phone Gap, allow cross-domain XHR
			// requests if the document doing the request was loaded via the file:// protocol.
			// This is usually to allow the application to "phone home" and fetch app specific
			// data. We normally let the browser handle external/cross-domain urls, but if the
			// allowCrossDomainPages option is true, we will allow cross-domain http/https
			// requests to go through our page loading logic.
			isPermittedCrossDomainRequest: function( docUrl, reqUrl ) {
				return $.mobile.allowCrossDomainPages &&
					docUrl.protocol === "file:" &&
					reqUrl.search( /^https?:/ ) !== -1;
			}
		}),

		// used to track last vclicked element to make sure its value is added to form data
		$lastVClicked = null,

		//will be defined when a link is clicked and given an active class
		$activeClickedLink = null,

		// resolved on domready
		domreadyDeferred = $.Deferred(),

		//urlHistory is purely here to make guesses at whether the back or forward button was clicked
		//and provide an appropriate transition
		urlHistory = $.mobile.navigate.history,

		//define first selector to receive focus when a page is shown
		focusable = "[tabindex],a,button:visible,select:visible,input",

		//queue to hold simultanious page transitions
		pageTransitionQueue = [],

		//indicates whether or not page is in process of transitioning
		isPageTransitioning = false,

		//nonsense hash change key for dialogs, so they create a history entry
		dialogHashKey = "&ui-state=dialog",

		//existing base tag?
		$base = $head.children( "base" ),

		//tuck away the original document URL minus any fragment.
		documentUrl = path.documentUrl,

		//if the document has an embedded base tag, documentBase is set to its
		//initial value. If a base tag does not exist, then we default to the documentUrl.
		documentBase = path.documentBase,

		//cache the comparison once.
		documentBaseDiffers = path.documentBaseDiffers,

		getScreenHeight = $.mobile.getScreenHeight;

		//base element management, defined depending on dynamic base tag support
		var base = $.support.dynamicBaseTag ? {

			//define base element, for use in routing asset urls that are referenced in Ajax-requested markup
			element: ( $base.length ? $base : $( "<base>", { href: documentBase.hrefNoHash } ).prependTo( $head ) ),

			//set the generated BASE element's href attribute to a new page's base path
			set: function( href ) {
				href = path.parseUrl(href).hrefNoHash;
				base.element.attr( "href", path.makeUrlAbsolute( href, documentBase ) );
			},

			//set the generated BASE element's href attribute to a new page's base path
			reset: function() {
				base.element.attr( "href", documentBase.hrefNoSearch );
			}

		} : undefined;


	//return the original document url
	$.mobile.getDocumentUrl = path.getDocumentUrl;

	//return the original document base url
	$.mobile.getDocumentBase = path.getDocumentBase;

	/* internal utility functions */

	// NOTE Issue #4950 Android phonegap doesn't navigate back properly
	//      when a full page refresh has taken place. It appears that hashchange
	//      and replacestate history alterations work fine but we need to support
	//      both forms of history traversal in our code that uses backward history
	//      movement
	$.mobile.back = function() {
		var nav = window.navigator;

		// if the setting is on and the navigator object is
		// available use the phonegap navigation capability
		if( this.phonegapNavigationEnabled &&
			nav &&
			nav.app &&
			nav.app.backHistory ){
			nav.app.backHistory();
		} else {
			window.history.back();
		}
	};

	//direct focus to the page title, or otherwise first focusable element
	$.mobile.focusPage = function ( page ) {
		var autofocus = page.find( "[autofocus]" ),
			pageTitle = page.find( ".ui-title:eq(0)" );

		if ( autofocus.length ) {
			autofocus.focus();
			return;
		}

		if ( pageTitle.length ) {
			pageTitle.focus();
		} else{
			page.focus();
		}
	};

	//remove active classes after page transition or error
	function removeActiveLinkClass( forceRemoval ) {
		if ( !!$activeClickedLink && ( !$activeClickedLink.closest( "." + $.mobile.activePageClass ).length || forceRemoval ) ) {
			$activeClickedLink.removeClass( $.mobile.activeBtnClass );
		}
		$activeClickedLink = null;
	}

	function releasePageTransitionLock() {
		isPageTransitioning = false;
		if ( pageTransitionQueue.length > 0 ) {
			$.mobile.changePage.apply( null, pageTransitionQueue.pop() );
		}
	}

	// Save the last scroll distance per page, before it is hidden
	var setLastScrollEnabled = true,
		setLastScroll, delayedSetLastScroll;

	setLastScroll = function() {
		// this barrier prevents setting the scroll value based on the browser
		// scrolling the window based on a hashchange
		if ( !setLastScrollEnabled ) {
			return;
		}

		var active = $.mobile.urlHistory.getActive();

		if ( active ) {
			var lastScroll = $window.scrollTop();

			// Set active page's lastScroll prop.
			// If the location we're scrolling to is less than minScrollBack, let it go.
			active.lastScroll = lastScroll < $.mobile.minScrollBack ? $.mobile.defaultHomeScroll : lastScroll;
		}
	};

	// bind to scrollstop to gather scroll position. The delay allows for the hashchange
	// event to fire and disable scroll recording in the case where the browser scrolls
	// to the hash targets location (sometimes the top of the page). once pagechange fires
	// getLastScroll is again permitted to operate
	delayedSetLastScroll = function() {
		setTimeout( setLastScroll, 100 );
	};

	// disable an scroll setting when a hashchange has been fired, this only works
	// because the recording of the scroll position is delayed for 100ms after
	// the browser might have changed the position because of the hashchange
	$window.bind( $.support.pushState ? "popstate" : "hashchange", function() {
		setLastScrollEnabled = false;
	});

	// handle initial hashchange from chrome :(
	$window.one( $.support.pushState ? "popstate" : "hashchange", function() {
		setLastScrollEnabled = true;
	});

	// wait until the mobile page container has been determined to bind to pagechange
	$window.one( "pagecontainercreate", function() {
		// once the page has changed, re-enable the scroll recording
		$.mobile.pageContainer.bind( "pagechange", function() {

			setLastScrollEnabled = true;

			// remove any binding that previously existed on the get scroll
			// which may or may not be different than the scroll element determined for
			// this page previously
			$window.unbind( "scrollstop", delayedSetLastScroll );

			// determine and bind to the current scoll element which may be the window
			// or in the case of touch overflow the element with touch overflow
			$window.bind( "scrollstop", delayedSetLastScroll );
		});
	});

	// bind to scrollstop for the first page as "pagechange" won't be fired in that case
	$window.bind( "scrollstop", delayedSetLastScroll );

	// No-op implementation of transition degradation
	$.mobile._maybeDegradeTransition = $.mobile._maybeDegradeTransition || function( transition ) {
		return transition;
	};

	//function for transitioning between two existing pages
	function transitionPages( toPage, fromPage, transition, reverse ) {
		if ( fromPage ) {
			//trigger before show/hide events
			fromPage.data( "mobile-page" )._trigger( "beforehide", null, { nextPage: toPage } );
		}

		toPage.data( "mobile-page" )._trigger( "beforeshow", null, { prevPage: fromPage || $( "" ) } );

		//clear page loader
		$.mobile.hidePageLoadingMsg();

		transition = $.mobile._maybeDegradeTransition( transition );

		//find the transition handler for the specified transition. If there
		//isn't one in our transitionHandlers dictionary, use the default one.
		//call the handler immediately to kick-off the transition.
		var th = $.mobile.transitionHandlers[ transition || "default" ] || $.mobile.defaultTransitionHandler,
			promise = th( transition, reverse, toPage, fromPage );

		promise.done(function() {
			//trigger show/hide events
			if ( fromPage ) {
				fromPage.data( "mobile-page" )._trigger( "hide", null, { nextPage: toPage } );
			}

			//trigger pageshow, define prevPage as either fromPage or empty jQuery obj
			toPage.data( "mobile-page" )._trigger( "show", null, { prevPage: fromPage || $( "" ) } );
		});

		return promise;
	}

	//simply set the active page's minimum height to screen height, depending on orientation
	$.mobile.resetActivePageHeight = function resetActivePageHeight( height ) {
		var aPage = $( "." + $.mobile.activePageClass ),
			aPagePadT = parseFloat( aPage.css( "padding-top" ) ),
			aPagePadB = parseFloat( aPage.css( "padding-bottom" ) ),
			aPageBorderT = parseFloat( aPage.css( "border-top-width" ) ),
			aPageBorderB = parseFloat( aPage.css( "border-bottom-width" ) );

		height = ( typeof height === "number" )? height : getScreenHeight();
		
		aPage.css( "min-height", height - aPagePadT - aPagePadB - aPageBorderT - aPageBorderB );
	};

	//shared page enhancements
	function enhancePage( $page, role ) {
		// If a role was specified, make sure the data-role attribute
		// on the page element is in sync.
		if ( role ) {
			$page.attr( "data-" + $.mobile.ns + "role", role );
		}

		//run page plugin
		$page.page();
	}

	// determine the current base url
	function findBaseWithDefault() {
		var closestBase = ( $.mobile.activePage && getClosestBaseUrl( $.mobile.activePage ) );
		return closestBase || documentBase.hrefNoHash;
	}

	/* exposed $.mobile methods */

	//animation complete callback
	$.fn.animationComplete = function( callback ) {
		if ( $.support.cssTransitions ) {
			return $( this ).one( 'webkitAnimationEnd animationend', callback );
		}
		else{
			// defer execution for consistency between webkit/non webkit
			setTimeout( callback, 0 );
			return $( this );
		}
	};

	//expose path object on $.mobile
	$.mobile.path = path;

	//expose base object on $.mobile
	$.mobile.base = base;

	//history stack
	$.mobile.urlHistory = urlHistory;

	$.mobile.dialogHashKey = dialogHashKey;

	//enable cross-domain page support
	$.mobile.allowCrossDomainPages = false;

	$.mobile._bindPageRemove = function() {
		var page = $( this );

		// when dom caching is not enabled or the page is embedded bind to remove the page on hide
		if ( !page.data( "mobile-page" ).options.domCache &&
			page.is( ":jqmData(external-page='true')" ) ) {

			page.bind( 'pagehide.remove', function( e ) {
				var $this = $( this ),
					prEvent = new $.Event( "pageremove" );

				$this.trigger( prEvent );

				if ( !prEvent.isDefaultPrevented() ) {
					$this.removeWithDependents();
				}
			});
		}
	};

	// Load a page into the DOM.
	$.mobile.loadPage = function( url, options ) {
		// This function uses deferred notifications to let callers
		// know when the page is done loading, or if an error has occurred.
		var deferred = $.Deferred(),

			// The default loadPage options with overrides specified by
			// the caller.
			settings = $.extend( {}, $.mobile.loadPage.defaults, options ),

			// The DOM element for the page after it has been loaded.
			page = null,

			// If the reloadPage option is true, and the page is already
			// in the DOM, dupCachedPage will be set to the page element
			// so that it can be removed after the new version of the
			// page is loaded off the network.
			dupCachedPage = null,

			// The absolute version of the URL passed into the function. This
			// version of the URL may contain dialog/subpage params in it.
			absUrl = path.makeUrlAbsolute( url, findBaseWithDefault() );

		// If the caller provided data, and we're using "get" request,
		// append the data to the URL.
		if ( settings.data && settings.type === "get" ) {
			absUrl = path.addSearchParams( absUrl, settings.data );
			settings.data = undefined;
		}

		// If the caller is using a "post" request, reloadPage must be true
		if ( settings.data && settings.type === "post" ) {
			settings.reloadPage = true;
		}

		// The absolute version of the URL minus any dialog/subpage params.
		// In otherwords the real URL of the page to be loaded.
		var fileUrl = path.getFilePath( absUrl ),

			// The version of the Url actually stored in the data-url attribute of
			// the page. For embedded pages, it is just the id of the page. For pages
			// within the same domain as the document base, it is the site relative
			// path. For cross-domain pages (Phone Gap only) the entire absolute Url
			// used to load the page.
			dataUrl = path.convertUrlToDataUrl( absUrl );

		// Make sure we have a pageContainer to work with.
		settings.pageContainer = settings.pageContainer || $.mobile.pageContainer;

		// Check to see if the page already exists in the DOM.
		// NOTE do _not_ use the :jqmData psuedo selector because parenthesis
		//      are a valid url char and it breaks on the first occurence
		page = settings.pageContainer.children( "[data-" + $.mobile.ns +"url='" + dataUrl + "']" );

		// If we failed to find the page, check to see if the url is a
		// reference to an embedded page. If so, it may have been dynamically
		// injected by a developer, in which case it would be lacking a data-url
		// attribute and in need of enhancement.
		if ( page.length === 0 && dataUrl && !path.isPath( dataUrl ) ) {
			page = settings.pageContainer.children( "#" + dataUrl )
				.attr( "data-" + $.mobile.ns + "url", dataUrl )
				.jqmData( "url", dataUrl );
		}

		
		// If we failed to find a page in the DOM, check the URL to see if it
		// refers to the first page in the application. If it isn't a reference
		// to the first page and refers to non-existent embedded page, error out.
		if ( page.length === 0 ) {
			if ( $.mobile.firstPage && path.isFirstPageUrl( fileUrl ) ) {
				// Check to make sure our cached-first-page is actually
				// in the DOM. Some user deployed apps are pruning the first
				// page from the DOM for various reasons, we check for this
				// case here because we don't want a first-page with an id
				// falling through to the non-existent embedded page error
				// case. If the first-page is not in the DOM, then we let
				// things fall through to the ajax loading code below so
				// that it gets reloaded.
				if ( $.mobile.firstPage.parent().length ) {
					page = $( $.mobile.firstPage );
				}
			} else if ( path.isEmbeddedPage( fileUrl )  ) {
				deferred.reject( absUrl, options );
				return deferred.promise();
			}
		}
		
		// If the page we are interested in is already in the DOM,
		// and the caller did not indicate that we should force a
		// reload of the file, we are done. Otherwise, track the
		// existing page as a duplicated.
		if ( page.length ) {
			if ( !settings.reloadPage ) {
				enhancePage( page, settings.role );
				deferred.resolve( absUrl, options, page );
				//if we are reloading the page make sure we update the base if its not a prefetch 
				if( base && !options.prefetch ){
					base.set(url);
				}
				return deferred.promise();
			}
			dupCachedPage = page;
		}
		var mpc = settings.pageContainer,
			pblEvent = new $.Event( "pagebeforeload" ),
			triggerData = { url: url, absUrl: absUrl, dataUrl: dataUrl, deferred: deferred, options: settings };

		// Let listeners know we're about to load a page.
		mpc.trigger( pblEvent, triggerData );

		// If the default behavior is prevented, stop here!
		if ( pblEvent.isDefaultPrevented() ) {
			return deferred.promise();
		}

		if ( settings.showLoadMsg ) {

			// This configurable timeout allows cached pages a brief delay to load without showing a message
			var loadMsgDelay = setTimeout(function() {
					$.mobile.showPageLoadingMsg();
				}, settings.loadMsgDelay ),

				// Shared logic for clearing timeout and removing message.
				hideMsg = function() {

					// Stop message show timer
					clearTimeout( loadMsgDelay );

					// Hide loading message
					$.mobile.hidePageLoadingMsg();
				};
		}
		// Reset base to the default document base.
		// only reset if we are not prefetching 
		if ( base && typeof options.prefetch === "undefined" ) {
			base.reset();
		}

		if ( !( $.mobile.allowCrossDomainPages || path.isSameDomain( documentUrl, absUrl ) ) ) {
			deferred.reject( absUrl, options );
		} else {
			// Load the new page.
			$.ajax({
				url: fileUrl,
				type: settings.type,
				data: settings.data,
				contentType: settings.contentType,
				dataType: "html",
				success: function( html, textStatus, xhr ) {
					//pre-parse html to check for a data-url,
					//use it as the new fileUrl, base path, etc
					var all = $( "<div></div>" ),

						//page title regexp
						newPageTitle = html.match( /<title[^>]*>([^<]*)/ ) && RegExp.$1,

						// TODO handle dialogs again
						pageElemRegex = new RegExp( "(<[^>]+\\bdata-" + $.mobile.ns + "role=[\"']?page[\"']?[^>]*>)" ),
						dataUrlRegex = new RegExp( "\\bdata-" + $.mobile.ns + "url=[\"']?([^\"'>]*)[\"']?" );


					// data-url must be provided for the base tag so resource requests can be directed to the
					// correct url. loading into a temprorary element makes these requests immediately
					if ( pageElemRegex.test( html ) &&
							RegExp.$1 &&
							dataUrlRegex.test( RegExp.$1 ) &&
							RegExp.$1 ) {
						url = fileUrl = path.getFilePath( $( "<div>" + RegExp.$1 + "</div>" ).text() );
					}
					//dont update the base tag if we are prefetching
					if ( base && typeof options.prefetch === "undefined") {
						base.set( fileUrl );
					}

					//workaround to allow scripts to execute when included in page divs
					all.get( 0 ).innerHTML = html;
					page = all.find( ":jqmData(role='page'), :jqmData(role='dialog')" ).first();

					//if page elem couldn't be found, create one and insert the body element's contents
					if ( !page.length ) {
						page = $( "<div data-" + $.mobile.ns + "role='page'>" + ( html.split( /<\/?body[^>]*>/gmi )[1] || "" ) + "</div>" );
					}

					if ( newPageTitle && !page.jqmData( "title" ) ) {
						if ( ~newPageTitle.indexOf( "&" ) ) {
							newPageTitle = $( "<div>" + newPageTitle + "</div>" ).text();
						}
						page.jqmData( "title", newPageTitle );
					}

					//rewrite src and href attrs to use a base url
					if ( !$.support.dynamicBaseTag ) {
						var newPath = path.get( fileUrl );
						page.find( "[src], link[href], a[rel='external'], :jqmData(ajax='false'), a[target]" ).each(function() {
							var thisAttr = $( this ).is( '[href]' ) ? 'href' :
									$( this ).is( '[src]' ) ? 'src' : 'action',
								thisUrl = $( this ).attr( thisAttr );

							// XXX_jblas: We need to fix this so that it removes the document
							//            base URL, and then prepends with the new page URL.
							//if full path exists and is same, chop it - helps IE out
							thisUrl = thisUrl.replace( location.protocol + '//' + location.host + location.pathname, '' );

							if ( !/^(\w+:|#|\/)/.test( thisUrl ) ) {
								$( this ).attr( thisAttr, newPath + thisUrl );
							}
						});
					}

					//append to page and enhance
					// TODO taging a page with external to make sure that embedded pages aren't removed
					//      by the various page handling code is bad. Having page handling code in many
					//      places is bad. Solutions post 1.0
					page
						.attr( "data-" + $.mobile.ns + "url", path.convertUrlToDataUrl( fileUrl ) )
						.attr( "data-" + $.mobile.ns + "external-page", true )
						.appendTo( settings.pageContainer );

					// wait for page creation to leverage options defined on widget
					page.one( 'pagecreate', $.mobile._bindPageRemove );

					enhancePage( page, settings.role );

					// Enhancing the page may result in new dialogs/sub pages being inserted
					// into the DOM. If the original absUrl refers to a sub-page, that is the
					// real page we are interested in.
					if ( absUrl.indexOf( "&" + $.mobile.subPageUrlKey ) > -1 ) {
						page = settings.pageContainer.children( "[data-" + $.mobile.ns +"url='" + dataUrl + "']" );
					}

					// Remove loading message.
					if ( settings.showLoadMsg ) {
						hideMsg();
					}

					// Add the page reference and xhr to our triggerData.
					triggerData.xhr = xhr;
					triggerData.textStatus = textStatus;
					triggerData.page = page;

					// Let listeners know the page loaded successfully.
					settings.pageContainer.trigger( "pageload", triggerData );

					deferred.resolve( absUrl, options, page, dupCachedPage );
				},
				error: function( xhr, textStatus, errorThrown ) {
					//set base back to current path
					if ( base ) {
						base.set( path.get() );
					}

					// Add error info to our triggerData.
					triggerData.xhr = xhr;
					triggerData.textStatus = textStatus;
					triggerData.errorThrown = errorThrown;

					var plfEvent = new $.Event( "pageloadfailed" );

					// Let listeners know the page load failed.
					settings.pageContainer.trigger( plfEvent, triggerData );

					// If the default behavior is prevented, stop here!
					// Note that it is the responsibility of the listener/handler
					// that called preventDefault(), to resolve/reject the
					// deferred object within the triggerData.
					if ( plfEvent.isDefaultPrevented() ) {
						return;
					}

					// Remove loading message.
					if ( settings.showLoadMsg ) {

						// Remove loading message.
						hideMsg();

						// show error message
						$.mobile.showPageLoadingMsg( $.mobile.pageLoadErrorMessageTheme, $.mobile.pageLoadErrorMessage, true );

						// hide after delay
						setTimeout( $.mobile.hidePageLoadingMsg, 1500 );
					}

					deferred.reject( absUrl, options );
				}
			});
		}

		return deferred.promise();
	};

	$.mobile.loadPage.defaults = {
		type: "get",
		data: undefined,
		reloadPage: false,
		role: undefined, // By default we rely on the role defined by the @data-role attribute.
		showLoadMsg: false,
		pageContainer: undefined,
		loadMsgDelay: 50 // This delay allows loads that pull from browser cache to occur without showing the loading message.
	};

	// Show a specific page in the page container.
	$.mobile.changePage = function( toPage, options ) {
		// If we are in the midst of a transition, queue the current request.
		// We'll call changePage() once we're done with the current transition to
		// service the request.
		if ( isPageTransitioning ) {
			pageTransitionQueue.unshift( arguments );
			return;
		}

		var settings = $.extend( {}, $.mobile.changePage.defaults, options ), isToPageString;

		// Make sure we have a pageContainer to work with.
		settings.pageContainer = settings.pageContainer || $.mobile.pageContainer;

		// Make sure we have a fromPage.
		settings.fromPage = settings.fromPage || $.mobile.activePage;

		isToPageString = (typeof toPage === "string");

		var mpc = settings.pageContainer,
			pbcEvent = new $.Event( "pagebeforechange" ),
			triggerData = { toPage: toPage, options: settings };

		// NOTE: preserve the original target as the dataUrl value will be simplified
		//       eg, removing ui-state, and removing query params from the hash
		//       this is so that users who want to use query params have access to them
		//       in the event bindings for the page life cycle See issue #5085
		if ( isToPageString ) {
			// if the toPage is a string simply convert it
			triggerData.absUrl = path.makeUrlAbsolute( toPage, findBaseWithDefault() );
		} else {
			// if the toPage is a jQuery object grab the absolute url stored
			// in the loadPage callback where it exists
			triggerData.absUrl = toPage.data( 'absUrl' );
		}

		// Let listeners know we're about to change the current page.
		mpc.trigger( pbcEvent, triggerData );

		// If the default behavior is prevented, stop here!
		if ( pbcEvent.isDefaultPrevented() ) {
			return;
		}

		// We allow "pagebeforechange" observers to modify the toPage in the trigger
		// data to allow for redirects. Make sure our toPage is updated.
		//
		// We also need to re-evaluate whether it is a string, because an object can
		// also be replaced by a string

		toPage = triggerData.toPage;
		isToPageString = (typeof toPage === "string");

		// Set the isPageTransitioning flag to prevent any requests from
		// entering this method while we are in the midst of loading a page
		// or transitioning.
		isPageTransitioning = true;

		// If the caller passed us a url, call loadPage()
		// to make sure it is loaded into the DOM. We'll listen
		// to the promise object it returns so we know when
		// it is done loading or if an error ocurred.
		if ( isToPageString ) {
			// preserve the original target as the dataUrl value will be simplified
			// eg, removing ui-state, and removing query params from the hash
			// this is so that users who want to use query params have access to them
			// in the event bindings for the page life cycle See issue #5085
			settings.target = toPage;

			$.mobile.loadPage( toPage, settings )
				.done(function( url, options, newPage, dupCachedPage ) {
					isPageTransitioning = false;
					options.duplicateCachedPage = dupCachedPage;

					// store the original absolute url so that it can be provided
					// to events in the triggerData of the subsequent changePage call
					newPage.data( 'absUrl', triggerData.absUrl );
					$.mobile.changePage( newPage, options );
				})
				.fail(function( url, options ) {

					//clear out the active button state
					removeActiveLinkClass( true );

					//release transition lock so navigation is free again
					releasePageTransitionLock();
					settings.pageContainer.trigger( "pagechangefailed", triggerData );
				});
			return;
		}

		// If we are going to the first-page of the application, we need to make
		// sure settings.dataUrl is set to the application document url. This allows
		// us to avoid generating a document url with an id hash in the case where the
		// first-page of the document has an id attribute specified.
		if ( toPage[ 0 ] === $.mobile.firstPage[ 0 ] && !settings.dataUrl ) {
			settings.dataUrl = documentUrl.hrefNoHash;
		}

		// The caller passed us a real page DOM element. Update our
		// internal state and then trigger a transition to the page.
		var fromPage = settings.fromPage,
			url = ( settings.dataUrl && path.convertUrlToDataUrl( settings.dataUrl ) ) || toPage.jqmData( "url" ),
			// The pageUrl var is usually the same as url, except when url is obscured as a dialog url. pageUrl always contains the file path
			pageUrl = url,
			fileUrl = path.getFilePath( url ),
			active = urlHistory.getActive(),
			activeIsInitialPage = urlHistory.activeIndex === 0,
			historyDir = 0,
			pageTitle = document.title,
			isDialog = settings.role === "dialog" || toPage.jqmData( "role" ) === "dialog";


		// By default, we prevent changePage requests when the fromPage and toPage
		// are the same element, but folks that generate content manually/dynamically
		// and reuse pages want to be able to transition to the same page. To allow
		// this, they will need to change the default value of allowSamePageTransition
		// to true, *OR*, pass it in as an option when they manually call changePage().
		// It should be noted that our default transition animations assume that the
		// formPage and toPage are different elements, so they may behave unexpectedly.
		// It is up to the developer that turns on the allowSamePageTransitiona option
		// to either turn off transition animations, or make sure that an appropriate
		// animation transition is used.
		if ( fromPage && fromPage[0] === toPage[0] && !settings.allowSamePageTransition ) {
			isPageTransitioning = false;
			mpc.trigger( "pagechange", triggerData );

			// Even if there is no page change to be done, we should keep the urlHistory in sync with the hash changes
			if ( settings.fromHashChange ) {
				urlHistory.direct({ url: url });
			}

			return;
		}

		// We need to make sure the page we are given has already been enhanced.
		enhancePage( toPage, settings.role );

		// If the changePage request was sent from a hashChange event, check to see if the
		// page is already within the urlHistory stack. If so, we'll assume the user hit
		// the forward/back button and will try to match the transition accordingly.
		if ( settings.fromHashChange ) {
			historyDir = options.direction === "back" ? -1 : 1;
		}

		// Kill the keyboard.
		// XXX_jblas: We need to stop crawling the entire document to kill focus. Instead,
		//            we should be tracking focus with a delegate() handler so we already have
		//            the element in hand at this point.
		// Wrap this in a try/catch block since IE9 throw "Unspecified error" if document.activeElement
		// is undefined when we are in an IFrame.
		try {
			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== 'body' ) {
				$( document.activeElement ).blur();
			} else {
				$( "input:focus, textarea:focus, select:focus" ).blur();
			}
		} catch( e ) {}

		// Record whether we are at a place in history where a dialog used to be - if so, do not add a new history entry and do not change the hash either
		var alreadyThere = false;

		// If we're displaying the page as a dialog, we don't want the url
		// for the dialog content to be used in the hash. Instead, we want
		// to append the dialogHashKey to the url of the current page.
		if ( isDialog && active ) {
			// on the initial page load active.url is undefined and in that case should
			// be an empty string. Moving the undefined -> empty string back into
			// urlHistory.addNew seemed imprudent given undefined better represents
			// the url state

			// If we are at a place in history that once belonged to a dialog, reuse
			// this state without adding to urlHistory and without modifying the hash.
			// However, if a dialog is already displayed at this point, and we're
			// about to display another dialog, then we must add another hash and
			// history entry on top so that one may navigate back to the original dialog
			if ( active.url &&
				active.url.indexOf( dialogHashKey ) > -1 &&
				$.mobile.activePage &&
				!$.mobile.activePage.is( ".ui-dialog" ) &&
				urlHistory.activeIndex > 0 ) {
				settings.changeHash = false;
				alreadyThere = true;
			}

			// Normally, we tack on a dialog hash key, but if this is the location of a stale dialog,
			// we reuse the URL from the entry
			url = ( active.url || "" );

			// account for absolute urls instead of just relative urls use as hashes
			if( !alreadyThere && url.indexOf("#") > -1 ) {
				url += dialogHashKey;
			} else {
				url += "#" + dialogHashKey;
			}

			// tack on another dialogHashKey if this is the same as the initial hash
			// this makes sure that a history entry is created for this dialog
			if ( urlHistory.activeIndex === 0 && url === urlHistory.initialDst ) {
				url += dialogHashKey;
			}
		}

		// if title element wasn't found, try the page div data attr too
		// If this is a deep-link or a reload ( active === undefined ) then just use pageTitle
		var newPageTitle = ( !active )? pageTitle : toPage.jqmData( "title" ) || toPage.children( ":jqmData(role='header')" ).find( ".ui-title" ).text();
		if ( !!newPageTitle && pageTitle === document.title ) {
			pageTitle = newPageTitle;
		}
		if ( !toPage.jqmData( "title" ) ) {
			toPage.jqmData( "title", pageTitle );
		}

		// Make sure we have a transition defined.
		settings.transition = settings.transition ||
			( ( historyDir && !activeIsInitialPage ) ? active.transition : undefined ) ||
			( isDialog ? $.mobile.defaultDialogTransition : $.mobile.defaultPageTransition );

		//add page to history stack if it's not back or forward
		if ( !historyDir && alreadyThere ) {
			urlHistory.getActive().pageUrl = pageUrl;
		}

		// Set the location hash.
		if ( url && !settings.fromHashChange ) {
			var params;

			// rebuilding the hash here since we loose it earlier on
			// TODO preserve the originally passed in path
			if( !path.isPath( url ) && url.indexOf( "#" ) < 0 ) {
				url = "#" + url;
			}

			// TODO the property names here are just silly
			params = {
				transition: settings.transition,
				title: pageTitle,
				pageUrl: pageUrl,
				role: settings.role
			};

			if ( settings.changeHash !== false && $.mobile.hashListeningEnabled ) {
				$.mobile.navigate( url, params, true);
			} else if ( toPage[ 0 ] !== $.mobile.firstPage[ 0 ] ) {
				$.mobile.navigate.history.add( url, params );
			}
		}

		//set page title
		document.title = pageTitle;

		//set "toPage" as activePage
		$.mobile.activePage = toPage;

		// If we're navigating back in the URL history, set reverse accordingly.
		settings.reverse = settings.reverse || historyDir < 0;

		transitionPages( toPage, fromPage, settings.transition, settings.reverse )
			.done(function( name, reverse, $to, $from, alreadyFocused ) {
				removeActiveLinkClass();

				//if there's a duplicateCachedPage, remove it from the DOM now that it's hidden
				if ( settings.duplicateCachedPage ) {
					settings.duplicateCachedPage.remove();
				}

				// Send focus to the newly shown page. Moved from promise .done binding in transitionPages
				// itself to avoid ie bug that reports offsetWidth as > 0 (core check for visibility)
				// despite visibility: hidden addresses issue #2965
				// https://github.com/jquery/jquery-mobile/issues/2965
				if ( !alreadyFocused ) {
					$.mobile.focusPage( toPage );
				}

				releasePageTransitionLock();
				mpc.trigger( "pagechange", triggerData );
			});
	};

	$.mobile.changePage.defaults = {
		transition: undefined,
		reverse: false,
		changeHash: true,
		fromHashChange: false,
		role: undefined, // By default we rely on the role defined by the @data-role attribute.
		duplicateCachedPage: undefined,
		pageContainer: undefined,
		showLoadMsg: true, //loading message shows by default when pages are being fetched during changePage
		dataUrl: undefined,
		fromPage: undefined,
		allowSamePageTransition: false
	};

/* Event Bindings - hashchange, submit, and click */
	function findClosestLink( ele )
	{
		while ( ele ) {
			// Look for the closest element with a nodeName of "a".
			// Note that we are checking if we have a valid nodeName
			// before attempting to access it. This is because the
			// node we get called with could have originated from within
			// an embedded SVG document where some symbol instance elements
			// don't have nodeName defined on them, or strings are of type
			// SVGAnimatedString.
			if ( ( typeof ele.nodeName === "string" ) && ele.nodeName.toLowerCase() === "a" ) {
				break;
			}
			ele = ele.parentNode;
		}
		return ele;
	}

	// The base URL for any given element depends on the page it resides in.
	function getClosestBaseUrl( ele )
	{
		// Find the closest page and extract out its url.
		var url = $( ele ).closest( ".ui-page" ).jqmData( "url" ),
			base = documentBase.hrefNoHash;

		if ( !url || !path.isPath( url ) ) {
			url = base;
		}

		return path.makeUrlAbsolute( url, base);
	}

	//The following event bindings should be bound after mobileinit has been triggered
	//the following deferred is resolved in the init file
	$.mobile.navreadyDeferred = $.Deferred();
	$.mobile._registerInternalEvents = function() {
		var getAjaxFormData = function( $form, calculateOnly ) {
			var url, ret = true, formData, vclickedName, method;
			
			if ( !$.mobile.ajaxEnabled ||
					// test that the form is, itself, ajax false
					$form.is( ":jqmData(ajax='false')" ) ||
					// test that $.mobile.ignoreContentEnabled is set and
					// the form or one of it's parents is ajax=false
					!$form.jqmHijackable().length ||
					$form.attr( "target" ) ) {
				return false;
			}

			url = $form.attr( "action" );
			method = ( $form.attr( "method" ) || "get" ).toLowerCase();

			// If no action is specified, browsers default to using the
			// URL of the document containing the form. Since we dynamically
			// pull in pages from external documents, the form should submit
			// to the URL for the source document of the page containing
			// the form.
			if ( !url ) {
				// Get the @data-url for the page containing the form.
				url = getClosestBaseUrl( $form );

				// NOTE: If the method is "get", we need to strip off the query string
				// because it will get replaced with the new form data. See issue #5710.
				if ( method === "get" ) {
					url = path.parseUrl( url ).hrefNoSearch;
				}

				if ( url === documentBase.hrefNoHash ) {
					// The url we got back matches the document base,
					// which means the page must be an internal/embedded page,
					// so default to using the actual document url as a browser
					// would.
					url = documentUrl.hrefNoSearch;
				}
			}

			url = path.makeUrlAbsolute(  url, getClosestBaseUrl( $form ) );

			if ( ( path.isExternal( url ) && !path.isPermittedCrossDomainRequest( documentUrl, url ) ) ) {
				return false;
			}

			if ( !calculateOnly ) {
				formData = $form.serializeArray();

				if ( $lastVClicked && $lastVClicked[ 0 ].form === $form[ 0 ] ) {
					vclickedName = $lastVClicked.attr( "name" );
					if ( vclickedName ) {
						// Make sure the last clicked element is included in the form
						$.each( formData, function( key, value ) {
							if ( value.name === vclickedName ) {
								// Unset vclickedName - we've found it in the serialized data already
								vclickedName = "";
								return false;
							}
						});
						if ( vclickedName ) {
							formData.push( { name: vclickedName, value: $lastVClicked.attr( "value" ) } );
						}
					}
				}

				ret = {
					url: url,
					options: {
						type:		method,
						data:		$.param( formData ),
						transition:	$form.jqmData( "transition" ),
						reverse:	$form.jqmData( "direction" ) === "reverse",
						reloadPage:	true
					}
				};
			}

			return ret;
		};

		//bind to form submit events, handle with Ajax
		$.mobile.document.delegate( "form", "submit", function( event ) {
			var formData = getAjaxFormData( $( this ) );

			if ( formData ) {
				$.mobile.changePage( formData.url, formData.options );
				event.preventDefault();
			}
		});

		//add active state on vclick
		$.mobile.document.bind( "vclick", function( event ) {
			var $btn, btnEls, target = event.target, needClosest = false;
			// if this isn't a left click we don't care. Its important to note
			// that when the virtual event is generated it will create the which attr
			if ( event.which > 1 || !$.mobile.linkBindingEnabled ) {
				return;
			}

			// Record that this element was clicked, in case we need it for correct
			// form submission during the "submit" handler above
			$lastVClicked = $( target );

			// Try to find a target element to which the active class will be applied
			if ( $.data( target, "mobile-button" ) ) {
				// If the form will not be submitted via AJAX, do not add active class
				if ( !getAjaxFormData( $( target ).closest( "form" ), true ) ) {
					return;
				}
				// We will apply the active state to this button widget - the parent
				// of the input that was clicked will have the associated data
				if ( target.parentNode ) {
					target = target.parentNode;
				}
			} else {
				target = findClosestLink( target );
				if ( !( target && path.parseUrl( target.getAttribute( "href" ) || "#" ).hash !== "#" ) ) {
					return;
				}

				// TODO teach $.mobile.hijackable to operate on raw dom elements so the
				// link wrapping can be avoided
				if ( !$( target ).jqmHijackable().length ) {
					return;
				}
			}

			// Avoid calling .closest by using the data set during .buttonMarkup()
			// List items have the button data in the parent of the element clicked
			if ( !!~target.className.indexOf( "ui-link-inherit" ) ) {
				if ( target.parentNode ) {
					btnEls = $.data( target.parentNode, "buttonElements" );
				}
			// Otherwise, look for the data on the target itself
			} else {
				btnEls = $.data( target, "buttonElements" );
			}
			// If found, grab the button's outer element
			if ( btnEls ) {
				target = btnEls.outer;
			} else {
				needClosest = true;
			}

			$btn = $( target );
			// If the outer element wasn't found by the our heuristics, use .closest()
			if ( needClosest ) {
				$btn = $btn.closest( ".ui-btn" );
			}

			if ( $btn.length > 0 && !$btn.hasClass( "ui-disabled" ) ) {
				removeActiveLinkClass( true );
				$activeClickedLink = $btn;
				$activeClickedLink.addClass( $.mobile.activeBtnClass );
			}
		});

		// click routing - direct to HTTP or Ajax, accordingly
		$.mobile.document.bind( "click", function( event ) {
			if ( !$.mobile.linkBindingEnabled || event.isDefaultPrevented() ) {
				return;
			}

			var link = findClosestLink( event.target ), $link = $( link ), httpCleanup;

			// If there is no link associated with the click or its not a left
			// click we want to ignore the click
			// TODO teach $.mobile.hijackable to operate on raw dom elements so the link wrapping
			// can be avoided
			if ( !link || event.which > 1 || !$link.jqmHijackable().length ) {
				return;
			}

			//remove active link class if external (then it won't be there if you come back)
			httpCleanup = function() {
				window.setTimeout(function() { removeActiveLinkClass( true ); }, 200 );
			};

			//if there's a data-rel=back attr, go back in history
			if ( $link.is( ":jqmData(rel='back')" ) ) {
				$.mobile.back();
				return false;
			}

			var baseUrl = getClosestBaseUrl( $link ),

				//get href, if defined, otherwise default to empty hash
				href = path.makeUrlAbsolute( $link.attr( "href" ) || "#", baseUrl );

			//if ajax is disabled, exit early
			if ( !$.mobile.ajaxEnabled && !path.isEmbeddedPage( href ) ) {
				httpCleanup();
				//use default click handling
				return;
			}

			// XXX_jblas: Ideally links to application pages should be specified as
			//            an url to the application document with a hash that is either
			//            the site relative path or id to the page. But some of the
			//            internal code that dynamically generates sub-pages for nested
			//            lists and select dialogs, just write a hash in the link they
			//            create. This means the actual URL path is based on whatever
			//            the current value of the base tag is at the time this code
			//            is called. For now we are just assuming that any url with a
			//            hash in it is an application page reference.
			if ( href.search( "#" ) !== -1 ) {
				href = href.replace( /[^#]*#/, "" );
				if ( !href ) {
					//link was an empty hash meant purely
					//for interaction, so we ignore it.
					event.preventDefault();
					return;
				} else if ( path.isPath( href ) ) {
					//we have apath so make it the href we want to load.
					href = path.makeUrlAbsolute( href, baseUrl );
				} else {
					//we have a simple id so use the documentUrl as its base.
					href = path.makeUrlAbsolute( "#" + href, documentUrl.hrefNoHash );
				}
			}

				// Should we handle this link, or let the browser deal with it?
			var useDefaultUrlHandling = $link.is( "[rel='external']" ) || $link.is( ":jqmData(ajax='false')" ) || $link.is( "[target]" ),

				// Some embedded browsers, like the web view in Phone Gap, allow cross-domain XHR
				// requests if the document doing the request was loaded via the file:// protocol.
				// This is usually to allow the application to "phone home" and fetch app specific
				// data. We normally let the browser handle external/cross-domain urls, but if the
				// allowCrossDomainPages option is true, we will allow cross-domain http/https
				// requests to go through our page loading logic.

				//check for protocol or rel and its not an embedded page
				//TODO overlap in logic from isExternal, rel=external check should be
				//     moved into more comprehensive isExternalLink
				isExternal = useDefaultUrlHandling || ( path.isExternal( href ) && !path.isPermittedCrossDomainRequest( documentUrl, href ) );

			if ( isExternal ) {
				httpCleanup();
				//use default click handling
				return;
			}

			//use ajax
			var transition = $link.jqmData( "transition" ),
				reverse = $link.jqmData( "direction" ) === "reverse" ||
							// deprecated - remove by 1.0
							$link.jqmData( "back" ),

				//this may need to be more specific as we use data-rel more
				role = $link.attr( "data-" + $.mobile.ns + "rel" ) || undefined;

			$.mobile.changePage( href, { transition: transition, reverse: reverse, role: role, link: $link } );
			event.preventDefault();
		});

		//prefetch pages when anchors with data-prefetch are encountered
		$.mobile.document.delegate( ".ui-page", "pageshow.prefetch", function() {
			var urls = [];
			$( this ).find( "a:jqmData(prefetch)" ).each(function() {
				var $link = $( this ),
					url = $link.attr( "href" );

				if ( url && $.inArray( url, urls ) === -1 ) {
					urls.push( url );

					$.mobile.loadPage( url, { role: $link.attr( "data-" + $.mobile.ns + "rel" ),prefetch: true } );
				}
			});
		});

		$.mobile._handleHashChange = function( url, data ) {
			//find first page via hash
			var to = path.stripHash(url),
				//transition is false if it's the first page, undefined otherwise (and may be overridden by default)
				transition = $.mobile.urlHistory.stack.length === 0 ? "none" : undefined,

				// default options for the changPage calls made after examining the current state
				// of the page and the hash, NOTE that the transition is derived from the previous
				// history entry
				changePageOptions = {
					changeHash: false,
					fromHashChange: true,
					reverse: data.direction === "back"
				};

			$.extend( changePageOptions, data, {
				transition: (urlHistory.getLast() || {}).transition || transition
			});

			// special case for dialogs
			if ( urlHistory.activeIndex > 0 && to.indexOf( dialogHashKey ) > -1 && urlHistory.initialDst !== to ) {

				// If current active page is not a dialog skip the dialog and continue
				// in the same direction
				if ( $.mobile.activePage && !$.mobile.activePage.is( ".ui-dialog" ) ) {
					//determine if we're heading forward or backward and continue accordingly past
					//the current dialog
					if( data.direction === "back" ) {
						$.mobile.back();
					} else {
						window.history.forward();
					}

					// prevent changePage call
					return;
				} else {
					// if the current active page is a dialog and we're navigating
					// to a dialog use the dialog objected saved in the stack
					to = data.pageUrl;
					var active = $.mobile.urlHistory.getActive();

					// make sure to set the role, transition and reversal
					// as most of this is lost by the domCache cleaning
					$.extend( changePageOptions, {
						role: active.role,
						transition: active.transition,
						reverse: data.direction === "back"
					});
				}
			}

			//if to is defined, load it
			if ( to ) {
				// At this point, 'to' can be one of 3 things, a cached page element from
				// a history stack entry, an id, or site-relative/absolute URL. If 'to' is
				// an id, we need to resolve it against the documentBase, not the location.href,
				// since the hashchange could've been the result of a forward/backward navigation
				// that crosses from an external page/dialog to an internal page/dialog.
				to = !path.isPath( to ) ? ( path.makeUrlAbsolute( '#' + to, documentBase ) ) : to;

				// If we're about to go to an initial URL that contains a reference to a non-existent
				// internal page, go to the first page instead. We know that the initial hash refers to a
				// non-existent page, because the initial hash did not end up in the initial urlHistory entry
				if ( to === path.makeUrlAbsolute( '#' + urlHistory.initialDst, documentBase ) &&
					urlHistory.stack.length && urlHistory.stack[0].url !== urlHistory.initialDst.replace( dialogHashKey, "" ) ) {
					to = $.mobile.firstPage;
				}

				$.mobile.changePage( to, changePageOptions );
			}	else {

				//there's no hash, go to the first page in the dom
				$.mobile.changePage( $.mobile.firstPage, changePageOptions );
			}
		};

		// TODO roll the logic here into the handleHashChange method
		$window.bind( "navigate", function( e, data ) {
			var url;

			if ( e.originalEvent && e.originalEvent.isDefaultPrevented() ) {
				return;
			}

			url = $.event.special.navigate.originalEventName.indexOf( "hashchange" ) > -1 ? data.state.hash : data.state.url;

			if( !url ) {
				url = $.mobile.path.parseLocation().hash;
			}

			if( !url || url === "#" || url.indexOf( "#" + $.mobile.path.uiStateKey ) === 0 ){
				url = location.href;
			}

			$.mobile._handleHashChange( url, data.state );
		});

		//set page min-heights to be device specific
		$.mobile.document.bind( "pageshow", $.mobile.resetActivePageHeight );
		$.mobile.window.bind( "throttledresize", $.mobile.resetActivePageHeight );

	};//navreadyDeferred done callback

	$( function() { domreadyDeferred.resolve(); } );

	$.when( domreadyDeferred, $.mobile.navreadyDeferred ).done( function() { $.mobile._registerInternalEvents(); } );
})( jQuery );

/*
* fallback transition for flip in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.flip = "fade";

})( jQuery, this );
/*
* fallback transition for flow in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.flow = "fade";

})( jQuery, this );
/*
* fallback transition for pop in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.pop = "fade";

})( jQuery, this );
/*
* fallback transition for slide in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

// Use the simultaneous transitions handler for slide transitions
$.mobile.transitionHandlers.slide = $.mobile.transitionHandlers.simultaneous;

// Set the slide transitions's fallback to "fade"
$.mobile.transitionFallbacks.slide = "fade";

})( jQuery, this );
/*
* fallback transition for slidedown in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.slidedown = "fade";

})( jQuery, this );
/*
* fallback transition for slidefade in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

// Set the slide transitions's fallback to "fade"
$.mobile.transitionFallbacks.slidefade = "fade";

})( jQuery, this );
/*
* fallback transition for slideup in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.slideup = "fade";

})( jQuery, this );
/*
* fallback transition for turn in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.turn = "fade";

})( jQuery, this );

(function( $, undefined ) {

$.mobile.page.prototype.options.degradeInputs = {
	color: false,
	date: false,
	datetime: false,
	"datetime-local": false,
	email: false,
	month: false,
	number: false,
	range: "number",
	search: "text",
	tel: false,
	time: false,
	url: false,
	week: false
};


//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {

	var page = $.mobile.closestPageData( $( e.target ) ), options;

	if ( !page ) {
		return;
	}

	options = page.options;

	// degrade inputs to avoid poorly implemented native functionality
	$( e.target ).find( "input" ).not( page.keepNativeSelector() ).each(function() {
		var $this = $( this ),
			type = this.getAttribute( "type" ),
			optType = options.degradeInputs[ type ] || "text";

		if ( options.degradeInputs[ type ] ) {
			var html = $( "<div>" ).html( $this.clone() ).html(),
				// In IE browsers, the type sometimes doesn't exist in the cloned markup, so we replace the closing tag instead
				hasType = html.indexOf( " type=" ) > -1,
				findstr = hasType ? /\s+type=["']?\w+['"]?/ : /\/?>/,
				repstr = " type=\"" + optType + "\" data-" + $.mobile.ns + "type=\"" + type + "\"" + ( hasType ? "" : ">" );

			$this.replaceWith( html.replace( findstr, repstr ) );
		}
	});

});

})( jQuery );

(function( $, window, undefined ) {

$.widget( "mobile.dialog", $.mobile.widget, {
	options: {
		closeBtn: "left",
		closeBtnText: "Close",
		overlayTheme: "a",
		corners: true,
		initSelector: ":jqmData(role='dialog')"
	},

	// Override the theme set by the page plugin on pageshow
	_handlePageBeforeShow: function() {
		this._isCloseable = true;
		if ( this.options.overlayTheme ) {
			this.element
				.page( "removeContainerBackground" )
				.page( "setContainerBackground", this.options.overlayTheme );
		}
	},

	_create: function() {
		var self = this,
			$el = this.element,
			cornerClass = !!this.options.corners ? " ui-corner-all" : "",
			dialogWrap = $( "<div/>", {
					"role" : "dialog",
					"class" : "ui-dialog-contain ui-overlay-shadow" + cornerClass
				});

		$el.addClass( "ui-dialog ui-overlay-" + this.options.overlayTheme );

		// Class the markup for dialog styling
		// Set aria role
		$el.wrapInner( dialogWrap );

		/* bind events
			- clicks and submits should use the closing transition that the dialog opened with
				unless a data-transition is specified on the link/form
			- if the click was on the close button, or the link has a data-rel="back" it'll go back in history naturally
		*/
		$el.bind( "vclick submit", function( event ) {
			var $target = $( event.target ).closest( event.type === "vclick" ? "a" : "form" ),
				active;

			if ( $target.length && !$target.jqmData( "transition" ) ) {

				active = $.mobile.urlHistory.getActive() || {};

				$target.attr( "data-" + $.mobile.ns + "transition", ( active.transition || $.mobile.defaultDialogTransition ) )
					.attr( "data-" + $.mobile.ns + "direction", "reverse" );
			}
		});

		this._on( $el, {
			pagebeforeshow: "_handlePageBeforeShow"
		});

		$.extend( this, {
			_createComplete: false
		});

		this._setCloseBtn( this.options.closeBtn );
	},

	_setCloseBtn: function( value ) {
		var self = this, btn, location;

		if ( this._headerCloseButton ) {
			this._headerCloseButton.remove();
			this._headerCloseButton = null;
		}
		if ( value !== "none" ) {
			// Sanitize value
			location = ( value === "left" ? "left" : "right" );
			btn = $( "<a href='#' class='ui-btn-" + location + "' data-" + $.mobile.ns + "icon='delete' data-" + $.mobile.ns + "iconpos='notext'>"+ this.options.closeBtnText + "</a>" );
			this.element.children().find( ":jqmData(role='header')" ).first().prepend( btn );
			if ( this._createComplete && $.fn.buttonMarkup ) {
				btn.buttonMarkup();
			}
			this._createComplete = true;

			// this must be an anonymous function so that select menu dialogs can replace
			// the close method. This is a change from previously just defining data-rel=back
			// on the button and letting nav handle it
			//
			// Use click rather than vclick in order to prevent the possibility of unintentionally
			// reopening the dialog if the dialog opening item was directly under the close button.
			btn.bind( "click", function() {
				self.close();
			});

			this._headerCloseButton = btn;
		}
	},

	_setOption: function( key, value ) {
		if ( key === "closeBtn" ) {
			this._setCloseBtn( value );
		}
		this._super( key, value );
	},

	// Close method goes back in history
	close: function() {
		var idx, dst, hist = $.mobile.navigate.history;

		if ( this._isCloseable ) {
			this._isCloseable = false;
			// If the hash listening is enabled and there is at least one preceding history
			// entry it's ok to go back. Initial pages with the dialog hash state are an example
			// where the stack check is necessary
			if ( $.mobile.hashListeningEnabled && hist.activeIndex > 0 ) {
				$.mobile.back();
			} else {
				idx = Math.max( 0, hist.activeIndex - 1 );
				dst = hist.stack[ idx ].pageUrl || hist.stack[ idx ].url;
				hist.previousIndex = hist.activeIndex;
				hist.activeIndex = idx;
				if ( !$.mobile.path.isPath( dst ) ) {
					dst = $.mobile.path.makeUrlAbsolute( "#" + dst );
				}

				$.mobile.changePage( dst, { direction: "back", changeHash: false, fromHashChange: true } );
			}
		}
	}
});

//auto self-init widgets
$.mobile.document.delegate( $.mobile.dialog.prototype.options.initSelector, "pagecreate", function() {
	$.mobile.dialog.prototype.enhance( this );
});

})( jQuery, this );

(function( $, undefined ) {

$.mobile.page.prototype.options.backBtnText  = "Back";
$.mobile.page.prototype.options.addBackBtn   = false;
$.mobile.page.prototype.options.backBtnTheme = null;
$.mobile.page.prototype.options.headerTheme  = "a";
$.mobile.page.prototype.options.footerTheme  = "a";
$.mobile.page.prototype.options.contentTheme = null;

// NOTE bind used to force this binding to run before the buttonMarkup binding
//      which expects .ui-footer top be applied in its gigantic selector
// TODO remove the buttonMarkup giant selector and move it to the various modules
//      on which it depends
$.mobile.document.bind( "pagecreate", function( e ) {
	var $page = $( e.target ),
		o = $page.data( "mobile-page" ).options,
		pageRole = $page.jqmData( "role" ),
		pageTheme = o.theme;

	$( ":jqmData(role='header'), :jqmData(role='footer'), :jqmData(role='content')", $page )
		.jqmEnhanceable()
		.each(function() {

		var $this = $( this ),
			role = $this.jqmData( "role" ),
			theme = $this.jqmData( "theme" ),
			contentTheme = theme || o.contentTheme || ( pageRole === "dialog" && pageTheme ),
			$headeranchors,
			leftbtn,
			rightbtn,
			backBtn;

		$this.addClass( "ui-" + role );

		//apply theming and markup modifications to page,header,content,footer
		if ( role === "header" || role === "footer" ) {

			var thisTheme = theme || ( role === "header" ? o.headerTheme : o.footerTheme ) || pageTheme;

			$this
				//add theme class
				.addClass( "ui-bar-" + thisTheme )
				// Add ARIA role
				.attr( "role", role === "header" ? "banner" : "contentinfo" );

			if ( role === "header") {
				// Right,left buttons
				$headeranchors	= $this.children( "a, button" );
				leftbtn	= $headeranchors.hasClass( "ui-btn-left" );
				rightbtn = $headeranchors.hasClass( "ui-btn-right" );

				leftbtn = leftbtn || $headeranchors.eq( 0 ).not( ".ui-btn-right" ).addClass( "ui-btn-left" ).length;

				rightbtn = rightbtn || $headeranchors.eq( 1 ).addClass( "ui-btn-right" ).length;
			}

			// Auto-add back btn on pages beyond first view
			if ( o.addBackBtn &&
				role === "header" &&
				$( ".ui-page" ).length > 1 &&
				$page.jqmData( "url" ) !== $.mobile.path.stripHash( location.hash ) &&
				!leftbtn ) {

				backBtn = $( "<a href='javascript:void(0);' class='ui-btn-left' data-"+ $.mobile.ns +"rel='back' data-"+ $.mobile.ns +"icon='arrow-l'>"+ o.backBtnText +"</a>" )
					// If theme is provided, override default inheritance
					.attr( "data-"+ $.mobile.ns +"theme", o.backBtnTheme || thisTheme )
					.prependTo( $this );
			}

			// Page title
			$this.children( "h1, h2, h3, h4, h5, h6" )
				.addClass( "ui-title" )
				// Regardless of h element number in src, it becomes h1 for the enhanced page
				.attr({
					"role": "heading",
					"aria-level": "1"
				});

		} else if ( role === "content" ) {
			if ( contentTheme ) {
				$this.addClass( "ui-body-" + ( contentTheme ) );
			}

			// Add ARIA role
			$this.attr( "role", "main" );
		}
	});
});

})( jQuery );

(function( $, undefined ) {

// This function calls getAttribute, which should be safe for data-* attributes
var getAttrFixed = function( e, key ) {
	var value = e.getAttribute( key );

	return value === "true" ? true :
		value === "false" ? false :
		value === null ? undefined : value;
};

$.fn.buttonMarkup = function( options ) {
	var $workingSet = this,
		nsKey = "data-" + $.mobile.ns,
		key;

	// Enforce options to be of type string
	options = ( options && ( $.type( options ) === "object" ) )? options : {};
	for ( var i = 0; i < $workingSet.length; i++ ) {
		var el = $workingSet.eq( i ),
			e = el[ 0 ],
			o = $.extend( {}, $.fn.buttonMarkup.defaults, {
				icon:       options.icon       !== undefined ? options.icon       : getAttrFixed( e, nsKey + "icon" ),
				iconpos:    options.iconpos    !== undefined ? options.iconpos    : getAttrFixed( e, nsKey + "iconpos" ),
				theme:      options.theme      !== undefined ? options.theme      : getAttrFixed( e, nsKey + "theme" ) || $.mobile.getInheritedTheme( el, "c" ),
				inline:     options.inline     !== undefined ? options.inline     : getAttrFixed( e, nsKey + "inline" ),
				shadow:     options.shadow     !== undefined ? options.shadow     : getAttrFixed( e, nsKey + "shadow" ),
				corners:    options.corners    !== undefined ? options.corners    : getAttrFixed( e, nsKey + "corners" ),
				iconshadow: options.iconshadow !== undefined ? options.iconshadow : getAttrFixed( e, nsKey + "iconshadow" ),
				mini:       options.mini       !== undefined ? options.mini       : getAttrFixed( e, nsKey + "mini" )
			}, options ),

			// Classes Defined
			innerClass = "ui-btn-inner",
			textClass = "ui-btn-text",
			buttonClass, iconClass,
			hover = false,
			state = "up",
			// Button inner markup
			buttonInner,
			buttonText,
			buttonIcon,
			buttonElements;

		for ( key in o ) {
			if ( o[ key ] === undefined || o[ key ] === null ) {
				el.removeAttr( nsKey + key );
			} else {
				e.setAttribute( nsKey + key, o[ key ] );
			}
		}

		if ( getAttrFixed( e, nsKey + "rel" ) === "popup" && el.attr( "href" ) ) {
			e.setAttribute( "aria-haspopup", true );
			e.setAttribute( "aria-owns", el.attr( "href" ) );
		}

		// Check if this element is already enhanced
		buttonElements = $.data( ( ( e.tagName === "INPUT" || e.tagName === "BUTTON" ) ? e.parentNode : e ), "buttonElements" );

		if ( buttonElements ) {
			e = buttonElements.outer;
			el = $( e );
			buttonInner = buttonElements.inner;
			buttonText = buttonElements.text;
			// We will recreate this icon below
			$( buttonElements.icon ).remove();
			buttonElements.icon = null;
			hover = buttonElements.hover;
			state = buttonElements.state;
		}
		else {
			buttonInner = document.createElement( o.wrapperEls );
			buttonText = document.createElement( o.wrapperEls );
		}
		buttonIcon = o.icon ? document.createElement( "span" ) : null;

		if ( attachEvents && !buttonElements ) {
			attachEvents();
		}

		// if not, try to find closest theme container
		if ( !o.theme ) {
			o.theme = $.mobile.getInheritedTheme( el, "c" );
		}

		buttonClass = "ui-btn ";
		buttonClass += ( hover ? "ui-btn-hover-" + o.theme : "" );
		buttonClass += ( state ? " ui-btn-" + state + "-" + o.theme : "" );
		buttonClass += o.shadow ? " ui-shadow" : "";
		buttonClass += o.corners ? " ui-btn-corner-all" : "";

		if ( o.mini !== undefined ) {
			// Used to control styling in headers/footers, where buttons default to `mini` style.
			buttonClass += o.mini === true ? " ui-mini" : " ui-fullsize";
		}

		if ( o.inline !== undefined ) {
			// Used to control styling in headers/footers, where buttons default to `inline` style.
			buttonClass += o.inline === true ? " ui-btn-inline" : " ui-btn-block";
		}

		if ( o.icon ) {
			o.icon = "ui-icon-" + o.icon;
			o.iconpos = o.iconpos || "left";

			iconClass = "ui-icon " + o.icon;

			if ( o.iconshadow ) {
				iconClass += " ui-icon-shadow";
			}
		}

		if ( o.iconpos ) {
			buttonClass += " ui-btn-icon-" + o.iconpos;

			if ( o.iconpos === "notext" && !el.attr( "title" ) ) {
				el.attr( "title", el.getEncodedText() );
			}
		}

		if ( buttonElements ) {
			el.removeClass( buttonElements.bcls || "" );
		}
		el.removeClass( "ui-link" ).addClass( buttonClass );

		buttonInner.className = innerClass;
		buttonText.className = textClass;
		if ( !buttonElements ) {
			buttonInner.appendChild( buttonText );
		}
		if ( buttonIcon ) {
			buttonIcon.className = iconClass;
			if ( !( buttonElements && buttonElements.icon ) ) {
				buttonIcon.innerHTML = "&#160;";
				buttonInner.appendChild( buttonIcon );
			}
		}

		while ( e.firstChild && !buttonElements ) {
			buttonText.appendChild( e.firstChild );
		}

		if ( !buttonElements ) {
			e.appendChild( buttonInner );
		}

		// Assign a structure containing the elements of this button to the elements of this button. This
		// will allow us to recognize this as an already-enhanced button in future calls to buttonMarkup().
		buttonElements = {
			hover : hover,
			state : state,
			bcls  : buttonClass,
			outer : e,
			inner : buttonInner,
			text  : buttonText,
			icon  : buttonIcon
		};

		$.data( e,           'buttonElements', buttonElements );
		$.data( buttonInner, 'buttonElements', buttonElements );
		$.data( buttonText,  'buttonElements', buttonElements );
		if ( buttonIcon ) {
			$.data( buttonIcon, 'buttonElements', buttonElements );
		}
	}

	return this;
};

$.fn.buttonMarkup.defaults = {
	corners: true,
	shadow: true,
	iconshadow: true,
	wrapperEls: "span"
};

function closestEnabledButton( element ) {
    var cname;

    while ( element ) {
		// Note that we check for typeof className below because the element we
		// handed could be in an SVG DOM where className on SVG elements is defined to
		// be of a different type (SVGAnimatedString). We only operate on HTML DOM
		// elements, so we look for plain "string".
        cname = ( typeof element.className === 'string' ) && ( element.className + ' ' );
        if ( cname && cname.indexOf( "ui-btn " ) > -1 && cname.indexOf( "ui-disabled " ) < 0 ) {
            break;
        }

        element = element.parentNode;
    }

    return element;
}

function updateButtonClass( $btn, classToRemove, classToAdd, hover, state ) {
	var buttonElements = $.data( $btn[ 0 ], "buttonElements" );
	$btn.removeClass( classToRemove ).addClass( classToAdd );
	if ( buttonElements ) {
		buttonElements.bcls = $( document.createElement( "div" ) )
			.addClass( buttonElements.bcls + " " + classToAdd )
			.removeClass( classToRemove )
			.attr( "class" );
		if ( hover !== undefined ) {
			buttonElements.hover = hover;
		}
		buttonElements.state = state;
	}
}

var attachEvents = function() {
	var hoverDelay = $.mobile.buttonMarkup.hoverDelay, hov, foc;

	$.mobile.document.bind( {
		"vmousedown vmousecancel vmouseup vmouseover vmouseout focus blur scrollstart": function( event ) {
			var theme,
				$btn = $( closestEnabledButton( event.target ) ),
				isTouchEvent = event.originalEvent && /^touch/.test( event.originalEvent.type ),
				evt = event.type;

			if ( $btn.length ) {
				theme = $btn.attr( "data-" + $.mobile.ns + "theme" );

				if ( evt === "vmousedown" ) {
					if ( isTouchEvent ) {
						// Use a short delay to determine if the user is scrolling before highlighting
						hov = setTimeout( function() {
							updateButtonClass( $btn, "ui-btn-up-" + theme, "ui-btn-down-" + theme, undefined, "down" );
						}, hoverDelay );
					} else {
						updateButtonClass( $btn, "ui-btn-up-" + theme, "ui-btn-down-" + theme, undefined, "down" );
					}
				} else if ( evt === "vmousecancel" || evt === "vmouseup" ) {
					updateButtonClass( $btn, "ui-btn-down-" + theme, "ui-btn-up-" + theme, undefined, "up" );
				} else if ( evt === "vmouseover" || evt === "focus" ) {
					if ( isTouchEvent ) {
						// Use a short delay to determine if the user is scrolling before highlighting
						foc = setTimeout( function() {
							updateButtonClass( $btn, "ui-btn-up-" + theme, "ui-btn-hover-" + theme, true, "" );
						}, hoverDelay );
					} else {
						updateButtonClass( $btn, "ui-btn-up-" + theme, "ui-btn-hover-" + theme, true, "" );
					}
				} else if ( evt === "vmouseout" || evt === "blur" || evt === "scrollstart" ) {
					updateButtonClass( $btn, "ui-btn-hover-" + theme  + " ui-btn-down-" + theme, "ui-btn-up-" + theme, false, "up" );
					if ( hov ) {
						clearTimeout( hov );
					}
					if ( foc ) {
						clearTimeout( foc );
					}
				}
			}
		},
		"focusin focus": function( event ) {
			$( closestEnabledButton( event.target ) ).addClass( $.mobile.focusClass );
		},
		"focusout blur": function( event ) {
			$( closestEnabledButton( event.target ) ).removeClass( $.mobile.focusClass );
		}
	});

	attachEvents = null;
};

//links in bars, or those with  data-role become buttons
//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {

	$( ":jqmData(role='button'), .ui-bar > a, .ui-header > a, .ui-footer > a, .ui-bar > :jqmData(role='controlgroup') > a", e.target )
		.jqmEnhanceable()
		.not( "button, input, .ui-btn, :jqmData(role='none'), :jqmData(role='nojs')" )
		.buttonMarkup();
});

})( jQuery );


(function( $, undefined ) {

$.widget( "mobile.collapsible", $.mobile.widget, {
	options: {
		expandCueText: " click to expand contents",
		collapseCueText: " click to collapse contents",
		collapsed: true,
		heading: "h1,h2,h3,h4,h5,h6,legend",
		collapsedIcon: "plus",
		expandedIcon: "minus",
		iconpos: "left",
		theme: null,
		contentTheme: null,
		inset: true,
		corners: true,
		mini: false,
		initSelector: ":jqmData(role='collapsible')"
	},
	_create: function() {

		var $el = this.element,
			o = this.options,
			collapsible = $el.addClass( "ui-collapsible" ),
			collapsibleHeading = $el.children( o.heading ).first(),
			collapsibleContent = collapsible.wrapInner( "<div class='ui-collapsible-content'></div>" ).children( ".ui-collapsible-content" ),
			collapsibleSet = $el.closest( ":jqmData(role='collapsible-set')" ).addClass( "ui-collapsible-set" ),
			collapsibleClasses = "";

		// Replace collapsibleHeading if it's a legend
		if ( collapsibleHeading.is( "legend" ) ) {
			collapsibleHeading = $( "<div role='heading'>"+ collapsibleHeading.html() +"</div>" ).insertBefore( collapsibleHeading );
			collapsibleHeading.next().remove();
		}

		// If we are in a collapsible set
		if ( collapsibleSet.length ) {
			// Inherit the theme from collapsible-set
			if ( !o.theme ) {
				o.theme = collapsibleSet.jqmData( "theme" ) || $.mobile.getInheritedTheme( collapsibleSet, "c" );
			}
			// Inherit the content-theme from collapsible-set
			if ( !o.contentTheme ) {
				o.contentTheme = collapsibleSet.jqmData( "content-theme" );
			}

			// Get the preference for collapsed icon in the set, but override with data- attribute on the individual collapsible
			o.collapsedIcon = $el.jqmData( "collapsed-icon" ) || collapsibleSet.jqmData( "collapsed-icon" ) || o.collapsedIcon;

			// Get the preference for expanded icon in the set, but override with data- attribute on the individual collapsible
			o.expandedIcon = $el.jqmData( "expanded-icon" ) || collapsibleSet.jqmData( "expanded-icon" ) || o.expandedIcon;

			// Gets the preference icon position in the set, but override with data- attribute on the individual collapsible
			o.iconpos = $el.jqmData( "iconpos" ) || collapsibleSet.jqmData( "iconpos" ) || o.iconpos;

			// Inherit the preference for inset from collapsible-set or set the default value to ensure equalty within a set
			if ( collapsibleSet.jqmData( "inset" ) !== undefined ) {
				o.inset = collapsibleSet.jqmData( "inset" );
			} else {
				o.inset = true;
			}
			// Set corners for individual collapsibles to false when in a collapsible-set
			o.corners = false;
			// Gets the preference for mini in the set
			if ( !o.mini ) {
				o.mini = collapsibleSet.jqmData( "mini" );
			}
		} else {
			// get inherited theme if not a set and no theme has been set
			if ( !o.theme ) {
				o.theme = $.mobile.getInheritedTheme( $el, "c" );
			}
		}

		if ( !!o.inset ) {
			collapsibleClasses += " ui-collapsible-inset";
			if ( !!o.corners ) {
				collapsibleClasses += " ui-corner-all" ;
			}
		}
		if ( o.contentTheme ) {
			collapsibleClasses += " ui-collapsible-themed-content";
			collapsibleContent.addClass( "ui-body-" + o.contentTheme );
		}
		if ( collapsibleClasses !== "" ) {
			collapsible.addClass( collapsibleClasses );
		}
		
		collapsibleHeading
			//drop heading in before content
			.insertBefore( collapsibleContent )
			//modify markup & attributes
			.addClass( "ui-collapsible-heading" )
			.append( "<span class='ui-collapsible-heading-status'></span>" )
			.wrapInner( "<a href='#' class='ui-collapsible-heading-toggle'></a>" )
			.find( "a" )
				.first()
				.buttonMarkup({
					shadow: false,
					corners: false,
					iconpos: o.iconpos,
					icon: o.collapsedIcon,
					mini: o.mini,
					theme: o.theme
				});

		//events
		collapsible
			.bind( "expand collapse", function( event ) {
				if ( !event.isDefaultPrevented() ) {
					var $this = $( this ),
						isCollapse = ( event.type === "collapse" );

					event.preventDefault();

					collapsibleHeading
						.toggleClass( "ui-collapsible-heading-collapsed", isCollapse )
						.find( ".ui-collapsible-heading-status" )
							.text( isCollapse ? o.expandCueText : o.collapseCueText )
						.end()
						.find( ".ui-icon" )
							.toggleClass( "ui-icon-" + o.expandedIcon, !isCollapse )
							// logic or cause same icon for expanded/collapsed state would remove the ui-icon-class
							.toggleClass( "ui-icon-" + o.collapsedIcon, ( isCollapse || o.expandedIcon === o.collapsedIcon ) )
						.end()
						.find( "a" ).first().removeClass( $.mobile.activeBtnClass );

					$this.toggleClass( "ui-collapsible-collapsed", isCollapse );
					collapsibleContent.toggleClass( "ui-collapsible-content-collapsed", isCollapse ).attr( "aria-hidden", isCollapse );

					collapsibleContent.trigger( "updatelayout" );
				}
			})
			.trigger( o.collapsed ? "collapse" : "expand" );

		collapsibleHeading
			.bind( "tap", function( event ) {
				collapsibleHeading.find( "a" ).first().addClass( $.mobile.activeBtnClass );
			})
			.bind( "vclick", function( event ) {

				var type = collapsibleHeading.is( ".ui-collapsible-heading-collapsed" ) ? "expand" : "collapse";

				collapsible.trigger( type );

				event.preventDefault();
				event.stopPropagation();
			});
	}
});

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.collapsible.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $, undefined ) {

$.mobile.behaviors.addFirstLastClasses = {
	_getVisibles: function( $els, create ) {
		var visibles;

		if ( create ) {
			visibles = $els.not( ".ui-screen-hidden" );
		} else {
			visibles = $els.filter( ":visible" );
			if ( visibles.length === 0 ) {
				visibles = $els.not( ".ui-screen-hidden" );
			}
		}

		return visibles;
	},

	_addFirstLastClasses: function( $els, $visibles, create ) {
		$els.removeClass( "ui-first-child ui-last-child" );
		$visibles.eq( 0 ).addClass( "ui-first-child" ).end().last().addClass( "ui-last-child" );
		if ( !create ) {
			this.element.trigger( "updatelayout" );
		}
	}
};

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.collapsibleset", $.mobile.widget, $.extend( {
	options: {
		initSelector: ":jqmData(role='collapsible-set')"
	},
	_create: function() {
		var $el = this.element.addClass( "ui-collapsible-set" ),
			o = this.options;

		// Inherit the theme from collapsible-set
		if ( !o.theme ) {
			o.theme = $.mobile.getInheritedTheme( $el, "c" );
		}
		// Inherit the content-theme from collapsible-set
		if ( !o.contentTheme ) {
			o.contentTheme = $el.jqmData( "content-theme" );
		}
		// Inherit the corner styling from collapsible-set
		if ( !o.corners ) {
			o.corners = $el.jqmData( "corners" );
		}
		
		if ( $el.jqmData( "inset" ) !== undefined ) {
			o.inset = $el.jqmData( "inset" );
		}
		o.inset = o.inset !== undefined ? o.inset : true;
		o.corners = o.corners !== undefined ? o.corners : true;
		
		if ( !!o.corners && !!o.inset ) {
			$el.addClass( "ui-corner-all" );
		}

		// Initialize the collapsible set if it's not already initialized
		if ( !$el.jqmData( "collapsiblebound" ) ) {
			$el
				.jqmData( "collapsiblebound", true )
				.bind( "expand", function( event ) {
					var closestCollapsible = $( event.target )
						.closest( ".ui-collapsible" );
					if ( closestCollapsible.parent().is( ":jqmData(role='collapsible-set')" ) ) {
						closestCollapsible
							.siblings( ".ui-collapsible" )
							.trigger( "collapse" );
					}
				});
		}
	},

	_init: function() {
		var $el = this.element,
			collapsiblesInSet = $el.children( ":jqmData(role='collapsible')" ),
			expanded = collapsiblesInSet.filter( ":jqmData(collapsed='false')" );
		this._refresh( "true" );

		// Because the corners are handled by the collapsible itself and the default state is collapsed
		// That was causing https://github.com/jquery/jquery-mobile/issues/4116
		expanded.trigger( "expand" );
	},

	_refresh: function( create ) {
		var collapsiblesInSet = this.element.children( ":jqmData(role='collapsible')" );

		$.mobile.collapsible.prototype.enhance( collapsiblesInSet.not( ".ui-collapsible" ) );

		this._addFirstLastClasses( collapsiblesInSet, this._getVisibles( collapsiblesInSet, create ), create );
	},

	refresh: function() {
		this._refresh( false );
	}
}, $.mobile.behaviors.addFirstLastClasses ) );

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.collapsibleset.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $, undefined ) {

// filter function removes whitespace between label and form element so we can use inline-block (nodeType 3 = text)
$.fn.fieldcontain = function( options ) {
	return this
		.addClass( "ui-field-contain ui-body ui-br" )
		.contents().filter( function() {
			return ( this.nodeType === 3 && !/\S/.test( this.nodeValue ) );
		}).remove();
};

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ) {
	$( ":jqmData(role='fieldcontain')", e.target ).jqmEnhanceable().fieldcontain();
});

})( jQuery );

(function( $, undefined ) {

$.fn.grid = function( options ) {
	return this.each(function() {

		var $this = $( this ),
			o = $.extend({
				grid: null
			}, options ),
			$kids = $this.children(),
			gridCols = { solo:1, a:2, b:3, c:4, d:5 },
			grid = o.grid,
			iterator;

			if ( !grid ) {
				if ( $kids.length <= 5 ) {
					for ( var letter in gridCols ) {
						if ( gridCols[ letter ] === $kids.length ) {
							grid = letter;
						}
					}
				} else {
					grid = "a";
					$this.addClass( "ui-grid-duo" );
				}
			}
			iterator = gridCols[grid];

		$this.addClass( "ui-grid-" + grid );

		$kids.filter( ":nth-child(" + iterator + "n+1)" ).addClass( "ui-block-a" );

		if ( iterator > 1 ) {
			$kids.filter( ":nth-child(" + iterator + "n+2)" ).addClass( "ui-block-b" );
		}
		if ( iterator > 2 ) {
			$kids.filter( ":nth-child(" + iterator + "n+3)" ).addClass( "ui-block-c" );
		}
		if ( iterator > 3 ) {
			$kids.filter( ":nth-child(" + iterator + "n+4)" ).addClass( "ui-block-d" );
		}
		if ( iterator > 4 ) {
			$kids.filter( ":nth-child(" + iterator + "n+5)" ).addClass( "ui-block-e" );
		}
	});
};
})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.navbar", $.mobile.widget, {
	options: {
		iconpos: "top",
		grid: null,
		initSelector: ":jqmData(role='navbar')"
	},

	_create: function() {

		var $navbar = this.element,
			$navbtns = $navbar.find( "a" ),
			iconpos = $navbtns.filter( ":jqmData(icon)" ).length ?
									this.options.iconpos : undefined;

		$navbar.addClass( "ui-navbar ui-mini" )
			.attr( "role", "navigation" )
			.find( "ul" )
			.jqmEnhanceable()
			.grid({ grid: this.options.grid });

		$navbtns.buttonMarkup({
			corners:	false,
			shadow:		false,
			inline:     true,
			iconpos:	iconpos
		});

		$navbar.delegate( "a", "vclick", function( event ) {
			// ui-btn-inner is returned as target
			var target = $( event.target ).is( "a" ) ? $( this ) : $( this ).parent( "a" );
			
			if ( !target.is( ".ui-disabled, .ui-btn-active" ) ) {
				$navbtns.removeClass( $.mobile.activeBtnClass );
				$( this ).addClass( $.mobile.activeBtnClass );
				
				// The code below is a workaround to fix #1181
				var activeBtn = $( this );
				
				$( document ).one( "pagehide", function() {
					activeBtn.removeClass( $.mobile.activeBtnClass );
				});
			}
		});

		// Buttons in the navbar with ui-state-persist class should regain their active state before page show
		$navbar.closest( ".ui-page" ).bind( "pagebeforeshow", function() {
			$navbtns.filter( ".ui-state-persist" ).addClass( $.mobile.activeBtnClass );
		});
	}
});

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.navbar.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $, undefined ) {

//Keeps track of the number of lists per page UID
//This allows support for multiple nested list in the same page
//https://github.com/jquery/jquery-mobile/issues/1617
var listCountPerPage = {};

$.widget( "mobile.listview", $.mobile.widget, $.extend( {

	options: {
		theme: null,
		countTheme: "c",
		headerTheme: "b",
		dividerTheme: "b",
		icon: "arrow-r",
		splitIcon: "arrow-r",
		splitTheme: "b",
		corners: true,
		shadow: true,
		inset: false,
		initSelector: ":jqmData(role='listview')"
	},

	_create: function() {
		var t = this,
			listviewClasses = "";

		listviewClasses += t.options.inset ? " ui-listview-inset" : "";

		if ( !!t.options.inset ) {
			listviewClasses += t.options.corners ? " ui-corner-all" : "";
			listviewClasses += t.options.shadow ? " ui-shadow" : "";
		}

		// create listview markup
		t.element.addClass(function( i, orig ) {
			return orig + " ui-listview" + listviewClasses;
		});

		t.refresh( true );
	},

	// This is a generic utility method for finding the first
	// node with a given nodeName. It uses basic DOM traversal
	// to be fast and is meant to be a substitute for simple
	// $.fn.closest() and $.fn.children() calls on a single
	// element. Note that callers must pass both the lowerCase
	// and upperCase version of the nodeName they are looking for.
	// The main reason for this is that this function will be
	// called many times and we want to avoid having to lowercase
	// the nodeName from the element every time to ensure we have
	// a match. Note that this function lives here for now, but may
	// be moved into $.mobile if other components need a similar method.
	_findFirstElementByTagName: function( ele, nextProp, lcName, ucName ) {
		var dict = {};
		dict[ lcName ] = dict[ ucName ] = true;
		while ( ele ) {
			if ( dict[ ele.nodeName ] ) {
				return ele;
			}
			ele = ele[ nextProp ];
		}
		return null;
	},
	_getChildrenByTagName: function( ele, lcName, ucName ) {
		var results = [],
			dict = {};
		dict[ lcName ] = dict[ ucName ] = true;
		ele = ele.firstChild;
		while ( ele ) {
			if ( dict[ ele.nodeName ] ) {
				results.push( ele );
			}
			ele = ele.nextSibling;
		}
		return $( results );
	},

	_addThumbClasses: function( containers ) {
		var i, img, len = containers.length;
		for ( i = 0; i < len; i++ ) {
			img = $( this._findFirstElementByTagName( containers[ i ].firstChild, "nextSibling", "img", "IMG" ) );
			if ( img.length ) {
				img.addClass( "ui-li-thumb" );
				$( this._findFirstElementByTagName( img[ 0 ].parentNode, "parentNode", "li", "LI" ) ).addClass( img.is( ".ui-li-icon" ) ? "ui-li-has-icon" : "ui-li-has-thumb" );
			}
		}
	},

	refresh: function( create ) {
		this.parentPage = this.element.closest( ".ui-page" );
		this._createSubPages();

		var o = this.options,
			$list = this.element,
			self = this,
			dividertheme = $list.jqmData( "dividertheme" ) || o.dividerTheme,
			listsplittheme = $list.jqmData( "splittheme" ),
			listspliticon = $list.jqmData( "spliticon" ),
			listicon = $list.jqmData( "icon" ),
			li = this._getChildrenByTagName( $list[ 0 ], "li", "LI" ),
			ol = !!$.nodeName( $list[ 0 ], "ol" ),
			jsCount = !$.support.cssPseudoElement,
			start = $list.attr( "start" ),
			itemClassDict = {},
			item, itemClass, itemTheme,
			a, last, splittheme, counter, startCount, newStartCount, countParent, icon, imgParents, img, linkIcon;

		if ( ol && jsCount ) {
			$list.find( ".ui-li-dec" ).remove();
		}

		if ( ol ) {
			// Check if a start attribute has been set while taking a value of 0 into account
			if ( start || start === 0 ) {
				if ( !jsCount ) {
					startCount = parseInt( start , 10 ) - 1;
					$list.css( "counter-reset", "listnumbering " + startCount );
				} else {
					counter = parseInt( start , 10 );
				}
			} else if ( jsCount ) {
					counter = 1;
			}
		}

		if ( !o.theme ) {
			o.theme = $.mobile.getInheritedTheme( this.element, "c" );
		}

		for ( var pos = 0, numli = li.length; pos < numli; pos++ ) {
			item = li.eq( pos );
			itemClass = "ui-li";

			// If we're creating the element, we update it regardless
			if ( create || !item.hasClass( "ui-li" ) ) {
				itemTheme = item.jqmData( "theme" ) || o.theme;
				a = this._getChildrenByTagName( item[ 0 ], "a", "A" );
				var isDivider = ( item.jqmData( "role" ) === "list-divider" );

				if ( a.length && !isDivider ) {
					icon = item.jqmData( "icon" );

					item.buttonMarkup({
						wrapperEls: "div",
						shadow: false,
						corners: false,
						iconpos: "right",
						icon: a.length > 1 || icon === false ? false : icon || listicon || o.icon,
						theme: itemTheme
					});

					if ( ( icon !== false ) && ( a.length === 1 ) ) {
						item.addClass( "ui-li-has-arrow" );
					}

					a.first().removeClass( "ui-link" ).addClass( "ui-link-inherit" );

					if ( a.length > 1 ) {
						itemClass += " ui-li-has-alt";

						last = a.last();
						splittheme = listsplittheme || last.jqmData( "theme" ) || o.splitTheme;
						linkIcon = last.jqmData( "icon" );

						last.appendTo( item )
							.attr( "title", $.trim(last.getEncodedText()) )
							.addClass( "ui-li-link-alt" )
							.empty()
							.buttonMarkup({
								shadow: false,
								corners: false,
								theme: itemTheme,
								icon: false,
								iconpos: "notext"
							})
							.find( ".ui-btn-inner" )
								.append(
									$( document.createElement( "span" ) ).buttonMarkup({
										shadow: true,
										corners: true,
										theme: splittheme,
										iconpos: "notext",
										// link icon overrides list item icon overrides ul element overrides options
										icon: linkIcon || icon || listspliticon || o.splitIcon
									})
								);
					}
				} else if ( isDivider ) {

					itemClass += " ui-li-divider ui-bar-" + ( item.jqmData( "theme" ) || dividertheme );
					item.attr( "role", "heading" );

					if ( ol ) {
						//reset counter when a divider heading is encountered
						if ( start || start === 0 ) {
							if ( !jsCount ) {
								newStartCount = parseInt( start , 10 ) - 1;
								item.css( "counter-reset", "listnumbering " + newStartCount );
							} else {
								counter = parseInt( start , 10 );
							}
						} else if ( jsCount ) {
								counter = 1;
						}
					}

				} else {
					itemClass += " ui-li-static ui-btn-up-" + itemTheme;
				}
			}

			if ( ol && jsCount && itemClass.indexOf( "ui-li-divider" ) < 0 ) {
				countParent = itemClass.indexOf( "ui-li-static" ) > 0 ? item : item.find( ".ui-link-inherit" );

				countParent.addClass( "ui-li-jsnumbering" )
					.prepend( "<span class='ui-li-dec'>" + ( counter++ ) + ". </span>" );
			}

			// Instead of setting item class directly on the list item and its
			// btn-inner at this point in time, push the item into a dictionary
			// that tells us what class to set on it so we can do this after this
			// processing loop is finished.

			if ( !itemClassDict[ itemClass ] ) {
				itemClassDict[ itemClass ] = [];
			}

			itemClassDict[ itemClass ].push( item[ 0 ] );
		}

		// Set the appropriate listview item classes on each list item
		// and their btn-inner elements. The main reason we didn't do this
		// in the for-loop above is because we can eliminate per-item function overhead
		// by calling addClass() and children() once or twice afterwards. This
		// can give us a significant boost on platforms like WP7.5.

		for ( itemClass in itemClassDict ) {
			$( itemClassDict[ itemClass ] ).addClass( itemClass ).children( ".ui-btn-inner" ).addClass( itemClass );
		}

		$list.find( "h1, h2, h3, h4, h5, h6" ).addClass( "ui-li-heading" )
			.end()

			.find( "p, dl" ).addClass( "ui-li-desc" )
			.end()

			.find( ".ui-li-aside" ).each(function() {
					var $this = $( this );
					$this.prependTo( $this.parent() ); //shift aside to front for css float
				})
			.end()

			.find( ".ui-li-count" ).each(function() {
					$( this ).closest( "li" ).addClass( "ui-li-has-count" );
				}).addClass( "ui-btn-up-" + ( $list.jqmData( "counttheme" ) || this.options.countTheme) + " ui-btn-corner-all" );

		// The idea here is to look at the first image in the list item
		// itself, and any .ui-link-inherit element it may contain, so we
		// can place the appropriate classes on the image and list item.
		// Note that we used to use something like:
		//
		//    li.find(">img:eq(0), .ui-link-inherit>img:eq(0)").each( ... );
		//
		// But executing a find() like that on Windows Phone 7.5 took a
		// really long time. Walking things manually with the code below
		// allows the 400 listview item page to load in about 3 seconds as
		// opposed to 30 seconds.

		this._addThumbClasses( li );
		this._addThumbClasses( $list.find( ".ui-link-inherit" ) );

		this._addFirstLastClasses( li, this._getVisibles( li, create ), create );
		// autodividers binds to this to redraw dividers after the listview refresh
		this._trigger( "afterrefresh" );
	},

	//create a string for ID/subpage url creation
	_idStringEscape: function( str ) {
		return str.replace(/[^a-zA-Z0-9]/g, '-');
	},

	_createSubPages: function() {
		var parentList = this.element,
			parentPage = parentList.closest( ".ui-page" ),
			parentUrl = parentPage.jqmData( "url" ),
			parentId = parentUrl || parentPage[ 0 ][ $.expando ],
			parentListId = parentList.attr( "id" ),
			o = this.options,
			dns = "data-" + $.mobile.ns,
			self = this,
			persistentFooterID = parentPage.find( ":jqmData(role='footer')" ).jqmData( "id" ),
			hasSubPages;

		if ( typeof listCountPerPage[ parentId ] === "undefined" ) {
			listCountPerPage[ parentId ] = -1;
		}

		parentListId = parentListId || ++listCountPerPage[ parentId ];

		$( parentList.find( "li>ul, li>ol" ).toArray().reverse() ).each(function( i ) {
			var self = this,
				list = $( this ),
				listId = list.attr( "id" ) || parentListId + "-" + i,
				parent = list.parent(),
				nodeElsFull = $( list.prevAll().toArray().reverse() ),
				nodeEls = nodeElsFull.length ? nodeElsFull : $( "<span>" + $.trim(parent.contents()[ 0 ].nodeValue) + "</span>" ),
				title = nodeEls.first().getEncodedText(),//url limits to first 30 chars of text
				id = ( parentUrl || "" ) + "&" + $.mobile.subPageUrlKey + "=" + listId,
				theme = list.jqmData( "theme" ) || o.theme,
				countTheme = list.jqmData( "counttheme" ) || parentList.jqmData( "counttheme" ) || o.countTheme,
				newPage, anchor;

			//define hasSubPages for use in later removal
			hasSubPages = true;

			newPage = list.detach()
						.wrap( "<div " + dns + "role='page' " + dns + "url='" + id + "' " + dns + "theme='" + theme + "' " + dns + "count-theme='" + countTheme + "'><div " + dns + "role='content'></div></div>" )
						.parent()
							.before( "<div " + dns + "role='header' " + dns + "theme='" + o.headerTheme + "'><div class='ui-title'>" + title + "</div></div>" )
							.after( persistentFooterID ? $( "<div " + dns + "role='footer' " + dns + "id='"+ persistentFooterID +"'>" ) : "" )
							.parent()
								.appendTo( $.mobile.pageContainer );

			newPage.page();

			anchor = parent.find( 'a:first' );

			if ( !anchor.length ) {
				anchor = $( "<a/>" ).html( nodeEls || title ).prependTo( parent.empty() );
			}

			anchor.attr( "href", "#" + id );

		}).listview();

		// on pagehide, remove any nested pages along with the parent page, as long as they aren't active
		// and aren't embedded
		if ( hasSubPages &&
			parentPage.is( ":jqmData(external-page='true')" ) &&
			parentPage.data( "mobile-page" ).options.domCache === false ) {

			var newRemove = function( e, ui ) {
				var nextPage = ui.nextPage, npURL,
					prEvent = new $.Event( "pageremove" );

				if ( ui.nextPage ) {
					npURL = nextPage.jqmData( "url" );
					if ( npURL.indexOf( parentUrl + "&" + $.mobile.subPageUrlKey ) !== 0 ) {
						self.childPages().remove();
						parentPage.trigger( prEvent );
						if ( !prEvent.isDefaultPrevented() ) {
							parentPage.removeWithDependents();
						}
					}
				}
			};

			// unbind the original page remove and replace with our specialized version
			parentPage
				.unbind( "pagehide.remove" )
				.bind( "pagehide.remove", newRemove);
		}
	},

	// TODO sort out a better way to track sub pages of the listview this is brittle
	childPages: function() {
		var parentUrl = this.parentPage.jqmData( "url" );

		return $( ":jqmData(url^='"+  parentUrl + "&" + $.mobile.subPageUrlKey + "')" );
	}
}, $.mobile.behaviors.addFirstLastClasses ) );

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.listview.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $ ) {
	var	meta = $( "meta[name=viewport]" ),
		initialContent = meta.attr( "content" ),
		disabledZoom = initialContent + ",maximum-scale=1, user-scalable=no",
		enabledZoom = initialContent + ",maximum-scale=10, user-scalable=yes",
		disabledInitially = /(user-scalable[\s]*=[\s]*no)|(maximum-scale[\s]*=[\s]*1)[$,\s]/.test( initialContent );

	$.mobile.zoom = $.extend( {}, {
		enabled: !disabledInitially,
		locked: false,
		disable: function( lock ) {
			if ( !disabledInitially && !$.mobile.zoom.locked ) {
				meta.attr( "content", disabledZoom );
				$.mobile.zoom.enabled = false;
				$.mobile.zoom.locked = lock || false;
			}
		},
		enable: function( unlock ) {
			if ( !disabledInitially && ( !$.mobile.zoom.locked || unlock === true ) ) {
				meta.attr( "content", enabledZoom );
				$.mobile.zoom.enabled = true;
				$.mobile.zoom.locked = false;
			}
		},
		restore: function() {
			if ( !disabledInitially ) {
				meta.attr( "content", initialContent );
				$.mobile.zoom.enabled = true;
			}
		}
	});

}( jQuery ));

(function( $, undefined ) {

$.widget( "mobile.textinput", $.mobile.widget, {
	options: {
		theme: null,
		mini: false,
		// This option defaults to true on iOS devices.
		preventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( "AppleWebKit" ) > -1,
		initSelector: "input[type='text'], input[type='search'], :jqmData(type='search'), input[type='number'], :jqmData(type='number'), input[type='password'], input[type='email'], input[type='url'], input[type='tel'], textarea, input[type='time'], input[type='date'], input[type='month'], input[type='week'], input[type='datetime'], input[type='datetime-local'], input[type='color'], input:not([type]), input[type='file']",
		clearBtn: false,
		clearSearchButtonText: null, //deprecating for 1.3...
		clearBtnText: "clear text",
		disabled: false
	},

	_create: function() {

		var self = this,
			input = this.element,
			o = this.options,
			theme = o.theme || $.mobile.getInheritedTheme( this.element, "c" ),
			themeclass  = " ui-body-" + theme,
			miniclass = o.mini ? " ui-mini" : "",
			isSearch = input.is( "[type='search'], :jqmData(type='search')" ),
			focusedEl,
			clearbtn,
			clearBtnText = o.clearSearchButtonText || o.clearBtnText,
			clearBtnBlacklist = input.is( "textarea, :jqmData(type='range')" ),
			inputNeedsClearBtn = !!o.clearBtn && !clearBtnBlacklist,
			inputNeedsWrap = input.is( "input" ) && !input.is( ":jqmData(type='range')" );

		function toggleClear() {
			setTimeout( function() {
				clearbtn.toggleClass( "ui-input-clear-hidden", !input.val() );
			}, 0 );
		}

		$( "label[for='" + input.attr( "id" ) + "']" ).addClass( "ui-input-text" );

		focusedEl = input.addClass( "ui-input-text ui-body-"+ theme );

		// XXX: Temporary workaround for issue 785 (Apple bug 8910589).
		//      Turn off autocorrect and autocomplete on non-iOS 5 devices
		//      since the popup they use can't be dismissed by the user. Note
		//      that we test for the presence of the feature by looking for
		//      the autocorrect property on the input element. We currently
		//      have no test for iOS 5 or newer so we're temporarily using
		//      the touchOverflow support flag for jQM 1.0. Yes, I feel dirty. - jblas
		if ( typeof input[0].autocorrect !== "undefined" && !$.support.touchOverflow ) {
			// Set the attribute instead of the property just in case there
			// is code that attempts to make modifications via HTML.
			input[0].setAttribute( "autocorrect", "off" );
			input[0].setAttribute( "autocomplete", "off" );
		}

		//"search" and "text" input widgets
		if ( isSearch ) {
			focusedEl = input.wrap( "<div class='ui-input-search ui-shadow-inset ui-btn-corner-all ui-btn-shadow ui-icon-searchfield" + themeclass + miniclass + "'></div>" ).parent();
		} else if ( inputNeedsWrap ) {
			focusedEl = input.wrap( "<div class='ui-input-text ui-shadow-inset ui-corner-all ui-btn-shadow" + themeclass + miniclass + "'></div>" ).parent();
		}

		if( inputNeedsClearBtn || isSearch ) {
			clearbtn = $( "<a href='#' class='ui-input-clear' title='" + clearBtnText + "'>" + clearBtnText + "</a>" )
				.bind( "click", function( event ) {
					input
						.val( "" )
						.focus()
						.trigger( "change" );
					clearbtn.addClass( "ui-input-clear-hidden" );
					event.preventDefault();
				})
				.appendTo( focusedEl )
				.buttonMarkup({
					icon: "delete",
					iconpos: "notext",
					corners: true,
					shadow: true,
					mini: o.mini
				});
				
			if ( !isSearch ) {
				focusedEl.addClass( "ui-input-has-clear" );
			}

			toggleClear();

			input.bind( "paste cut keyup input focus change blur", toggleClear );
		}
		else if ( !inputNeedsWrap && !isSearch ) {
			input.addClass( "ui-corner-all ui-shadow-inset" + themeclass + miniclass );
		}

		input.focus(function() {
				// In many situations, iOS will zoom into the input upon tap, this prevents that from happening
				if ( o.preventFocusZoom ) {
					$.mobile.zoom.disable( true );
				}			
				focusedEl.addClass( $.mobile.focusClass );
			})
			.blur(function() {
				focusedEl.removeClass( $.mobile.focusClass );
				if ( o.preventFocusZoom ) {
					$.mobile.zoom.enable( true );
				}				
			});

		// Autogrow
		if ( input.is( "textarea" ) ) {
			var extraLineHeight = 15,
				keyupTimeoutBuffer = 100,
				keyupTimeout;

			this._keyup = function() {
				var scrollHeight = input[ 0 ].scrollHeight,
					clientHeight = input[ 0 ].clientHeight;

				if ( clientHeight < scrollHeight ) {
					var paddingTop = parseFloat( input.css( "padding-top" ) ),
						paddingBottom = parseFloat( input.css( "padding-bottom" ) ),
						paddingHeight = paddingTop + paddingBottom;
					
					input.height( scrollHeight - paddingHeight + extraLineHeight );
				}
			};

			input.on( "keyup change input paste", function() {
				clearTimeout( keyupTimeout );
				keyupTimeout = setTimeout( self._keyup, keyupTimeoutBuffer );
			});

			// binding to pagechange here ensures that for pages loaded via
			// ajax the height is recalculated without user input
			this._on( true, $.mobile.document, { "pagechange": "_keyup" });

			// Issue 509: the browser is not providing scrollHeight properly until the styles load
			if ( $.trim( input.val() ) ) {
				// bind to the window load to make sure the height is calculated based on BOTH
				// the DOM and CSS
				this._on( true, $.mobile.window, {"load": "_keyup"});
			}
		}
		if ( input.attr( "disabled" ) ) {
			this.disable();
		}
	},

	disable: function() {
		var $el,
			isSearch = this.element.is( "[type='search'], :jqmData(type='search')" ),
			inputNeedsWrap = this.element.is( "input" ) && !this.element.is( ":jqmData(type='range')" ),
			parentNeedsDisabled = this.element.attr( "disabled", true )	&& ( inputNeedsWrap || isSearch );
			
		if ( parentNeedsDisabled ) {
			$el = this.element.parent();
		} else {
			$el = this.element;
		}
		$el.addClass( "ui-disabled" );
		return this._setOption( "disabled", true );
	},

	enable: function() {
		var $el,
			isSearch = this.element.is( "[type='search'], :jqmData(type='search')" ),
			inputNeedsWrap = this.element.is( "input" ) && !this.element.is( ":jqmData(type='range')" ),
			parentNeedsEnabled = this.element.attr( "disabled", false )	&& ( inputNeedsWrap || isSearch );

		if ( parentNeedsEnabled ) {
			$el = this.element.parent();
		} else {
			$el = this.element;
		}
		$el.removeClass( "ui-disabled" );
		return this._setOption( "disabled", false );
	}
});

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.textinput.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.mobile.listview.prototype.options.filter = false;
$.mobile.listview.prototype.options.filterPlaceholder = "Filter items...";
$.mobile.listview.prototype.options.filterTheme = "c";
$.mobile.listview.prototype.options.filterReveal = false;
// TODO rename callback/deprecate and default to the item itself as the first argument
var defaultFilterCallback = function( text, searchValue, item ) {
		return text.toString().toLowerCase().indexOf( searchValue ) === -1;
	};

$.mobile.listview.prototype.options.filterCallback = defaultFilterCallback;

$.mobile.document.delegate( "ul, ol", "listviewcreate", function() {
	var list = $( this ),
		listview = list.data( "mobile-listview" );

	if ( !listview || !listview.options.filter ) {
		return;
	}

	if ( listview.options.filterReveal ) {
		list.children().addClass( "ui-screen-hidden" );
	}

	var wrapper = $( "<form>", {
			"class": "ui-listview-filter ui-bar-" + listview.options.filterTheme,
			"role": "search"
		}).submit( function( e ) {
			e.preventDefault();
			search.blur();
		}),
		onKeyUp = function( e ) {
			var $this = $( this ),
				val = this.value.toLowerCase(),
				listItems = null,
				li = list.children(),
				lastval = $this.jqmData( "lastval" ) + "",
				childItems = false,
				itemtext = "",
				item,
				// Check if a custom filter callback applies
				isCustomFilterCallback = listview.options.filterCallback !== defaultFilterCallback;

			if ( lastval && lastval === val ) {
				// Execute the handler only once per value change
				return;
			}

			listview._trigger( "beforefilter", "beforefilter", { input: this } );

			// Change val as lastval for next execution
			$this.jqmData( "lastval" , val );
			if ( isCustomFilterCallback || val.length < lastval.length || val.indexOf( lastval ) !== 0 ) {

				// Custom filter callback applies or removed chars or pasted something totally different, check all items
				listItems = list.children();
			} else {

				// Only chars added, not removed, only use visible subset
				listItems = list.children( ":not(.ui-screen-hidden)" );

				if ( !listItems.length && listview.options.filterReveal ) {
					listItems = list.children( ".ui-screen-hidden" );
				}
			}

			if ( val ) {

				// This handles hiding regular rows without the text we search for
				// and any list dividers without regular rows shown under it

				for ( var i = listItems.length - 1; i >= 0; i-- ) {
					item = $( listItems[ i ] );
					itemtext = item.jqmData( "filtertext" ) || item.text();

					if ( item.is( "li:jqmData(role=list-divider)" ) ) {

						item.toggleClass( "ui-filter-hidequeue" , !childItems );

						// New bucket!
						childItems = false;

					} else if ( listview.options.filterCallback( itemtext, val, item ) ) {

						//mark to be hidden
						item.toggleClass( "ui-filter-hidequeue" , true );
					} else {

						// There's a shown item in the bucket
						childItems = true;
					}
				}

				// Show items, not marked to be hidden
				listItems
					.filter( ":not(.ui-filter-hidequeue)" )
					.toggleClass( "ui-screen-hidden", false );

				// Hide items, marked to be hidden
				listItems
					.filter( ".ui-filter-hidequeue" )
					.toggleClass( "ui-screen-hidden", true )
					.toggleClass( "ui-filter-hidequeue", false );

			} else {

				//filtervalue is empty => show all
				listItems.toggleClass( "ui-screen-hidden", !!listview.options.filterReveal );
			}
			listview._addFirstLastClasses( li, listview._getVisibles( li, false ), false );
		},
		search = $( "<input>", {
			placeholder: listview.options.filterPlaceholder
		})
		.attr( "data-" + $.mobile.ns + "type", "search" )
		.jqmData( "lastval", "" )
		.bind( "keyup change input", onKeyUp )
		.appendTo( wrapper )
		.textinput();

	if ( listview.options.inset ) {
		wrapper.addClass( "ui-listview-filter-inset" );
	}

	wrapper.bind( "submit", function() {
		return false;
	})
	.insertBefore( list );
});

})( jQuery );

(function( $, undefined ) {

$.mobile.listview.prototype.options.autodividers = false;
$.mobile.listview.prototype.options.autodividersSelector = function( elt ) {
	// look for the text in the given element
	var text = $.trim( elt.text() ) || null;

	if ( !text ) {
		return null;
	}

	// create the text for the divider (first uppercased letter)
	text = text.slice( 0, 1 ).toUpperCase();

	return text;
};

$.mobile.document.delegate( "ul,ol", "listviewcreate", function() {

	var list = $( this ),
			listview = list.data( "mobile-listview" );

	if ( !listview || !listview.options.autodividers ) {
		return;
	}

	var replaceDividers = function () {
		list.find( "li:jqmData(role='list-divider')" ).remove();

		var lis = list.find( 'li' ),
			lastDividerText = null, li, dividerText;

		for ( var i = 0; i < lis.length ; i++ ) {
			li = lis[i];
			dividerText = listview.options.autodividersSelector( $( li ) );

			if ( dividerText && lastDividerText !== dividerText ) {
				var divider = document.createElement( 'li' );
				divider.appendChild( document.createTextNode( dividerText ) );
				divider.setAttribute( 'data-' + $.mobile.ns + 'role', 'list-divider' );
				li.parentNode.insertBefore( divider, li );
			}

			lastDividerText = dividerText;
		}
	};

	var afterListviewRefresh = function () {
		list.unbind( 'listviewafterrefresh', afterListviewRefresh );
		replaceDividers();
		listview.refresh();
		list.bind( 'listviewafterrefresh', afterListviewRefresh );
	};

	afterListviewRefresh();
});

})( jQuery );

(function( $, undefined ) {

$( document ).bind( "pagecreate create", function( e ) {
	$( ":jqmData(role='nojs')", e.target ).addClass( "ui-nojs" );
	
});

})( jQuery );

(function( $, undefined ) {

$.mobile.behaviors.formReset = {
	_handleFormReset: function() {
		this._on( this.element.closest( "form" ), {
			reset: function() {
				this._delay( "_reset" );
			}
		});
	}
};

})( jQuery );

/*
* "checkboxradio" plugin
*/

(function( $, undefined ) {

$.widget( "mobile.checkboxradio", $.mobile.widget, $.extend( {
	options: {
		theme: null,
		mini: false,
		initSelector: "input[type='checkbox'],input[type='radio']"
	},
	_create: function() {
		var self = this,
			input = this.element,
			o = this.options,
			inheritAttr = function( input, dataAttr ) {
				return input.jqmData( dataAttr ) || input.closest( "form, fieldset" ).jqmData( dataAttr );
			},
			// NOTE: Windows Phone could not find the label through a selector
			// filter works though.
			parentLabel = $( input ).closest( "label" ),
			label = parentLabel.length ? parentLabel : $( input ).closest( "form, fieldset, :jqmData(role='page'), :jqmData(role='dialog')" ).find( "label" ).filter( "[for='" + input[0].id + "']" ).first(),
			inputtype = input[0].type,
			mini = inheritAttr( input, "mini" ) || o.mini,
			checkedState = inputtype + "-on",
			uncheckedState = inputtype + "-off",
			iconpos = inheritAttr( input, "iconpos" ),
			checkedClass = "ui-" + checkedState,
			uncheckedClass = "ui-" + uncheckedState;

		if ( inputtype !== "checkbox" && inputtype !== "radio" ) {
			return;
		}

		// Expose for other methods
		$.extend( this, {
			label: label,
			inputtype: inputtype,
			checkedClass: checkedClass,
			uncheckedClass: uncheckedClass,
			checkedicon: checkedState,
			uncheckedicon: uncheckedState
		});

		// If there's no selected theme check the data attr
		if ( !o.theme ) {
			o.theme = $.mobile.getInheritedTheme( this.element, "c" );
		}

		label.buttonMarkup({
			theme: o.theme,
			icon: uncheckedState,
			shadow: false,
			mini: mini,
			iconpos: iconpos
		});

		// Wrap the input + label in a div
		var wrapper = document.createElement('div');
		wrapper.className = 'ui-' + inputtype;

		input.add( label ).wrapAll( wrapper );

		label.bind({
			vmouseover: function( event ) {
				if ( $( this ).parent().is( ".ui-disabled" ) ) {
					event.stopPropagation();
				}
			},

			vclick: function( event ) {
				if ( input.is( ":disabled" ) ) {
					event.preventDefault();
					return;
				}

				self._cacheVals();

				input.prop( "checked", inputtype === "radio" && true || !input.prop( "checked" ) );

				// trigger click handler's bound directly to the input as a substitute for
				// how label clicks behave normally in the browsers
				// TODO: it would be nice to let the browser's handle the clicks and pass them
				//       through to the associate input. we can swallow that click at the parent
				//       wrapper element level
				input.triggerHandler( 'click' );

				// Input set for common radio buttons will contain all the radio
				// buttons, but will not for checkboxes. clearing the checked status
				// of other radios ensures the active button state is applied properly
				self._getInputSet().not( input ).prop( "checked", false );

				self._updateAll();
				return false;
			}
		});

		input
			.bind({
				vmousedown: function() {
					self._cacheVals();
				},

				vclick: function() {
					var $this = $( this );

					// Adds checked attribute to checked input when keyboard is used
					if ( $this.is( ":checked" ) ) {

						$this.prop( "checked", true);
						self._getInputSet().not( $this ).prop( "checked", false );
					} else {

						$this.prop( "checked", false );
					}

					self._updateAll();
				},

				focus: function() {
					label.addClass( $.mobile.focusClass );
				},

				blur: function() {
					label.removeClass( $.mobile.focusClass );
				}
			});

		this._handleFormReset();
		this.refresh();
	},

	_cacheVals: function() {
		this._getInputSet().each(function() {
			$( this ).jqmData( "cacheVal", this.checked );
		});
	},

	//returns either a set of radios with the same name attribute, or a single checkbox
	_getInputSet: function() {
		if ( this.inputtype === "checkbox" ) {
			return this.element;
		}

		return this.element.closest( "form, :jqmData(role='page'), :jqmData(role='dialog')" )
			.find( "input[name='" + this.element[0].name + "'][type='" + this.inputtype + "']" );
	},

	_updateAll: function() {
		var self = this;

		this._getInputSet().each(function() {
			var $this = $( this );

			if ( this.checked || self.inputtype === "checkbox" ) {
				$this.trigger( "change" );
			}
		})
		.checkboxradio( "refresh" );
	},

	_reset: function() {
		this.refresh();
	},

	refresh: function() {
		var input = this.element[ 0 ],
			active = " " + $.mobile.activeBtnClass,
			checkedClass = this.checkedClass + ( this.element.parents( ".ui-controlgroup-horizontal" ).length ? active : "" ),
			label = this.label;

		if ( input.checked ) {
			label.removeClass( this.uncheckedClass + active ).addClass( checkedClass ).buttonMarkup( { icon: this.checkedicon } );
		} else {
			label.removeClass( checkedClass ).addClass( this.uncheckedClass ).buttonMarkup( { icon: this.uncheckedicon } );
		}

		if ( input.disabled ) {
			this.disable();
		} else {
			this.enable();
		}
	},

	disable: function() {
		this.element.prop( "disabled", true ).parent().addClass( "ui-disabled" );
	},

	enable: function() {
		this.element.prop( "disabled", false ).parent().removeClass( "ui-disabled" );
	}
}, $.mobile.behaviors.formReset ) );

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.checkboxradio.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.button", $.mobile.widget, {
	options: {
		theme: null,
		icon: null,
		iconpos: null,
		corners: true,
		shadow: true,
		iconshadow: true,
		inline: null,
		mini: null,
		initSelector: "button, [type='button'], [type='submit'], [type='reset']"
	},
	_create: function() {
		var $el = this.element,
			$button,
			// create a copy of this.options we can pass to buttonMarkup
			o = ( function( tdo ) {
				var key, ret = {};

				for ( key in tdo ) {
					if ( tdo[ key ] !== null && key !== "initSelector" ) {
						ret[ key ] = tdo[ key ];
					}
				}

				return ret;
			} )( this.options ),
			classes = "",
			$buttonPlaceholder;

		// if this is a link, check if it's been enhanced and, if not, use the right function
		if ( $el[ 0 ].tagName === "A" ) {
			if ( !$el.hasClass( "ui-btn" ) ) {
				$el.buttonMarkup();
			}
			return;
		}

		// get the inherited theme
		// TODO centralize for all widgets
		if ( !this.options.theme ) {
			this.options.theme = $.mobile.getInheritedTheme( this.element, "c" );
		}

		// TODO: Post 1.1--once we have time to test thoroughly--any classes manually applied to the original element should be carried over to the enhanced element, with an `-enhanced` suffix. See https://github.com/jquery/jquery-mobile/issues/3577
		/* if ( $el[0].className.length ) {
			classes = $el[0].className;
		} */
		if ( !!~$el[0].className.indexOf( "ui-btn-left" ) ) {
			classes = "ui-btn-left";
		}

		if (  !!~$el[0].className.indexOf( "ui-btn-right" ) ) {
			classes = "ui-btn-right";
		}

		if (  $el.attr( "type" ) === "submit" || $el.attr( "type" ) === "reset" ) {
			if ( classes ) {
				classes += " ui-submit";
			} else {
				classes = "ui-submit";
			}
		}
		$( "label[for='" + $el.attr( "id" ) + "']" ).addClass( "ui-submit" );

		// Add ARIA role
		this.button = $( "<div></div>" )
			[ $el.html() ? "html" : "text" ]( $el.html() || $el.val() )
			.insertBefore( $el )
			.buttonMarkup( o )
			.addClass( classes )
			.append( $el.addClass( "ui-btn-hidden" ) );

        $button = this.button;

		$el.bind({
			focus: function() {
				$button.addClass( $.mobile.focusClass );
			},

			blur: function() {
				$button.removeClass( $.mobile.focusClass );
			}
		});

		this.refresh();
	},

	_setOption: function( key, value ) {
		var op = {};

		op[ key ] = value;
		if ( key !== "initSelector" ) {
			this.button.buttonMarkup( op );
			// Record the option change in the options and in the DOM data-* attributes
			this.element.attr( "data-" + ( $.mobile.ns || "" ) + ( key.replace( /([A-Z])/, "-$1" ).toLowerCase() ), value );
		}
		this._super( "_setOption", key, value );
	},

	enable: function() {
		this.element.attr( "disabled", false );
		this.button.removeClass( "ui-disabled" ).attr( "aria-disabled", false );
		return this._setOption( "disabled", false );
	},

	disable: function() {
		this.element.attr( "disabled", true );
		this.button.addClass( "ui-disabled" ).attr( "aria-disabled", true );
		return this._setOption( "disabled", true );
	},

	refresh: function() {
		var $el = this.element;

		if ( $el.prop("disabled") ) {
			this.disable();
		} else {
			this.enable();
		}

		// Grab the button's text element from its implementation-independent data item
		$( this.button.data( 'buttonElements' ).text )[ $el.html() ? "html" : "text" ]( $el.html() || $el.val() );
	}
});

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.button.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.slider", $.mobile.widget, $.extend( {
	widgetEventPrefix: "slide",

	options: {
		theme: null,
		trackTheme: null,
		disabled: false,
		initSelector: "input[type='range'], :jqmData(type='range'), :jqmData(role='slider')",
		mini: false,
		highlight: false
	},

	_create: function() {

		// TODO: Each of these should have comments explain what they're for
		var self = this,
			control = this.element,
			parentTheme = $.mobile.getInheritedTheme( control, "c" ),
			theme = this.options.theme || parentTheme,
			trackTheme = this.options.trackTheme || parentTheme,
			cType = control[ 0 ].nodeName.toLowerCase(),
			isSelect = this.isToggleSwitch = cType === "select",
			isRangeslider = control.parent().is( ":jqmData(role='rangeslider')" ),
			selectClass = ( this.isToggleSwitch ) ? "ui-slider-switch" : "",
			controlID = control.attr( "id" ),
			$label = $( "[for='" + controlID + "']" ),
			labelID = $label.attr( "id" ) || controlID + "-label",
			label = $label.attr( "id", labelID ),
			min = !this.isToggleSwitch ? parseFloat( control.attr( "min" ) ) : 0,
			max =  !this.isToggleSwitch ? parseFloat( control.attr( "max" ) ) : control.find( "option" ).length-1,
			step = window.parseFloat( control.attr( "step" ) || 1 ),
			miniClass = ( this.options.mini || control.jqmData( "mini" ) ) ? " ui-mini" : "",
			domHandle = document.createElement( "a" ),
			handle = $( domHandle ),
			domSlider = document.createElement( "div" ),
			slider = $( domSlider ),
			valuebg = this.options.highlight && !this.isToggleSwitch ? (function() {
				var bg = document.createElement( "div" );
				bg.className = "ui-slider-bg " + $.mobile.activeBtnClass + " ui-btn-corner-all";
				return $( bg ).prependTo( slider );
			})() : false,
			options,
			wrapper;
			
		domHandle.setAttribute( "href", "#" );
		domSlider.setAttribute( "role", "application" );
		domSlider.className = [this.isToggleSwitch ? "ui-slider " : "ui-slider-track ",selectClass," ui-btn-down-",trackTheme," ui-btn-corner-all", miniClass].join( "" );
		domHandle.className = "ui-slider-handle";
		domSlider.appendChild( domHandle );

		handle.buttonMarkup({ corners: true, theme: theme, shadow: true })
				.attr({
					"role": "slider",
					"aria-valuemin": min,
					"aria-valuemax": max,
					"aria-valuenow": this._value(),
					"aria-valuetext": this._value(),
					"title": this._value(),
					"aria-labelledby": labelID
				});

		$.extend( this, {
			slider: slider,
			handle: handle,
			type: cType,
			step: step,
			max: max,
			min: min,
			valuebg: valuebg,
			isRangeslider: isRangeslider,
			dragging: false,
			beforeStart: null,
			userModified: false,
			mouseMoved: false
		});

		if ( this.isToggleSwitch ) {
			wrapper = document.createElement( "div" );
			wrapper.className = "ui-slider-inneroffset";

			for ( var j = 0, length = domSlider.childNodes.length; j < length; j++ ) {
				wrapper.appendChild( domSlider.childNodes[j] );
			}

			domSlider.appendChild( wrapper );

			// slider.wrapInner( "<div class='ui-slider-inneroffset'></div>" );

			// make the handle move with a smooth transition
			handle.addClass( "ui-slider-handle-snapping" );

			options = control.find( "option" );

			for ( var i = 0, optionsCount = options.length; i < optionsCount; i++ ) {
				var side = !i ? "b" : "a",
					sliderTheme = !i ? " ui-btn-down-" + trackTheme : ( " " + $.mobile.activeBtnClass ),
					sliderLabel = document.createElement( "div" ),
					sliderImg = document.createElement( "span" );

				sliderImg.className = ["ui-slider-label ui-slider-label-", side, sliderTheme, " ui-btn-corner-all"].join( "" );
				sliderImg.setAttribute( "role", "img" );
				sliderImg.appendChild( document.createTextNode( options[i].innerHTML ) );
				$( sliderImg ).prependTo( slider );
			}

			self._labels = $( ".ui-slider-label", slider );

		}

		label.addClass( "ui-slider" );
		
		// monitor the input for updated values
		control.addClass( this.isToggleSwitch ? "ui-slider-switch" : "ui-slider-input" );

		this._on( control, {
			"change": "_controlChange",
			"keyup": "_controlKeyup",
			"blur": "_controlBlur",
			"vmouseup": "_controlVMouseUp"
		});

		slider.bind( "vmousedown", $.proxy( this._sliderVMouseDown, this ) )
			.bind( "vclick", false );

		// We have to instantiate a new function object for the unbind to work properly
		// since the method itself is defined in the prototype (causing it to unbind everything)
		this._on( document, { "vmousemove": "_preventDocumentDrag" });
		this._on( slider.add( document ), { "vmouseup": "_sliderVMouseUp" });

		slider.insertAfter( control );

		// wrap in a div for styling purposes
		if ( !this.isToggleSwitch && !isRangeslider ) {
			wrapper = this.options.mini ? "<div class='ui-slider ui-mini'>" : "<div class='ui-slider'>";
			
			control.add( slider ).wrapAll( wrapper );
		}

		// Only add focus class to toggle switch, sliders get it automatically from ui-btn
		if ( this.isToggleSwitch ) {
			this.handle.bind({
				focus: function() {
					slider.addClass( $.mobile.focusClass );
				},

				blur: function() {
					slider.removeClass( $.mobile.focusClass );
				}
			});
		}

		// bind the handle event callbacks and set the context to the widget instance
		this._on( this.handle, {
			"vmousedown": "_handleVMouseDown",
			"keydown": "_handleKeydown",
			"keyup": "_handleKeyup"
		});

		this.handle.bind( "vclick", false );

		this._handleFormReset();

		this.refresh( undefined, undefined, true );
	},

	_controlChange: function( event ) {
		// if the user dragged the handle, the "change" event was triggered from inside refresh(); don't call refresh() again
		if ( this._trigger( "controlchange", event ) === false ) {
			return false;
		}
		if ( !this.mouseMoved ) {
			this.refresh( this._value(), true );
		}
	},

	_controlKeyup: function( event ) { // necessary?
		this.refresh( this._value(), true, true );
	},

	_controlBlur: function( event ) {
		this.refresh( this._value(), true );
	},

	// it appears the clicking the up and down buttons in chrome on
	// range/number inputs doesn't trigger a change until the field is
	// blurred. Here we check thif the value has changed and refresh
	_controlVMouseUp: function( event ) {
		this._checkedRefresh();
	},

	// NOTE force focus on handle
	_handleVMouseDown: function( event ) {
		this.handle.focus();
	},

	_handleKeydown: function( event ) {
		var index = this._value();
		if ( this.options.disabled ) {
			return;
		}

		// In all cases prevent the default and mark the handle as active
		switch ( event.keyCode ) {
			case $.mobile.keyCode.HOME:
			case $.mobile.keyCode.END:
			case $.mobile.keyCode.PAGE_UP:
			case $.mobile.keyCode.PAGE_DOWN:
			case $.mobile.keyCode.UP:
			case $.mobile.keyCode.RIGHT:
			case $.mobile.keyCode.DOWN:
			case $.mobile.keyCode.LEFT:
				event.preventDefault();

				if ( !this._keySliding ) {
					this._keySliding = true;
					this.handle.addClass( "ui-state-active" );
				}

				break;
		}

		// move the slider according to the keypress
		switch ( event.keyCode ) {
			case $.mobile.keyCode.HOME:
				this.refresh( this.min );
				break;
			case $.mobile.keyCode.END:
				this.refresh( this.max );
				break;
			case $.mobile.keyCode.PAGE_UP:
			case $.mobile.keyCode.UP:
			case $.mobile.keyCode.RIGHT:
				this.refresh( index + this.step );
				break;
			case $.mobile.keyCode.PAGE_DOWN:
			case $.mobile.keyCode.DOWN:
			case $.mobile.keyCode.LEFT:
				this.refresh( index - this.step );
				break;
		}
	}, // remove active mark

	_handleKeyup: function( event ) {
		if ( this._keySliding ) {
			this._keySliding = false;
			this.handle.removeClass( "ui-state-active" );
		}
	},

	_sliderVMouseDown: function( event ) {
		// NOTE: we don't do this in refresh because we still want to
		//       support programmatic alteration of disabled inputs
		if ( this.options.disabled || !( event.which === 1 || event.which === 0 ) ) {
			return false;
		}
		if ( this._trigger( "beforestart", event ) === false ) {
			return false;
		}
		this.dragging = true;
		this.userModified = false;
		this.mouseMoved = false;

		if ( this.isToggleSwitch ) {
			this.beforeStart = this.element[0].selectedIndex;
		}

		
		this.refresh( event );
		this._trigger( "start" );
		return false;
	},

	_sliderVMouseUp: function() {
		if ( this.dragging ) {
			this.dragging = false;

			if ( this.isToggleSwitch ) {
				// make the handle move with a smooth transition
				this.handle.addClass( "ui-slider-handle-snapping" );

				if ( this.mouseMoved ) {
					// this is a drag, change the value only if user dragged enough
					if ( this.userModified ) {
						this.refresh( this.beforeStart === 0 ? 1 : 0 );
					} else {
						this.refresh( this.beforeStart );
					}
				} else {
					// this is just a click, change the value
					this.refresh( this.beforeStart === 0 ? 1 : 0 );
				}
			}

			this.mouseMoved = false;
			this._trigger( "stop" );
			return false;
		}
	},

	_preventDocumentDrag: function( event ) {
			// NOTE: we don't do this in refresh because we still want to
			//       support programmatic alteration of disabled inputs
			if ( this._trigger( "drag", event ) === false) {
				return false;
			}
			if ( this.dragging && !this.options.disabled ) {
				
				// this.mouseMoved must be updated before refresh() because it will be used in the control "change" event
				this.mouseMoved = true;

				if ( this.isToggleSwitch ) {
					// make the handle move in sync with the mouse
					this.handle.removeClass( "ui-slider-handle-snapping" );
				}
				
				this.refresh( event );

				// only after refresh() you can calculate this.userModified
				this.userModified = this.beforeStart !== this.element[0].selectedIndex;
				return false;
			}
		},

	_checkedRefresh: function() {
		if ( this.value !== this._value() ) {
			this.refresh( this._value() );
		}
	},

	_value: function() {
		return  this.isToggleSwitch ? this.element[0].selectedIndex : parseFloat( this.element.val() ) ;
	},


	_reset: function() {
		this.refresh( undefined, false, true );
	},

	refresh: function( val, isfromControl, preventInputUpdate ) {
		// NOTE: we don't return here because we want to support programmatic
		//       alteration of the input value, which should still update the slider
		
		var self = this,
			parentTheme = $.mobile.getInheritedTheme( this.element, "c" ),
			theme = this.options.theme || parentTheme,
			trackTheme = this.options.trackTheme || parentTheme,
			left, width, data, tol;

		self.slider[0].className = [ this.isToggleSwitch ? "ui-slider ui-slider-switch" : "ui-slider-track"," ui-btn-down-" + trackTheme,' ui-btn-corner-all', ( this.options.mini ) ? " ui-mini":""].join( "" );
		if ( this.options.disabled || this.element.attr( "disabled" ) ) {
			this.disable();
		}

		// set the stored value for comparison later
		this.value = this._value();
		if ( this.options.highlight && !this.isToggleSwitch && this.slider.find( ".ui-slider-bg" ).length === 0 ) {
			this.valuebg = (function() {
				var bg = document.createElement( "div" );
				bg.className = "ui-slider-bg " + $.mobile.activeBtnClass + " ui-btn-corner-all";
				return $( bg ).prependTo( self.slider );
			})();
		}
		this.handle.buttonMarkup({ corners: true, theme: theme, shadow: true });

		var pxStep, percent,
			control = this.element,
			isInput = !this.isToggleSwitch,
			optionElements = isInput ? [] : control.find( "option" ),
			min =  isInput ? parseFloat( control.attr( "min" ) ) : 0,
			max = isInput ? parseFloat( control.attr( "max" ) ) : optionElements.length - 1,
			step = ( isInput && parseFloat( control.attr( "step" ) ) > 0 ) ? parseFloat( control.attr( "step" ) ) : 1;
			
		if ( typeof val === "object" ) {
			data = val;
			// a slight tolerance helped get to the ends of the slider
			tol = 8;

			left = this.slider.offset().left;
			width = this.slider.width();
			pxStep = width/((max-min)/step);
			if ( !this.dragging ||
					data.pageX < left - tol ||
					data.pageX > left + width + tol ) {
				return;
			}
			if ( pxStep > 1 ) {
				percent = ( ( data.pageX - left ) / width ) * 100;
			} else {
				percent = Math.round( ( ( data.pageX - left ) / width ) * 100 );
			}
		} else {
			if ( val == null ) {
				val = isInput ? parseFloat( control.val() || 0 ) : control[0].selectedIndex;
			}
			percent = ( parseFloat( val ) - min ) / ( max - min ) * 100;
		}

		if ( isNaN( percent ) ) {
			return;
		}

		var newval = ( percent / 100 ) * ( max - min ) + min;

		//from jQuery UI slider, the following source will round to the nearest step
		var valModStep = ( newval - min ) % step;
		var alignValue = newval - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		var percentPerStep = 100/((max-min)/step);
		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see jQueryUI: #4124)
		newval = parseFloat( alignValue.toFixed(5) );

		if ( typeof pxStep === "undefined" ) {
			pxStep = width / ( (max-min) / step );
		}
		if ( pxStep > 1 && isInput ) {
			percent = ( newval - min ) * percentPerStep * ( 1 / step );
		}
		if ( percent < 0 ) {
			percent = 0;
		}

		if ( percent > 100 ) {
			percent = 100;
		}

		if ( newval < min ) {
			newval = min;
		}

		if ( newval > max ) {
			newval = max;
		}

		this.handle.css( "left", percent + "%" );

		this.handle[0].setAttribute( "aria-valuenow", isInput ? newval : optionElements.eq( newval ).attr( "value" ) );

		this.handle[0].setAttribute( "aria-valuetext", isInput ? newval : optionElements.eq( newval ).getEncodedText() );

		this.handle[0].setAttribute( "title", isInput ? newval : optionElements.eq( newval ).getEncodedText() );

		if ( this.valuebg ) {
			this.valuebg.css( "width", percent + "%" );
		}

		// drag the label widths
		if ( this._labels ) {
			var handlePercent = this.handle.width() / this.slider.width() * 100,
				aPercent = percent && handlePercent + ( 100 - handlePercent ) * percent / 100,
				bPercent = percent === 100 ? 0 : Math.min( handlePercent + 100 - aPercent, 100 );

			this._labels.each(function() {
				var ab = $( this ).is( ".ui-slider-label-a" );
				$( this ).width( ( ab ? aPercent : bPercent  ) + "%" );
			});
		}

		if ( !preventInputUpdate ) {
			var valueChanged = false;

			// update control"s value
			if ( isInput ) {
				valueChanged = control.val() !== newval;
				control.val( newval );
			} else {
				valueChanged = control[ 0 ].selectedIndex !== newval;
				control[ 0 ].selectedIndex = newval;
			}
			if ( this._trigger( "beforechange", val ) === false) {
					return false;
			}
			if ( !isfromControl && valueChanged ) {
				control.trigger( "change" );
			}
		}
	},

	enable: function() {
		this.element.attr( "disabled", false );
		this.slider.removeClass( "ui-disabled" ).attr( "aria-disabled", false );
		return this._setOption( "disabled", false );
	},

	disable: function() {
		this.element.attr( "disabled", true );
		this.slider.addClass( "ui-disabled" ).attr( "aria-disabled", true );
		return this._setOption( "disabled", true );
	}

}, $.mobile.behaviors.formReset ) );

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.slider.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {
	$.widget( "mobile.rangeslider", $.mobile.widget, {

		options: {
			theme: null,
			trackTheme: null,
			disabled: false,
			initSelector: ":jqmData(role='rangeslider')",
			mini: false,
			highlight: true
		},

		_create: function() {
			var secondLabel,
			$el = this.element,
			elClass = this.options.mini ? "ui-rangeslider ui-mini" : "ui-rangeslider",
			_inputFirst = $el.find( "input" ).first(),
			_inputLast = $el.find( "input" ).last(),
			label = $el.find( "label" ).first(),
			_sliderFirst = $.data( _inputFirst.get(0), "mobileSlider" ).slider,
			_sliderLast = $.data( _inputLast.get(0), "mobileSlider" ).slider,
			firstHandle = $.data( _inputFirst.get(0), "mobileSlider" ).handle,
			_sliders = $( "<div class=\"ui-rangeslider-sliders\" />" ).appendTo( $el );
			
			if ( $el.find( "label" ).length > 1 ) {
				secondLabel = $el.find( "label" ).last().hide();
			}

			_inputFirst.addClass( "ui-rangeslider-first" );
			_inputLast.addClass( "ui-rangeslider-last" );
			$el.addClass( elClass );
			
			_sliderFirst.appendTo( _sliders );
			_sliderLast.appendTo( _sliders );
			label.prependTo( $el );
			firstHandle.prependTo( _sliderLast );

			$.extend( this, {
				_inputFirst: _inputFirst,
				_inputLast: _inputLast,
				_sliderFirst: _sliderFirst,
				_sliderLast: _sliderLast,
				_targetVal: null,
				_sliderTarget: false,
				_sliders: _sliders,
				_proxy: false
			});
			
			this.refresh();
			this._on( this.element.find( "input.ui-slider-input" ), {
				"slidebeforestart": "_slidebeforestart",
				"slidestop": "_slidestop",
				"slidedrag": "_slidedrag",
				"slidebeforechange": "_change",
				"blur": "_change",
				"keyup": "_change"
			});
			this._on({
				"mousedown":"_change"
			});
			this._on( this.element.closest( "form" ), {
				"reset":"_handleReset"
			});
			this._on( firstHandle, {
				"vmousedown": "_dragFirstHandle"
			});
		},
		_handleReset: function(){
			var self = this;
			//we must wait for the stack to unwind before updateing other wise sliders will not have updated yet
			setTimeout( function(){
				self._updateHighlight();
			},0);
		},

		_dragFirstHandle: function( event ) {
			//if the first handle is dragged send the event to the first slider
			$.data( this._inputFirst.get(0), "mobileSlider" ).dragging = true;
			$.data( this._inputFirst.get(0), "mobileSlider" ).refresh( event );
			return false;
		},

		_slidedrag: function( event ) {
			var first = $( event.target ).is( this._inputFirst ),
				otherSlider = ( first ) ? this._inputLast : this._inputFirst;

			this._sliderTarget = false;
			//if the drag was initiated on an extreme and the other handle is focused send the events to
			//the closest handle
			if ( ( this._proxy === "first" && first ) || ( this._proxy === "last" && !first ) ) {
				$.data( otherSlider.get(0), "mobileSlider" ).dragging = true;
				$.data( otherSlider.get(0), "mobileSlider" ).refresh( event );
				return false;
			}
		},

		_slidestop: function( event ) {
			var first = $( event.target ).is( this._inputFirst );
			
			this._proxy = false;
			//this stops dragging of the handle and brings the active track to the front 
			//this makes clicks on the track go the the last handle used
			this.element.find( "input" ).trigger( "vmouseup" );
			this._sliderFirst.css( "z-index", first ? 1 : "" );
		},

		_slidebeforestart: function( event ) {
			this._sliderTarget = false;
			//if the track is the target remember this and the original value
			if ( $( event.originalEvent.target ).hasClass( "ui-slider-track" ) ) {
				this._sliderTarget = true;
				this._targetVal = $( event.target ).val();
			}
		},

		_setOption: function( options ) {
			this._superApply( options );
			this.refresh();
		},

		refresh: function() {
			var $el = this.element,
				o = this.options;

			$el.find( "input" ).slider({
				theme: o.theme,
				trackTheme: o.trackTheme,
				disabled: o.disabled,
				mini: o.mini,
				highlight: o.highlight
			}).slider( "refresh" );
			this._updateHighlight();
		},

		_change: function( event ) {
			if ( event.type === "keyup" ) {
				this._updateHighlight();
				return false;
			}

			var self = this,
				min = parseFloat( this._inputFirst.val(), 10 ),
				max = parseFloat( this._inputLast.val(), 10 ),
				first = $( event.target ).hasClass( "ui-rangeslider-first" ),
				thisSlider = first ? this._inputFirst : this._inputLast,
				otherSlider = first ? this._inputLast : this._inputFirst;
			
			
			if( ( this._inputFirst.val() > this._inputLast.val() && event.type === "mousedown" && !$(event.target).hasClass("ui-slider-handle")) ){
				thisSlider.blur();
			} else if( event.type === "mousedown" ){
				return;
			}
			if ( min > max && !this._sliderTarget ) {
				//this prevents min from being greater then max
				thisSlider.val( first ? max: min ).slider( "refresh" );
				this._trigger( "normalize" );
			} else if ( min > max ) {
				//this makes it so clicks on the target on either extreme go to the closest handle
				thisSlider.val( this._targetVal ).slider( "refresh" );

				//You must wait for the stack to unwind so first slider is updated before updating second
				setTimeout( function() {
					otherSlider.val( first ? min: max ).slider( "refresh" );
					$.data( otherSlider.get(0), "mobileSlider" ).handle.focus();
					self._sliderFirst.css( "z-index", first ? "" : 1 );
					self._trigger( "normalize" );
				}, 0 );
				this._proxy = ( first ) ? "first" : "last";
			}
			//fixes issue where when both _sliders are at min they cannot be adjusted
			if ( min === max ) {
				$.data( thisSlider.get(0), "mobileSlider" ).handle.css( "z-index", 1 );
				$.data( otherSlider.get(0), "mobileSlider" ).handle.css( "z-index", 0 );
			} else {
				$.data( otherSlider.get(0), "mobileSlider" ).handle.css( "z-index", "" );
				$.data( thisSlider.get(0), "mobileSlider" ).handle.css( "z-index", "" );
			}
			
			this._updateHighlight();
			
			if ( min >= max ) {
				return false;
			}
		},

		_updateHighlight: function() {
			var min = parseInt( $.data( this._inputFirst.get(0), "mobileSlider" ).handle.get(0).style.left, 10 ),
				max = parseInt( $.data( this._inputLast.get(0), "mobileSlider" ).handle.get(0).style.left, 10 ),
				width = (max - min);

			this.element.find( ".ui-slider-bg" ).css({
				"margin-left": min + "%",
				"width": width + "%"
			});
		},

		_destroy: function() {
			this.element.removeClass( "ui-rangeslider ui-mini" ).find( "label" ).show();
			this._inputFirst.after( this._sliderFirst );
			this._inputLast.after( this._sliderLast );
			this._sliders.remove();
			this.element.find( "input" ).removeClass( "ui-rangeslider-first ui-rangeslider-last" ).slider( "destroy" );
		}

	});

$.widget( "mobile.rangeslider", $.mobile.rangeslider, $.mobile.behaviors.formReset );

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ) {
	$.mobile.rangeslider.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.selectmenu", $.mobile.widget, $.extend( {
	options: {
		theme: null,
		disabled: false,
		icon: "arrow-d",
		iconpos: "right",
		inline: false,
		corners: true,
		shadow: true,
		iconshadow: true,
		overlayTheme: "a",
		dividerTheme: "b",
		hidePlaceholderMenuItems: true,
		closeText: "Close",
		nativeMenu: true,
		// This option defaults to true on iOS devices.
		preventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( "AppleWebKit" ) > -1,
		initSelector: "select:not( :jqmData(role='slider') )",
		mini: false
	},

	_button: function() {
		return $( "<div/>" );
	},

	_setDisabled: function( value ) {
		this.element.attr( "disabled", value );
		this.button.attr( "aria-disabled", value );
		return this._setOption( "disabled", value );
	},

	_focusButton : function() {
		var self = this;

		setTimeout( function() {
			self.button.focus();
		}, 40);
	},

	_selectOptions: function() {
		return this.select.find( "option" );
	},

	// setup items that are generally necessary for select menu extension
	_preExtension: function() {
		var classes = "";
		// TODO: Post 1.1--once we have time to test thoroughly--any classes manually applied to the original element should be carried over to the enhanced element, with an `-enhanced` suffix. See https://github.com/jquery/jquery-mobile/issues/3577
		/* if ( $el[0].className.length ) {
			classes = $el[0].className;
		} */
		if ( !!~this.element[0].className.indexOf( "ui-btn-left" ) ) {
			classes = " ui-btn-left";
		}

		if (  !!~this.element[0].className.indexOf( "ui-btn-right" ) ) {
			classes = " ui-btn-right";
		}

		this.select = this.element.removeClass( "ui-btn-left ui-btn-right" ).wrap( "<div class='ui-select" + classes + "'>" );
		this.selectID  = this.select.attr( "id" );
		this.label = $( "label[for='"+ this.selectID +"']" ).addClass( "ui-select" );
		this.isMultiple = this.select[ 0 ].multiple;
		if ( !this.options.theme ) {
			this.options.theme = $.mobile.getInheritedTheme( this.select, "c" );
		}
	},

	_destroy: function() {
		var wrapper = this.element.parents( ".ui-select" );
		if ( wrapper.length > 0 ) {
			if ( wrapper.is( ".ui-btn-left, .ui-btn-right" ) ) {
				this.element.addClass( wrapper.is( ".ui-btn-left" ) ? "ui-btn-left" : "ui-btn-right" );
			}
			this.element.insertAfter( wrapper );
			wrapper.remove();
		}
	},

	_create: function() {
		this._preExtension();

		// Allows for extension of the native select for custom selects and other plugins
		// see select.custom for example extension
		// TODO explore plugin registration
		this._trigger( "beforeCreate" );

		this.button = this._button();

		var self = this,

			options = this.options,

			inline = options.inline || this.select.jqmData( "inline" ),
			mini = options.mini || this.select.jqmData( "mini" ),
			iconpos = options.icon ? ( options.iconpos || this.select.jqmData( "iconpos" ) ) : false,

			// IE throws an exception at options.item() function when
			// there is no selected item
			// select first in this case
			selectedIndex = this.select[ 0 ].selectedIndex === -1 ? 0 : this.select[ 0 ].selectedIndex,

			// TODO values buttonId and menuId are undefined here
			button = this.button
				.insertBefore( this.select )
				.buttonMarkup( {
					theme: options.theme,
					icon: options.icon,
					iconpos: iconpos,
					inline: inline,
					corners: options.corners,
					shadow: options.shadow,
					iconshadow: options.iconshadow,
					mini: mini
				});

		this.setButtonText();

		// Opera does not properly support opacity on select elements
		// In Mini, it hides the element, but not its text
		// On the desktop,it seems to do the opposite
		// for these reasons, using the nativeMenu option results in a full native select in Opera
		if ( options.nativeMenu && window.opera && window.opera.version ) {
			button.addClass( "ui-select-nativeonly" );
		}

		// Add counter for multi selects
		if ( this.isMultiple ) {
			this.buttonCount = $( "<span>" )
				.addClass( "ui-li-count ui-btn-up-c ui-btn-corner-all" )
				.hide()
				.appendTo( button.addClass('ui-li-has-count') );
		}

		// Disable if specified
		if ( options.disabled || this.element.attr('disabled')) {
			this.disable();
		}

		// Events on native select
		this.select.change(function() {
			self.refresh();
			
			if ( !!options.nativeMenu ) {
				this.blur();
			}
		});

		this._handleFormReset();

		this.build();
	},

	build: function() {
		var self = this;

		this.select
			.appendTo( self.button )
			.bind( "vmousedown", function() {
				// Add active class to button
				self.button.addClass( $.mobile.activeBtnClass );
			})
			.bind( "focus", function() {
				self.button.addClass( $.mobile.focusClass );
			})
			.bind( "blur", function() {
				self.button.removeClass( $.mobile.focusClass );
			})
			.bind( "focus vmouseover", function() {
				self.button.trigger( "vmouseover" );
			})
			.bind( "vmousemove", function() {
				// Remove active class on scroll/touchmove
				self.button.removeClass( $.mobile.activeBtnClass );
			})
			.bind( "change blur vmouseout", function() {
				self.button.trigger( "vmouseout" )
					.removeClass( $.mobile.activeBtnClass );
			})
			.bind( "change blur", function() {
				self.button.removeClass( "ui-btn-down-" + self.options.theme );
			});

		// In many situations, iOS will zoom into the select upon tap, this prevents that from happening
		self.button.bind( "vmousedown", function() {
			if ( self.options.preventFocusZoom ) {
					$.mobile.zoom.disable( true );
			}
		});
		self.label.bind( "click focus", function() {
			if ( self.options.preventFocusZoom ) {
					$.mobile.zoom.disable( true );
			}
		});
		self.select.bind( "focus", function() {
			if ( self.options.preventFocusZoom ) {
					$.mobile.zoom.disable( true );
			}
		});
		self.button.bind( "mouseup", function() {
			if ( self.options.preventFocusZoom ) {				
				setTimeout(function() {
					$.mobile.zoom.enable( true );
				}, 0 );
			}
		});
		self.select.bind( "blur", function() {
			if ( self.options.preventFocusZoom ) {				
				$.mobile.zoom.enable( true );
			}
		});

	},

	selected: function() {
                return this._selectOptions().filter( ":selected" );
	},

	selectedIndices: function() {
		var self = this;

		return this.selected().map(function() {
			return self._selectOptions().index( this );
		}).get();
	},

	setButtonText: function() {
		var self = this,
			selected = this.selected(),
			text = this.placeholder,
			span = $( document.createElement( "span" ) );

		this.button.find( ".ui-btn-text" ).html(function() {
			if ( selected.length ) {
				text = selected.map(function() {
					return $( this ).text();
				}).get().join( ", " );
			} else {
				text = self.placeholder;
			}

			// TODO possibly aggregate multiple select option classes
			return span.text( text )
				.addClass( self.select.attr( "class" ) )
				.addClass( selected.attr( "class" ) );
		});
	},

	setButtonCount: function() {
		var selected = this.selected();

		// multiple count inside button
		if ( this.isMultiple ) {
			this.buttonCount[ selected.length > 1 ? "show" : "hide" ]().text( selected.length );
		}
	},

	_reset: function() {
		this.refresh();
	},

	refresh: function() {
		this.setButtonText();
		this.setButtonCount();
	},

	// open and close preserved in native selects
	// to simplify users code when looping over selects
	open: $.noop,
	close: $.noop,

	disable: function() {
		this._setDisabled( true );
		this.button.addClass( "ui-disabled" );
	},

	enable: function() {
		this._setDisabled( false );
		this.button.removeClass( "ui-disabled" );
	}
}, $.mobile.behaviors.formReset ) );

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.selectmenu.prototype.enhanceWithin( e.target, true );
});
})( jQuery );

(function( $, undefined ) {

	function fitSegmentInsideSegment( winSize, segSize, offset, desired ) {
		var ret = desired;

		if ( winSize < segSize ) {
			// Center segment if it's bigger than the window
			ret = offset + ( winSize - segSize ) / 2;
		} else {
			// Otherwise center it at the desired coordinate while keeping it completely inside the window
			ret = Math.min( Math.max( offset, desired - segSize / 2 ), offset + winSize - segSize );
		}

		return ret;
	}

	function windowCoords() {
		var $win = $.mobile.window;

		return {
			x: $win.scrollLeft(),
			y: $win.scrollTop(),
			cx: ( window.innerWidth || $win.width() ),
			cy: ( window.innerHeight || $win.height() )
		};
	}

	$.widget( "mobile.popup", $.mobile.widget, {
		options: {
			theme: null,
			overlayTheme: null,
			shadow: true,
			corners: true,
			transition: "none",
			positionTo: "origin",
			tolerance: null,
			initSelector: ":jqmData(role='popup')",
			closeLinkSelector: "a:jqmData(rel='back')",
			closeLinkEvents: "click.popup",
			navigateEvents: "navigate.popup",
			closeEvents: "navigate.popup pagebeforechange.popup",
			dismissible: true,

			// NOTE Windows Phone 7 has a scroll position caching issue that
			//      requires us to disable popup history management by default
			//      https://github.com/jquery/jquery-mobile/issues/4784
			//
			// NOTE this option is modified in _create!
			history: !$.mobile.browser.oldIE
		},

		_eatEventAndClose: function( e ) {
			e.preventDefault();
			e.stopImmediatePropagation();
			if ( this.options.dismissible ) {
				this.close();
			}
			return false;
		},

		// Make sure the screen size is increased beyond the page height if the popup's causes the document to increase in height
		_resizeScreen: function() {
			var popupHeight = this._ui.container.outerHeight( true );

			this._ui.screen.removeAttr( "style" );
			if ( popupHeight > this._ui.screen.height() ) {
				this._ui.screen.height( popupHeight );
			}
		},

		_handleWindowKeyUp: function( e ) {
			if ( this._isOpen && e.keyCode === $.mobile.keyCode.ESCAPE ) {
				return this._eatEventAndClose( e );
			}
		},

		_expectResizeEvent: function() {
			var winCoords = windowCoords();

			if ( this._resizeData ) {
				if ( winCoords.x === this._resizeData.winCoords.x &&
					winCoords.y === this._resizeData.winCoords.y &&
					winCoords.cx === this._resizeData.winCoords.cx &&
					winCoords.cy === this._resizeData.winCoords.cy ) {
					// timeout not refreshed
					return false;
				} else {
					// clear existing timeout - it will be refreshed below
					clearTimeout( this._resizeData.timeoutId );
				}
			}

			this._resizeData = {
				timeoutId: setTimeout( $.proxy( this, "_resizeTimeout" ), 200 ),
				winCoords: winCoords
			};

			return true;
		},

		_resizeTimeout: function() {
			if ( this._isOpen ) {
				if ( !this._expectResizeEvent() ) {
					if ( this._ui.container.hasClass( "ui-popup-hidden" ) ) {
						// effectively rapid-open the popup while leaving the screen intact
						this._ui.container.removeClass( "ui-popup-hidden" );
						this.reposition( { positionTo: "window" } );
						this._ignoreResizeEvents();
					}

					this._resizeScreen();
					this._resizeData = null;
					this._orientationchangeInProgress = false;
				}
			} else {
				this._resizeData = null;
				this._orientationchangeInProgress = false;
			}
		},

		_ignoreResizeEvents: function() {
			var self = this;

			if ( this._ignoreResizeTo ) {
				clearTimeout( this._ignoreResizeTo );
			}
			this._ignoreResizeTo = setTimeout( function() { self._ignoreResizeTo = 0; }, 1000 );
		},

		_handleWindowResize: function( e ) {
			if ( this._isOpen && this._ignoreResizeTo === 0 ) {
				if ( ( this._expectResizeEvent() || this._orientationchangeInProgress ) &&
					!this._ui.container.hasClass( "ui-popup-hidden" ) ) {
					// effectively rapid-close the popup while leaving the screen intact
					this._ui.container
						.addClass( "ui-popup-hidden" )
						.removeAttr( "style" );
				}
			}
		},

		_handleWindowOrientationchange: function( e ) {
			if ( !this._orientationchangeInProgress && this._isOpen && this._ignoreResizeTo === 0 ) {
				this._expectResizeEvent();
				this._orientationchangeInProgress = true;
			}
		},

		// When the popup is open, attempting to focus on an element that is not a
		// child of the popup will redirect focus to the popup
		_handleDocumentFocusIn: function( e ) {
			var tgt = e.target, $tgt, ui = this._ui;

			if ( !this._isOpen ) {
				return;
			}

			if ( tgt !== ui.container[ 0 ] ) {
				$tgt = $( e.target );
				if ( 0 === $tgt.parents().filter( ui.container[ 0 ] ).length ) {
					$( document.activeElement ).one( "focus", function( e ) {
						$tgt.blur();
					});
					ui.focusElement.focus();
					e.preventDefault();
					e.stopImmediatePropagation();
					return false;
				} else if ( ui.focusElement[ 0 ] === ui.container[ 0 ] ) {
					ui.focusElement = $tgt;
				}
			}

			this._ignoreResizeEvents();
		},

		_create: function() {
			var ui = {
					screen: $( "<div class='ui-screen-hidden ui-popup-screen'></div>" ),
					placeholder: $( "<div style='display: none;'><!-- placeholder --></div>" ),
					container: $( "<div class='ui-popup-container ui-popup-hidden'></div>" )
				},
				thisPage = this.element.closest( ".ui-page" ),
				myId = this.element.attr( "id" ),
				self = this;

			// We need to adjust the history option to be false if there's no AJAX nav.
			// We can't do it in the option declarations because those are run before
			// it is determined whether there shall be AJAX nav.
			this.options.history = this.options.history && $.mobile.ajaxEnabled && $.mobile.hashListeningEnabled;

			if ( thisPage.length === 0 ) {
				thisPage = $( "body" );
			}

			// define the container for navigation event bindings
			// TODO this would be nice at the the mobile widget level
			this.options.container = this.options.container || $.mobile.pageContainer;

			// Apply the proto
			thisPage.append( ui.screen );
			ui.container.insertAfter( ui.screen );
			// Leave a placeholder where the element used to be
			ui.placeholder.insertAfter( this.element );
			if ( myId ) {
				ui.screen.attr( "id", myId + "-screen" );
				ui.container.attr( "id", myId + "-popup" );
				ui.placeholder.html( "<!-- placeholder for " + myId + " -->" );
			}
			ui.container.append( this.element );
			ui.focusElement = ui.container;

			// Add class to popup element
			this.element.addClass( "ui-popup" );

			// Define instance variables
			$.extend( this, {
				_scrollTop: 0,
				_page: thisPage,
				_ui: ui,
				_fallbackTransition: "",
				_currentTransition: false,
				_prereqs: null,
				_isOpen: false,
				_tolerance: null,
				_resizeData: null,
				_ignoreResizeTo: 0,
				_orientationchangeInProgress: false
			});

			$.each( this.options, function( key, value ) {
				// Cause initial options to be applied by their handler by temporarily setting the option to undefined
				// - the handler then sets it to the initial value
				self.options[ key ] = undefined;
				self._setOption( key, value, true );
			});

			ui.screen.bind( "vclick", $.proxy( this, "_eatEventAndClose" ) );

			this._on( $.mobile.window, {
				orientationchange: $.proxy( this, "_handleWindowOrientationchange" ),
				resize: $.proxy( this, "_handleWindowResize" ),
				keyup: $.proxy( this, "_handleWindowKeyUp" )
			});
			this._on( $.mobile.document, {
				focusin: $.proxy( this, "_handleDocumentFocusIn" )
			});
		},

		_applyTheme: function( dst, theme, prefix ) {
			var classes = ( dst.attr( "class" ) || "").split( " " ),
				alreadyAdded = true,
				currentTheme = null,
				matches,
				themeStr = String( theme );

			while ( classes.length > 0 ) {
				currentTheme = classes.pop();
				matches = ( new RegExp( "^ui-" + prefix + "-([a-z])$" ) ).exec( currentTheme );
				if ( matches && matches.length > 1 ) {
					currentTheme = matches[ 1 ];
					break;
				} else {
					currentTheme = null;
				}
			}

			if ( theme !== currentTheme ) {
				dst.removeClass( "ui-" + prefix + "-" + currentTheme );
				if ( ! ( theme === null || theme === "none" ) ) {
					dst.addClass( "ui-" + prefix + "-" + themeStr );
				}
			}
		},

		_setTheme: function( value ) {
			this._applyTheme( this.element, value, "body" );
		},

		_setOverlayTheme: function( value ) {
			this._applyTheme( this._ui.screen, value, "overlay" );

			if ( this._isOpen ) {
				this._ui.screen.addClass( "in" );
			}
		},

		_setShadow: function( value ) {
			this.element.toggleClass( "ui-overlay-shadow", value );
		},

		_setCorners: function( value ) {
			this.element.toggleClass( "ui-corner-all", value );
		},

		_applyTransition: function( value ) {
			this._ui.container.removeClass( this._fallbackTransition );
			if ( value && value !== "none" ) {
				this._fallbackTransition = $.mobile._maybeDegradeTransition( value );
				if ( this._fallbackTransition === "none" ) {
					this._fallbackTransition = "";
				}
				this._ui.container.addClass( this._fallbackTransition );
			}
		},

		_setTransition: function( value ) {
			if ( !this._currentTransition ) {
				this._applyTransition( value );
			}
		},

		_setTolerance: function( value ) {
			var tol = { t: 30, r: 15, b: 30, l: 15 };

			if ( value !== undefined ) {
				var ar = String( value ).split( "," );

				$.each( ar, function( idx, val ) { ar[ idx ] = parseInt( val, 10 ); } );

				switch( ar.length ) {
					// All values are to be the same
					case 1:
						if ( !isNaN( ar[ 0 ] ) ) {
							tol.t = tol.r = tol.b = tol.l = ar[ 0 ];
						}
						break;

					// The first value denotes top/bottom tolerance, and the second value denotes left/right tolerance
					case 2:
						if ( !isNaN( ar[ 0 ] ) ) {
							tol.t = tol.b = ar[ 0 ];
						}
						if ( !isNaN( ar[ 1 ] ) ) {
							tol.l = tol.r = ar[ 1 ];
						}
						break;

					// The array contains values in the order top, right, bottom, left
					case 4:
						if ( !isNaN( ar[ 0 ] ) ) {
							tol.t = ar[ 0 ];
						}
						if ( !isNaN( ar[ 1 ] ) ) {
							tol.r = ar[ 1 ];
						}
						if ( !isNaN( ar[ 2 ] ) ) {
							tol.b = ar[ 2 ];
						}
						if ( !isNaN( ar[ 3 ] ) ) {
							tol.l = ar[ 3 ];
						}
						break;

					default:
						break;
				}
			}

			this._tolerance = tol;
		},

		_setOption: function( key, value ) {
			var exclusions, setter = "_set" + key.charAt( 0 ).toUpperCase() + key.slice( 1 );

			if ( this[ setter ] !== undefined ) {
				this[ setter ]( value );
			}

			// TODO REMOVE FOR 1.2.1 by moving them out to a default options object
			exclusions = [
				"initSelector",
				"closeLinkSelector",
				"closeLinkEvents",
				"navigateEvents",
				"closeEvents",
				"history",
				"container"
			];

			$.mobile.widget.prototype._setOption.apply( this, arguments );
			if ( $.inArray( key, exclusions ) === -1 ) {
				// Record the option change in the options and in the DOM data-* attributes
				this.element.attr( "data-" + ( $.mobile.ns || "" ) + ( key.replace( /([A-Z])/, "-$1" ).toLowerCase() ), value );
			}
		},

		// Try and center the overlay over the given coordinates
		_placementCoords: function( desired ) {
			// rectangle within which the popup must fit
			var
				winCoords = windowCoords(),
				rc = {
					x: this._tolerance.l,
					y: winCoords.y + this._tolerance.t,
					cx: winCoords.cx - this._tolerance.l - this._tolerance.r,
					cy: winCoords.cy - this._tolerance.t - this._tolerance.b
				},
				menuSize, ret;

			// Clamp the width of the menu before grabbing its size
			this._ui.container.css( "max-width", rc.cx );
			menuSize = {
				cx: this._ui.container.outerWidth( true ),
				cy: this._ui.container.outerHeight( true )
			};

			// Center the menu over the desired coordinates, while not going outside
			// the window tolerances. This will center wrt. the window if the popup is too large.
			ret = {
				x: fitSegmentInsideSegment( rc.cx, menuSize.cx, rc.x, desired.x ),
				y: fitSegmentInsideSegment( rc.cy, menuSize.cy, rc.y, desired.y )
			};

			// Make sure the top of the menu is visible
			ret.y = Math.max( 0, ret.y );

			// If the height of the menu is smaller than the height of the document
			// align the bottom with the bottom of the document

			// fix for $.mobile.document.height() bug in core 1.7.2.
			var docEl = document.documentElement, docBody = document.body,
				docHeight = Math.max( docEl.clientHeight, docBody.scrollHeight, docBody.offsetHeight, docEl.scrollHeight, docEl.offsetHeight );

			ret.y -= Math.min( ret.y, Math.max( 0, ret.y + menuSize.cy - docHeight ) );

			return { left: ret.x, top: ret.y };
		},

		_createPrereqs: function( screenPrereq, containerPrereq, whenDone ) {
			var self = this, prereqs;

			// It is important to maintain both the local variable prereqs and self._prereqs. The local variable remains in
			// the closure of the functions which call the callbacks passed in. The comparison between the local variable and
			// self._prereqs is necessary, because once a function has been passed to .animationComplete() it will be called
			// next time an animation completes, even if that's not the animation whose end the function was supposed to catch
			// (for example, if an abort happens during the opening animation, the .animationComplete handler is not called for
			// that animation anymore, but the handler remains attached, so it is called the next time the popup is opened
			// - making it stale. Comparing the local variable prereqs to the widget-level variable self._prereqs ensures that
			// callbacks triggered by a stale .animationComplete will be ignored.

			prereqs = {
				screen: $.Deferred(),
				container: $.Deferred()
			};

			prereqs.screen.then( function() {
				if ( prereqs === self._prereqs ) {
					screenPrereq();
				}
			});

			prereqs.container.then( function() {
				if ( prereqs === self._prereqs ) {
					containerPrereq();
				}
			});

			$.when( prereqs.screen, prereqs.container ).done( function() {
				if ( prereqs === self._prereqs ) {
					self._prereqs = null;
					whenDone();
				}
			});

			self._prereqs = prereqs;
		},

		_animate: function( args ) {
			// NOTE before removing the default animation of the screen
			//      this had an animate callback that would resolve the deferred
			//      now the deferred is resolved immediately
			// TODO remove the dependency on the screen deferred
			this._ui.screen
				.removeClass( args.classToRemove )
				.addClass( args.screenClassToAdd );

			args.prereqs.screen.resolve();

			if ( args.transition && args.transition !== "none" ) {
				if ( args.applyTransition ) {
					this._applyTransition( args.transition );
				}
				if ( this._fallbackTransition ) {
					this._ui.container
						.animationComplete( $.proxy( args.prereqs.container, "resolve" ) )
						.addClass( args.containerClassToAdd )
						.removeClass( args.classToRemove );
					return;
				}
			}
			this._ui.container.removeClass( args.classToRemove );
			args.prereqs.container.resolve();
		},

		// The desired coordinates passed in will be returned untouched if no reference element can be identified via
		// desiredPosition.positionTo. Nevertheless, this function ensures that its return value always contains valid
		// x and y coordinates by specifying the center middle of the window if the coordinates are absent.
		// options: { x: coordinate, y: coordinate, positionTo: string: "origin", "window", or jQuery selector
		_desiredCoords: function( o ) {
			var dst = null, offset, winCoords = windowCoords(), x = o.x, y = o.y, pTo = o.positionTo;

			// Establish which element will serve as the reference
			if ( pTo && pTo !== "origin" ) {
				if ( pTo === "window" ) {
					x = winCoords.cx / 2 + winCoords.x;
					y = winCoords.cy / 2 + winCoords.y;
				} else {
					try {
						dst = $( pTo );
					} catch( e ) {
						dst = null;
					}
					if ( dst ) {
						dst.filter( ":visible" );
						if ( dst.length === 0 ) {
							dst = null;
						}
					}
				}
			}

			// If an element was found, center over it
			if ( dst ) {
				offset = dst.offset();
				x = offset.left + dst.outerWidth() / 2;
				y = offset.top + dst.outerHeight() / 2;
			}

			// Make sure x and y are valid numbers - center over the window
			if ( $.type( x ) !== "number" || isNaN( x ) ) {
				x = winCoords.cx / 2 + winCoords.x;
			}
			if ( $.type( y ) !== "number" || isNaN( y ) ) {
				y = winCoords.cy / 2 + winCoords.y;
			}

			return { x: x, y: y };
		},

		_reposition: function( o ) {
			// We only care about position-related parameters for repositioning
			o = { x: o.x, y: o.y, positionTo: o.positionTo };
			this._trigger( "beforeposition", o );
			this._ui.container.offset( this._placementCoords( this._desiredCoords( o ) ) );
		},

		reposition: function( o ) {
			if ( this._isOpen ) {
				this._reposition( o );
			}
		},

		_openPrereqsComplete: function() {
			this._ui.container.addClass( "ui-popup-active" );
			this._isOpen = true;
			this._resizeScreen();
			this._ui.container.attr( "tabindex", "0" ).focus();
			this._ignoreResizeEvents();
			this._trigger( "afteropen" );
		},

		_open: function( options ) {
			var o = $.extend( {}, this.options, options ),
				// TODO move blacklist to private method
				androidBlacklist = ( function() {
					var w = window,
						ua = navigator.userAgent,
						// Rendering engine is Webkit, and capture major version
						wkmatch = ua.match( /AppleWebKit\/([0-9\.]+)/ ),
						wkversion = !!wkmatch && wkmatch[ 1 ],
						androidmatch = ua.match( /Android (\d+(?:\.\d+))/ ),
						andversion = !!androidmatch && androidmatch[ 1 ],
						chromematch = ua.indexOf( "Chrome" ) > -1;

					// Platform is Android, WebKit version is greater than 534.13 ( Android 3.2.1 ) and not Chrome.
					if( androidmatch !== null && andversion === "4.0" && wkversion && wkversion > 534.13 && !chromematch ) {
						return true;
					}
					return false;
				}());

			// Count down to triggering "popupafteropen" - we have two prerequisites:
			// 1. The popup window animation completes (container())
			// 2. The screen opacity animation completes (screen())
			this._createPrereqs(
				$.noop,
				$.noop,
				$.proxy( this, "_openPrereqsComplete" ) );

			this._currentTransition = o.transition;
			this._applyTransition( o.transition );

			if ( !this.options.theme ) {
				this._setTheme( this._page.jqmData( "theme" ) || $.mobile.getInheritedTheme( this._page, "c" ) );
			}

			this._ui.screen.removeClass( "ui-screen-hidden" );
			this._ui.container.removeClass( "ui-popup-hidden" );

			// Give applications a chance to modify the contents of the container before it appears
			this._reposition( o );

			if ( this.options.overlayTheme && androidBlacklist ) {
				/* TODO:
				The native browser on Android 4.0.X ("Ice Cream Sandwich") suffers from an issue where the popup overlay appears to be z-indexed
				above the popup itself when certain other styles exist on the same page -- namely, any element set to `position: fixed` and certain
				types of input. These issues are reminiscent of previously uncovered bugs in older versions of Android's native browser:
				https://github.com/scottjehl/Device-Bugs/issues/3

				This fix closes the following bugs ( I use "closes" with reluctance, and stress that this issue should be revisited as soon as possible ):

				https://github.com/jquery/jquery-mobile/issues/4816
				https://github.com/jquery/jquery-mobile/issues/4844
				https://github.com/jquery/jquery-mobile/issues/4874
				*/

				// TODO sort out why this._page isn't working
				this.element.closest( ".ui-page" ).addClass( "ui-popup-open" );
			}
			this._animate({
				additionalCondition: true,
				transition: o.transition,
				classToRemove: "",
				screenClassToAdd: "in",
				containerClassToAdd: "in",
				applyTransition: false,
				prereqs: this._prereqs
			});
		},

		_closePrereqScreen: function() {
			this._ui.screen
				.removeClass( "out" )
				.addClass( "ui-screen-hidden" );
		},

		_closePrereqContainer: function() {
			this._ui.container
				.removeClass( "reverse out" )
				.addClass( "ui-popup-hidden" )
				.removeAttr( "style" );
		},

		_closePrereqsDone: function() {
			var opts = this.options;

			this._ui.container.removeAttr( "tabindex" );

			// remove the global mutex for popups
			$.mobile.popup.active = undefined;

			// alert users that the popup is closed
			this._trigger( "afterclose" );
		},

		_close: function( immediate ) {
			this._ui.container.removeClass( "ui-popup-active" );
			this._page.removeClass( "ui-popup-open" );

			this._isOpen = false;

			// Count down to triggering "popupafterclose" - we have two prerequisites:
			// 1. The popup window reverse animation completes (container())
			// 2. The screen opacity animation completes (screen())
			this._createPrereqs(
				$.proxy( this, "_closePrereqScreen" ),
				$.proxy( this, "_closePrereqContainer" ),
				$.proxy( this, "_closePrereqsDone" ) );

			this._animate( {
				additionalCondition: this._ui.screen.hasClass( "in" ),
				transition: ( immediate ? "none" : ( this._currentTransition ) ),
				classToRemove: "in",
				screenClassToAdd: "out",
				containerClassToAdd: "reverse out",
				applyTransition: true,
				prereqs: this._prereqs
			});
		},

		_unenhance: function() {
			// Put the element back to where the placeholder was and remove the "ui-popup" class
			this._setTheme( "none" );
			this.element
				// Cannot directly insertAfter() - we need to detach() first, because
				// insertAfter() will do nothing if the payload div was not attached
				// to the DOM at the time the widget was created, and so the payload
				// will remain inside the container even after we call insertAfter().
				// If that happens and we remove the container a few lines below, we
				// will cause an infinite recursion - #5244
				.detach()
				.insertAfter( this._ui.placeholder )
				.removeClass( "ui-popup ui-overlay-shadow ui-corner-all" );
			this._ui.screen.remove();
			this._ui.container.remove();
			this._ui.placeholder.remove();
		},

		_destroy: function() {
			if ( $.mobile.popup.active === this ) {
				this.element.one( "popupafterclose", $.proxy( this, "_unenhance" ) );
				this.close();
			} else {
				this._unenhance();
			}
		},

		_closePopup: function( e, data ) {
			var parsedDst, toUrl, o = this.options, immediate = false;

			// restore location on screen
			window.scrollTo( 0, this._scrollTop );

			if ( e && e.type === "pagebeforechange" && data ) {
				// Determine whether we need to rapid-close the popup, or whether we can
				// take the time to run the closing transition
				if ( typeof data.toPage === "string" ) {
					parsedDst = data.toPage;
				} else {
					parsedDst = data.toPage.jqmData( "url" );
				}
				parsedDst = $.mobile.path.parseUrl( parsedDst );
				toUrl = parsedDst.pathname + parsedDst.search + parsedDst.hash;

				if ( this._myUrl !== $.mobile.path.makeUrlAbsolute( toUrl ) ) {
					// Going to a different page - close immediately
					immediate = true;
				} else {
					e.preventDefault();
				}
			}

			// remove nav bindings
			o.container.unbind( o.closeEvents );
			// unbind click handlers added when history is disabled
			this.element.undelegate( o.closeLinkSelector, o.closeLinkEvents );

			this._close( immediate );
		},

		// any navigation event after a popup is opened should close the popup
		// NOTE the pagebeforechange is bound to catch navigation events that don't
		//      alter the url (eg, dialogs from popups)
		_bindContainerClose: function() {
			this.options.container
				.one( this.options.closeEvents, $.proxy( this, "_closePopup" ) );
		},

		// TODO no clear deliniation of what should be here and
		// what should be in _open. Seems to be "visual" vs "history" for now
		open: function( options ) {
			var self = this, opts = this.options, url, hashkey, activePage, currentIsDialog, hasHash, urlHistory;

			// make sure open is idempotent
			if( $.mobile.popup.active ) {
				return;
			}

			// set the global popup mutex
			$.mobile.popup.active = this;
			this._scrollTop = $.mobile.window.scrollTop();

			// if history alteration is disabled close on navigate events
			// and leave the url as is
			if( !( opts.history ) ) {
				self._open( options );
				self._bindContainerClose();

				// When histoy is disabled we have to grab the data-rel
				// back link clicks so we can close the popup instead of
				// relying on history to do it for us
				self.element
					.delegate( opts.closeLinkSelector, opts.closeLinkEvents, function( e ) {
						self.close();
						e.preventDefault();
					});

				return;
			}

			// cache some values for min/readability
			urlHistory = $.mobile.urlHistory;
			hashkey = $.mobile.dialogHashKey;
			activePage = $.mobile.activePage;
			currentIsDialog = activePage.is( ".ui-dialog" );
			this._myUrl = url = urlHistory.getActive().url;
			hasHash = ( url.indexOf( hashkey ) > -1 ) && !currentIsDialog && ( urlHistory.activeIndex > 0 );

			if ( hasHash ) {
				self._open( options );
				self._bindContainerClose();
				return;
			}

			// if the current url has no dialog hash key proceed as normal
			// otherwise, if the page is a dialog simply tack on the hash key
			if ( url.indexOf( hashkey ) === -1 && !currentIsDialog ){
				url = url + (url.indexOf( "#" ) > -1 ? hashkey : "#" + hashkey);
			} else {
				url = $.mobile.path.parseLocation().hash + hashkey;
			}

			// Tack on an extra hashkey if this is the first page and we've just reconstructed the initial hash
			if ( urlHistory.activeIndex === 0 && url === urlHistory.initialDst ) {
				url += hashkey;
			}

			// swallow the the initial navigation event, and bind for the next
			$(window).one( "beforenavigate", function( e ) {
				e.preventDefault();
				self._open( options );
				self._bindContainerClose();
			});

			this.urlAltered = true;
			$.mobile.navigate( url, {role: "dialog"} );
		},

		close: function() {
			// make sure close is idempotent
			if( $.mobile.popup.active !== this ) {
				return;
			}

			this._scrollTop = $.mobile.window.scrollTop();

			if( this.options.history && this.urlAltered ) {
				$.mobile.back();
				this.urlAltered = false;
			} else {
				// simulate the nav bindings having fired
				this._closePopup();
			}
		}
	});


	// TODO this can be moved inside the widget
	$.mobile.popup.handleLink = function( $link ) {
		var closestPage = $link.closest( ":jqmData(role='page')" ),
			scope = ( ( closestPage.length === 0 ) ? $( "body" ) : closestPage ),
			// NOTE make sure to get only the hash, ie7 (wp7) return the absolute href
			//      in this case ruining the element selection
			popup = $( $.mobile.path.parseUrl($link.attr( "href" )).hash, scope[0] ),
			offset;

		if ( popup.data( "mobile-popup" ) ) {
			offset = $link.offset();
			popup.popup( "open", {
				x: offset.left + $link.outerWidth() / 2,
				y: offset.top + $link.outerHeight() / 2,
				transition: $link.jqmData( "transition" ),
				positionTo: $link.jqmData( "position-to" )
			});
		}

		//remove after delay
		setTimeout( function() {
			// Check if we are in a listview
			var $parent = $link.parent().parent();
			if ($parent.hasClass("ui-li")) {
				$link = $parent.parent();
			}
			$link.removeClass( $.mobile.activeBtnClass );
		}, 300 );
	};

	// TODO move inside _create
	$.mobile.document.bind( "pagebeforechange", function( e, data ) {
		if ( data.options.role === "popup" ) {
			$.mobile.popup.handleLink( data.options.link );
			e.preventDefault();
		}
	});

	$.mobile.document.bind( "pagecreate create", function( e )  {
		$.mobile.popup.prototype.enhanceWithin( e.target, true );
	});

})( jQuery );

/*
* custom "selectmenu" plugin
*/

(function( $, undefined ) {
	var extendSelect = function( widget ) {

		var select = widget.select,
			origDestroy = widget._destroy,
			selectID  = widget.selectID,
			prefix = ( selectID ? selectID : ( ( $.mobile.ns || "" ) + "uuid-" + widget.uuid ) ),
			popupID = prefix + "-listbox",
			dialogID = prefix + "-dialog",
			label = widget.label,
			thisPage = widget.select.closest( ".ui-page" ),
			selectOptions = widget._selectOptions(),
			isMultiple = widget.isMultiple = widget.select[ 0 ].multiple,
			buttonId = selectID + "-button",
			menuId = selectID + "-menu",
			menuPage = $( "<div data-" + $.mobile.ns + "role='dialog' id='" + dialogID + "' data-" +$.mobile.ns + "theme='"+ widget.options.theme +"' data-" +$.mobile.ns + "overlay-theme='"+ widget.options.overlayTheme +"'>" +
				"<div data-" + $.mobile.ns + "role='header'>" +
				"<div class='ui-title'>" + label.getEncodedText() + "</div>"+
				"</div>"+
				"<div data-" + $.mobile.ns + "role='content'></div>"+
				"</div>" ),

			listbox =  $( "<div id='" + popupID + "' class='ui-selectmenu'>" ).insertAfter( widget.select ).popup( { theme: widget.options.overlayTheme } ),

			list = $( "<ul>", {
				"class": "ui-selectmenu-list",
				"id": menuId,
				"role": "listbox",
				"aria-labelledby": buttonId
				}).attr( "data-" + $.mobile.ns + "theme", widget.options.theme )
					.attr( "data-" + $.mobile.ns + "divider-theme", widget.options.dividerTheme )
					.appendTo( listbox ),


			header = $( "<div>", {
				"class": "ui-header ui-bar-" + widget.options.theme
			}).prependTo( listbox ),

			headerTitle = $( "<h1>", {
				"class": "ui-title"
			}).appendTo( header ),

			menuPageContent,
			menuPageClose,
			headerClose;

		if ( widget.isMultiple ) {
			headerClose = $( "<a>", {
				"text": widget.options.closeText,
				"href": "#",
				"class": "ui-btn-left"
			}).attr( "data-" + $.mobile.ns + "iconpos", "notext" ).attr( "data-" + $.mobile.ns + "icon", "delete" ).appendTo( header ).buttonMarkup();
		}

		$.extend( widget, {
			select: widget.select,
			selectID: selectID,
			buttonId: buttonId,
			menuId: menuId,
			popupID: popupID,
			dialogID: dialogID,
			thisPage: thisPage,
			menuPage: menuPage,
			label: label,
			selectOptions: selectOptions,
			isMultiple: isMultiple,
			theme: widget.options.theme,
			listbox: listbox,
			list: list,
			header: header,
			headerTitle: headerTitle,
			headerClose: headerClose,
			menuPageContent: menuPageContent,
			menuPageClose: menuPageClose,
			placeholder: "",

			build: function() {
				var self = this;

				// Create list from select, update state
				self.refresh();

				if ( self._origTabIndex === undefined ) {
					// Map undefined to false, because self._origTabIndex === undefined
					// indicates that we have not yet checked whether the select has
					// originally had a tabindex attribute, whereas false indicates that
					// we have checked the select for such an attribute, and have found
					// none present.
					self._origTabIndex = ( self.select[ 0 ].getAttribute( "tabindex" ) === null ) ? false : self.select.attr( "tabindex" );
				}
				self.select.attr( "tabindex", "-1" ).focus(function() {
					$( this ).blur();
					self.button.focus();
				});

				// Button events
				self.button.bind( "vclick keydown" , function( event ) {
					if ( self.options.disabled || self.isOpen ) {
						return;
					}

					if (event.type === "vclick" ||
							event.keyCode && (event.keyCode === $.mobile.keyCode.ENTER ||
																event.keyCode === $.mobile.keyCode.SPACE)) {

						self._decideFormat();
						if ( self.menuType === "overlay" ) {
							self.button.attr( "href", "#" + self.popupID ).attr( "data-" + ( $.mobile.ns || "" ) + "rel", "popup" );
						} else {
							self.button.attr( "href", "#" + self.dialogID ).attr( "data-" + ( $.mobile.ns || "" ) + "rel", "dialog" );
						}
						self.isOpen = true;
						// Do not prevent default, so the navigation may have a chance to actually open the chosen format
					}
				});

				// Events for list items
				self.list.attr( "role", "listbox" )
					.bind( "focusin", function( e ) {
						$( e.target )
							.attr( "tabindex", "0" )
							.trigger( "vmouseover" );

					})
					.bind( "focusout", function( e ) {
						$( e.target )
							.attr( "tabindex", "-1" )
							.trigger( "vmouseout" );
					})
					.delegate( "li:not(.ui-disabled, .ui-li-divider)", "click", function( event ) {

						// index of option tag to be selected
						var oldIndex = self.select[ 0 ].selectedIndex,
							newIndex = self.list.find( "li:not(.ui-li-divider)" ).index( this ),
							option = self._selectOptions().eq( newIndex )[ 0 ];

						// toggle selected status on the tag for multi selects
						option.selected = self.isMultiple ? !option.selected : true;

						// toggle checkbox class for multiple selects
						if ( self.isMultiple ) {
							$( this ).find( ".ui-icon" )
								.toggleClass( "ui-icon-checkbox-on", option.selected )
								.toggleClass( "ui-icon-checkbox-off", !option.selected );
						}

						// trigger change if value changed
						if ( self.isMultiple || oldIndex !== newIndex ) {
							self.select.trigger( "change" );
						}

						// hide custom select for single selects only - otherwise focus clicked item
						// We need to grab the clicked item the hard way, because the list may have been rebuilt
						if ( self.isMultiple ) {
							self.list.find( "li:not(.ui-li-divider)" ).eq( newIndex )
								.addClass( "ui-btn-down-" + widget.options.theme ).find( "a" ).first().focus();
						}
						else {
							self.close();
						}

						event.preventDefault();
					})
					.keydown(function( event ) {  //keyboard events for menu items
						var target = $( event.target ),
							li = target.closest( "li" ),
							prev, next;

						// switch logic based on which key was pressed
						switch ( event.keyCode ) {
							// up or left arrow keys
						case 38:
							prev = li.prev().not( ".ui-selectmenu-placeholder" );

							if ( prev.is( ".ui-li-divider" ) ) {
								prev = prev.prev();
							}

							// if there's a previous option, focus it
							if ( prev.length ) {
								target
									.blur()
									.attr( "tabindex", "-1" );

								prev.addClass( "ui-btn-down-" + widget.options.theme ).find( "a" ).first().focus();
							}

							return false;
							// down or right arrow keys
						case 40:
							next = li.next();

							if ( next.is( ".ui-li-divider" ) ) {
								next = next.next();
							}

							// if there's a next option, focus it
							if ( next.length ) {
								target
									.blur()
									.attr( "tabindex", "-1" );

								next.addClass( "ui-btn-down-" + widget.options.theme ).find( "a" ).first().focus();
							}

							return false;
							// If enter or space is pressed, trigger click
						case 13:
						case 32:
							target.trigger( "click" );

							return false;
						}
					});

				// button refocus ensures proper height calculation
				// by removing the inline style and ensuring page inclusion
				self.menuPage.bind( "pagehide", function() {
					// TODO centralize page removal binding / handling in the page plugin.
					// Suggestion from @jblas to do refcounting
					//
					// TODO extremely confusing dependency on the open method where the pagehide.remove
					// bindings are stripped to prevent the parent page from disappearing. The way
					// we're keeping pages in the DOM right now sucks
					//
					// rebind the page remove that was unbound in the open function
					// to allow for the parent page removal from actions other than the use
					// of a dialog sized custom select
					//
					// doing this here provides for the back button on the custom select dialog
					$.mobile._bindPageRemove.call( self.thisPage );
				});

				// Events on the popup
				self.listbox.bind( "popupafterclose", function( event ) {
					self.close();
				});

				// Close button on small overlays
				if ( self.isMultiple ) {
					self.headerClose.click(function() {
						if ( self.menuType === "overlay" ) {
							self.close();
							return false;
						}
					});
				}

				// track this dependency so that when the parent page
				// is removed on pagehide it will also remove the menupage
				self.thisPage.addDependents( this.menuPage );
			},

			_isRebuildRequired: function() {
				var list = this.list.find( "li" ),
					options = this._selectOptions();

				// TODO exceedingly naive method to determine difference
				// ignores value changes etc in favor of a forcedRebuild
				// from the user in the refresh method
				return options.text() !== list.text();
			},

			selected: function() {
				return this._selectOptions().filter( ":selected:not( :jqmData(placeholder='true') )" );
			},

			refresh: function( forceRebuild , foo ) {
				var self = this,
				select = this.element,
				isMultiple = this.isMultiple,
				indicies;

				if (  forceRebuild || this._isRebuildRequired() ) {
					self._buildList();
				}

				indicies = this.selectedIndices();

				self.setButtonText();
				self.setButtonCount();

				self.list.find( "li:not(.ui-li-divider)" )
					.removeClass( $.mobile.activeBtnClass )
					.attr( "aria-selected", false )
					.each(function( i ) {

						if ( $.inArray( i, indicies ) > -1 ) {
							var item = $( this );

							// Aria selected attr
							item.attr( "aria-selected", true );

							// Multiple selects: add the "on" checkbox state to the icon
							if ( self.isMultiple ) {
								item.find( ".ui-icon" ).removeClass( "ui-icon-checkbox-off" ).addClass( "ui-icon-checkbox-on" );
							} else {
								if ( item.is( ".ui-selectmenu-placeholder" ) ) {
									item.next().addClass( $.mobile.activeBtnClass );
								} else {
									item.addClass( $.mobile.activeBtnClass );
								}
							}
						}
					});
			},

			close: function() {
				if ( this.options.disabled || !this.isOpen ) {
					return;
				}

				var self = this;

				if ( self.menuType === "page" ) {
					self.menuPage.dialog( "close" );
					self.list.appendTo( self.listbox );
				} else {
					self.listbox.popup( "close" );
				}

				self._focusButton();
				// allow the dialog to be closed again
				self.isOpen = false;
			},

			open: function() {
				this.button.click();
			},

			_decideFormat: function() {
				var self = this,
					$window = $.mobile.window,
					selfListParent = self.list.parent(),
					menuHeight = selfListParent.outerHeight(),
					menuWidth = selfListParent.outerWidth(),
					activePage = $( "." + $.mobile.activePageClass ),
					scrollTop = $window.scrollTop(),
					btnOffset = self.button.offset().top,
					screenHeight = $window.height(),
					screenWidth = $window.width();

				function focusMenuItem() {
					var selector = self.list.find( "." + $.mobile.activeBtnClass + " a" );
					if ( selector.length === 0 ) {
						selector = self.list.find( "li.ui-btn:not( :jqmData(placeholder='true') ) a" );
					}
					selector.first().focus().closest( "li" ).addClass( "ui-btn-down-" + widget.options.theme );
				}

				if ( menuHeight > screenHeight - 80 || !$.support.scrollTop ) {

					self.menuPage.appendTo( $.mobile.pageContainer ).page();
					self.menuPageContent = menuPage.find( ".ui-content" );
					self.menuPageClose = menuPage.find( ".ui-header a" );

					// prevent the parent page from being removed from the DOM,
					// otherwise the results of selecting a list item in the dialog
					// fall into a black hole
					self.thisPage.unbind( "pagehide.remove" );

					//for WebOS/Opera Mini (set lastscroll using button offset)
					if ( scrollTop === 0 && btnOffset > screenHeight ) {
						self.thisPage.one( "pagehide", function() {
							$( this ).jqmData( "lastScroll", btnOffset );
						});
					}

					self.menuPage
						.one( "pageshow", function() {
							focusMenuItem();
						})
						.one( "pagehide", function() {
							self.close();
						});

					self.menuType = "page";
					self.menuPageContent.append( self.list );
					self.menuPage.find("div .ui-title").text(self.label.text());
				} else {
					self.menuType = "overlay";

					self.listbox.one( "popupafteropen", focusMenuItem );
				}
			},

			_buildList: function() {
				var self = this,
					o = this.options,
					placeholder = this.placeholder,
					needPlaceholder = true,
					optgroups = [],
					lis = [],
					dataIcon = self.isMultiple ? "checkbox-off" : "false";

				self.list.empty().filter( ".ui-listview" ).listview( "destroy" );

				var $options = self.select.find( "option" ),
					numOptions = $options.length,
					select = this.select[ 0 ],
					dataPrefix = 'data-' + $.mobile.ns,
					dataIndexAttr = dataPrefix + 'option-index',
					dataIconAttr = dataPrefix + 'icon',
					dataRoleAttr = dataPrefix + 'role',
					dataPlaceholderAttr = dataPrefix + 'placeholder',
					fragment = document.createDocumentFragment(),
					isPlaceholderItem = false,
					optGroup;

				for (var i = 0; i < numOptions;i++, isPlaceholderItem = false) {
					var option = $options[i],
						$option = $( option ),
						parent = option.parentNode,
						text = $option.text(),
						anchor  = document.createElement( 'a' ),
						classes = [];

					anchor.setAttribute( 'href', '#' );
					anchor.appendChild( document.createTextNode( text ) );

					// Are we inside an optgroup?
					if ( parent !== select && parent.nodeName.toLowerCase() === "optgroup" ) {
						var optLabel = parent.getAttribute( 'label' );
						if ( optLabel !== optGroup ) {
							var divider = document.createElement( 'li' );
							divider.setAttribute( dataRoleAttr, 'list-divider' );
							divider.setAttribute( 'role', 'option' );
							divider.setAttribute( 'tabindex', '-1' );
							divider.appendChild( document.createTextNode( optLabel ) );
							fragment.appendChild( divider );
							optGroup = optLabel;
						}
					}

					if ( needPlaceholder && ( !option.getAttribute( "value" ) || text.length === 0 || $option.jqmData( "placeholder" ) ) ) {
						needPlaceholder = false;
						isPlaceholderItem = true;

						// If we have identified a placeholder, record the fact that it was
						// us who have added the placeholder to the option and mark it
						// retroactively in the select as well
						if ( null === option.getAttribute( dataPlaceholderAttr ) ) {
							this._removePlaceholderAttr = true;
						}
						option.setAttribute( dataPlaceholderAttr, true );
						if ( o.hidePlaceholderMenuItems ) {
							classes.push( "ui-selectmenu-placeholder" );
						}
						if ( placeholder !== text ) {
							placeholder = self.placeholder = text;
						}
					}

					var item = document.createElement('li');
					if ( option.disabled ) {
						classes.push( "ui-disabled" );
						item.setAttribute('aria-disabled',true);
					}
					item.setAttribute( dataIndexAttr,i );
					item.setAttribute( dataIconAttr, dataIcon );
					if ( isPlaceholderItem ) {
						item.setAttribute( dataPlaceholderAttr, true );
					}
					item.className = classes.join( " " );
					item.setAttribute( 'role', 'option' );
					anchor.setAttribute( 'tabindex', '-1' );
					item.appendChild( anchor );
					fragment.appendChild( item );
				}

				self.list[0].appendChild( fragment );

				// Hide header if it's not a multiselect and there's no placeholder
				if ( !this.isMultiple && !placeholder.length ) {
					this.header.hide();
				} else {
					this.headerTitle.text( this.placeholder );
				}

				// Now populated, create listview
				self.list.listview();
			},

			_button: function() {
				return $( "<a>", {
					"href": "#",
					"role": "button",
					// TODO value is undefined at creation
					"id": this.buttonId,
					"aria-haspopup": "true",

					// TODO value is undefined at creation
					"aria-owns": this.menuId
				});
			},

			_destroy: function() {
				this.close();

				// Restore the tabindex attribute to its original value
				if ( this._origTabIndex !== undefined ) {
					if ( this._origTabIndex !== false ) {
						this.select.attr( "tabindex", this._origTabIndex );
					} else {
						this.select.removeAttr( "tabindex" );
					}
				}

				// Remove the placeholder attribute if we were the ones to add it
				if ( this._removePlaceholderAttr ) {
					this._selectOptions().removeAttr( "data-" + $.mobile.ns + "placeholder" );
				}

				// Remove the popup
				this.listbox.remove();

				// Chain up
				origDestroy.apply( this, arguments );
			}
		});
	};

	// issue #3894 - core doesn't trigger events on disabled delegates
	$.mobile.document.bind( "selectmenubeforecreate", function( event ) {
		var selectmenuWidget = $( event.target ).data( "mobile-selectmenu" );

		if ( !selectmenuWidget.options.nativeMenu &&
				selectmenuWidget.element.parents( ":jqmData(role='popup')" ).length === 0 ) {
			extendSelect( selectmenuWidget );
		}
	});
})( jQuery );

(function( $, undefined ) {

	$.widget( "mobile.controlgroup", $.mobile.widget, $.extend( {
		options: {
			shadow: false,
			corners: true,
			excludeInvisible: true,
			type: "vertical",
			mini: false,
			initSelector: ":jqmData(role='controlgroup')"
		},

		_create: function() {
			var $el = this.element,
				ui = {
					inner: $( "<div class='ui-controlgroup-controls'></div>" ),
					legend: $( "<div role='heading' class='ui-controlgroup-label'></div>" )
				},
				grouplegend = $el.children( "legend" ),
				self = this;

			// Apply the proto
			$el.wrapInner( ui.inner );
			if ( grouplegend.length ) {
				ui.legend.append( grouplegend ).insertBefore( $el.children( 0 ) );
			}
			$el.addClass( "ui-corner-all ui-controlgroup" );

			$.extend( this, {
				_initialRefresh: true
			});

			$.each( this.options, function( key, value ) {
				// Cause initial options to be applied by their handler by temporarily setting the option to undefined
				// - the handler then sets it to the initial value
				self.options[ key ] = undefined;
				self._setOption( key, value, true );
			});
		},

		_init: function() {
			this.refresh();
		},

		_setOption: function( key, value ) {
			var setter = "_set" + key.charAt( 0 ).toUpperCase() + key.slice( 1 );

			if ( this[ setter ] !== undefined ) {
				this[ setter ]( value );
			}

			this._super( key, value );
			this.element.attr( "data-" + ( $.mobile.ns || "" ) + ( key.replace( /([A-Z])/, "-$1" ).toLowerCase() ), value );
		},

		_setType: function( value ) {
			this.element
				.removeClass( "ui-controlgroup-horizontal ui-controlgroup-vertical" )
				.addClass( "ui-controlgroup-" + value );
			this.refresh();
		},

		_setCorners: function( value ) {
			this.element.toggleClass( "ui-corner-all", value );
		},

		_setShadow: function( value ) {
			this.element.toggleClass( "ui-shadow", value );
		},

		_setMini: function( value ) {
			this.element.toggleClass( "ui-mini", value );
		},

		container: function() {
			return this.element.children( ".ui-controlgroup-controls" );
		},

		refresh: function() {
			var els = this.element.find( ".ui-btn" ).not( ".ui-slider-handle" ),
				create = this._initialRefresh;
			if ( $.mobile.checkboxradio ) {
				this.element.find( ":mobile-checkboxradio" ).checkboxradio( "refresh" );
			}
			this._addFirstLastClasses( els, this.options.excludeInvisible ? this._getVisibles( els, create ) : els, create );
			this._initialRefresh = false;
		}
	}, $.mobile.behaviors.addFirstLastClasses ) );

	// TODO: Implement a mechanism to allow widgets to become enhanced in the
	// correct order when their correct enhancement depends on other widgets in
	// the page being correctly enhanced already.
	//
	// For now, we wait until dom-ready to attach the controlgroup's enhancement
	// hook, because by that time, all the other widgets' enhancement hooks should
	// already be in place, ensuring that all widgets that need to be grouped will
	// already have been enhanced by the time the controlgroup is created.
	$( function() {
		$.mobile.document.bind( "pagecreate create", function( e )  {
			$.mobile.controlgroup.prototype.enhanceWithin( e.target, true );
		});
	});
})(jQuery);

(function( $, undefined ) {

$( document ).bind( "pagecreate create", function( e ) {

	//links within content areas, tests included with page
	$( e.target )
		.find( "a" )
		.jqmEnhanceable()
		.not( ".ui-btn, .ui-link-inherit, :jqmData(role='none'), :jqmData(role='nojs')" )
		.addClass( "ui-link" );

});

})( jQuery );


(function( $, undefined ) {


	$.widget( "mobile.fixedtoolbar", $.mobile.widget, {
		options: {
			visibleOnPageShow: true,
			disablePageZoom: true,
			transition: "slide", //can be none, fade, slide (slide maps to slideup or slidedown)
			fullscreen: false,
			tapToggle: true,
			tapToggleBlacklist: "a, button, input, select, textarea, .ui-header-fixed, .ui-footer-fixed, .ui-popup, .ui-panel, .ui-panel-dismiss-open",
			hideDuringFocus: "input, textarea, select",
			updatePagePadding: true,
			trackPersistentToolbars: true,

			// Browser detection! Weeee, here we go...
			// Unfortunately, position:fixed is costly, not to mention probably impossible, to feature-detect accurately.
			// Some tests exist, but they currently return false results in critical devices and browsers, which could lead to a broken experience.
			// Testing fixed positioning is also pretty obtrusive to page load, requiring injected elements and scrolling the window
			// The following function serves to rule out some popular browsers with known fixed-positioning issues
			// This is a plugin option like any other, so feel free to improve or overwrite it
			supportBlacklist: function() {
				return !$.support.fixedPosition;
			},
			initSelector: ":jqmData(position='fixed')"
		},

		_create: function() {

			var self = this,
				o = self.options,
				$el = self.element,
				tbtype = $el.is( ":jqmData(role='header')" ) ? "header" : "footer",
				$page = $el.closest( ".ui-page" );

			// Feature detecting support for
			if ( o.supportBlacklist() ) {
				self.destroy();
				return;
			}

			$el.addClass( "ui-"+ tbtype +"-fixed" );

			// "fullscreen" overlay positioning
			if ( o.fullscreen ) {
				$el.addClass( "ui-"+ tbtype +"-fullscreen" );
				$page.addClass( "ui-page-" + tbtype + "-fullscreen" );
			}
			// If not fullscreen, add class to page to set top or bottom padding
			else{
				$page.addClass( "ui-page-" + tbtype + "-fixed" );
			}

			$.extend( this, {
				_thisPage: null
			});
 
			self._addTransitionClass();
			self._bindPageEvents();
			self._bindToggleHandlers();
		},

		_addTransitionClass: function() {
			var tclass = this.options.transition;

			if ( tclass && tclass !== "none" ) {
				// use appropriate slide for header or footer
				if ( tclass === "slide" ) {
					tclass = this.element.is( ".ui-header" ) ? "slidedown" : "slideup";
				}

				this.element.addClass( tclass );
			}
		},

		_bindPageEvents: function() {
			this._thisPage = this.element.closest( ".ui-page" );
			//page event bindings
			// Fixed toolbars require page zoom to be disabled, otherwise usability issues crop up
			// This method is meant to disable zoom while a fixed-positioned toolbar page is visible
			this._on( this._thisPage, {
				"pagebeforeshow": "_handlePageBeforeShow",
				"webkitAnimationStart":"_handleAnimationStart",
				"animationstart":"_handleAnimationStart",
				"updatelayout": "_handleAnimationStart",
				"pageshow": "_handlePageShow",
				"pagebeforehide": "_handlePageBeforeHide"
			});
		},

		_handlePageBeforeShow: function() {
			var o = this.options;
			if ( o.disablePageZoom ) {
				$.mobile.zoom.disable( true );
			}
			if ( !o.visibleOnPageShow ) {
				this.hide( true );
			}
		},

		_handleAnimationStart: function() {
			if ( this.options.updatePagePadding ) {
				this.updatePagePadding( this._thisPage );
			}
		},

		_handlePageShow: function() {
			this.updatePagePadding( this._thisPage );
			if ( this.options.updatePagePadding ) {
				this._on( $.mobile.window, { "throttledresize": "updatePagePadding" } );
			}
		},

		_handlePageBeforeHide: function( e, ui ) {
			var o = this.options;

			if ( o.disablePageZoom ) {
				$.mobile.zoom.enable( true );
			}
			if ( o.updatePagePadding ) {
				this._off( $.mobile.window, "throttledresize" );
			}

			if ( o.trackPersistentToolbars ) {
				var thisFooter = $( ".ui-footer-fixed:jqmData(id)", this._thisPage ),
					thisHeader = $( ".ui-header-fixed:jqmData(id)", this._thisPage ),
					nextFooter = thisFooter.length && ui.nextPage && $( ".ui-footer-fixed:jqmData(id='" + thisFooter.jqmData( "id" ) + "')", ui.nextPage ) || $(),
					nextHeader = thisHeader.length && ui.nextPage && $( ".ui-header-fixed:jqmData(id='" + thisHeader.jqmData( "id" ) + "')", ui.nextPage ) || $();

				if ( nextFooter.length || nextHeader.length ) {

					nextFooter.add( nextHeader ).appendTo( $.mobile.pageContainer );

					ui.nextPage.one( "pageshow", function() {
						nextHeader.prependTo( this );
						nextFooter.appendTo( this );
					});
				}
			}
		},

		_visible: true,

		// This will set the content element's top or bottom padding equal to the toolbar's height
		updatePagePadding: function( tbPage ) {
			var $el = this.element,
				header = $el.is( ".ui-header" ),
				pos = parseFloat( $el.css( header ? "top" : "bottom" ) );

			// This behavior only applies to "fixed", not "fullscreen"
			if ( this.options.fullscreen ) { return; }

			// tbPage argument can be a Page object or an event, if coming from throttled resize. 
			tbPage = ( tbPage && tbPage.type === undefined && tbPage ) || this._thisPage || $el.closest( ".ui-page" );
			$( tbPage ).css( "padding-" + ( header ? "top" : "bottom" ), $el.outerHeight() + pos );
		},

		_useTransition: function( notransition ) {
			var $win = $.mobile.window,
				$el = this.element,
				scroll = $win.scrollTop(),
				elHeight = $el.height(),
				pHeight = $el.closest( ".ui-page" ).height(),
				viewportHeight = $.mobile.getScreenHeight(),
				tbtype = $el.is( ":jqmData(role='header')" ) ? "header" : "footer";

			return !notransition &&
				( this.options.transition && this.options.transition !== "none" &&
				(
					( tbtype === "header" && !this.options.fullscreen && scroll > elHeight ) ||
					( tbtype === "footer" && !this.options.fullscreen && scroll + viewportHeight < pHeight - elHeight )
				) || this.options.fullscreen
				);
		},

		show: function( notransition ) {
			var hideClass = "ui-fixed-hidden",
				$el = this.element;

			if ( this._useTransition( notransition ) ) {
				$el
					.removeClass( "out " + hideClass )
					.addClass( "in" )
					.animationComplete(function () {
						$el.removeClass('in');
					});
			}
			else {
				$el.removeClass( hideClass );
			}
			this._visible = true;
		},

		hide: function( notransition ) {
			var hideClass = "ui-fixed-hidden",
				$el = this.element,
				// if it's a slide transition, our new transitions need the reverse class as well to slide outward
				outclass = "out" + ( this.options.transition === "slide" ? " reverse" : "" );

			if( this._useTransition( notransition ) ) {
				$el
					.addClass( outclass )
					.removeClass( "in" )
					.animationComplete(function() {
						$el.addClass( hideClass ).removeClass( outclass );
					});
			}
			else {
				$el.addClass( hideClass ).removeClass( outclass );
			}
			this._visible = false;
		},

		toggle: function() {
			this[ this._visible ? "hide" : "show" ]();
		},

		_bindToggleHandlers: function() {
			var self = this,
				o = self.options,
				$el = self.element,
				delayShow, delayHide,
				isVisible = true;

			// tap toggle
			$el.closest( ".ui-page" )
				.bind( "vclick", function( e ) {
					if ( o.tapToggle && !$( e.target ).closest( o.tapToggleBlacklist ).length ) {
						self.toggle();
					}
				})
				.bind( "focusin focusout", function( e ) {
					//this hides the toolbars on a keyboard pop to give more screen room and prevent ios bug which 
					//positions fixed toolbars in the middle of the screen on pop if the input is near the top or
					//bottom of the screen addresses issues #4410 Footer navbar moves up when clicking on a textbox in an Android environment
					//and issue #4113 Header and footer change their position after keyboard popup - iOS
					//and issue #4410 Footer navbar moves up when clicking on a textbox in an Android environment
					if ( screen.width < 1025 && $( e.target ).is( o.hideDuringFocus ) && !$( e.target ).closest( ".ui-header-fixed, .ui-footer-fixed" ).length ) {
						//Fix for issue #4724 Moving through form in Mobile Safari with "Next" and "Previous" system 
						//controls causes fixed position, tap-toggle false Header to reveal itself
						// isVisible instead of self._visible because the focusin and focusout events fire twice at the same time
						// Also use a delay for hiding the toolbars because on Android native browser focusin is direclty followed
						// by a focusout when a native selects opens and the other way around when it closes.
						if ( e.type === "focusout" && !isVisible ) {
							isVisible = true;
							//wait for the stack to unwind and see if we have jumped to another input
							clearTimeout( delayHide );
							delayShow = setTimeout( function() {
								self.show();
							}, 0 ); 
						} else if ( e.type === "focusin" && !!isVisible ) {
							//if we have jumped to another input clear the time out to cancel the show.
							clearTimeout( delayShow );
							isVisible = false;
							delayHide = setTimeout( function() {
								self.hide();
							}, 0 ); 
						}
					}
				});
		},

		_destroy: function() {
			var $el = this.element,
				header = $el.is( ".ui-header" );

			$el.closest( ".ui-page" ).css( "padding-" + ( header ? "top" : "bottom" ), "" );
			$el.removeClass( "ui-header-fixed ui-footer-fixed ui-header-fullscreen ui-footer-fullscreen in out fade slidedown slideup ui-fixed-hidden" );
			$el.closest( ".ui-page" ).removeClass( "ui-page-header-fixed ui-page-footer-fixed ui-page-header-fullscreen ui-page-footer-fullscreen" );
		}

	});

	//auto self-init widgets
	$.mobile.document
		.bind( "pagecreate create", function( e ) {

			// DEPRECATED in 1.1: support for data-fullscreen=true|false on the page element.
			// This line ensures it still works, but we recommend moving the attribute to the toolbars themselves.
			if ( $( e.target ).jqmData( "fullscreen" ) ) {
				$( $.mobile.fixedtoolbar.prototype.options.initSelector, e.target ).not( ":jqmData(fullscreen)" ).jqmData( "fullscreen", true );
			}

			$.mobile.fixedtoolbar.prototype.enhanceWithin( e.target );
		});

})( jQuery );

(function( $, undefined ) {
	$.widget( "mobile.fixedtoolbar", $.mobile.fixedtoolbar, {

			_create: function() {
				this._super();
				this._workarounds();
			},

			//check the browser and version and run needed workarounds
			_workarounds: function() {
				var ua = navigator.userAgent,
				platform = navigator.platform,
				// Rendering engine is Webkit, and capture major version
				wkmatch = ua.match( /AppleWebKit\/([0-9]+)/ ),
				wkversion = !!wkmatch && wkmatch[ 1 ],
				os = null,
				self = this;
				//set the os we are working in if it dosent match one with workarounds return
				if( platform.indexOf( "iPhone" ) > -1 || platform.indexOf( "iPad" ) > -1  || platform.indexOf( "iPod" ) > -1 ){
					os = "ios";
				} else if( ua.indexOf( "Android" ) > -1 ){
					os = "android";
				} else {
					return;
				}
				//check os version if it dosent match one with workarounds return
				if( os === "ios" ) {
					//iOS  workarounds
					self._bindScrollWorkaround();
				} else if( os === "android" && wkversion && wkversion < 534 ) {
					//Android 2.3 run all Android 2.3 workaround
					self._bindScrollWorkaround();
					self._bindListThumbWorkaround();
				} else {
					return;
				}
			},

			//Utility class for checking header and footer positions relative to viewport
			_viewportOffset: function() {
				var $el = this.element,
					header = $el.is( ".ui-header" ),
					offset = Math.abs($el.offset().top - $.mobile.window.scrollTop());
				if( !header ) {
					offset = Math.round(offset - $.mobile.window.height() + $el.outerHeight())-60;
				}
				return offset;
			},

			//bind events for _triggerRedraw() function 
			_bindScrollWorkaround: function() {
				var self = this;
				//bind to scrollstop and check if the toolbars are correctly positioned
				this._on( $.mobile.window, { scrollstop: function() {
					var viewportOffset = self._viewportOffset();
					//check if the header is visible and if its in the right place
					if( viewportOffset > 2 && self._visible) {
						self._triggerRedraw();
					}
				}});
			},

			//this addresses issue #4250 Persistent footer instability in v1.1 with long select lists in Android 2.3.3
			//and issue #3748 Android 2.x: Page transitions broken when fixed toolbars used
			//the absolutely positioned thumbnail in a list view causes problems with fixed position buttons above in a nav bar
			//setting the li's to -webkit-transform:translate3d(0,0,0); solves this problem to avoide potential issues in other
			//platforms we scope this with the class ui-android-2x-fix
			_bindListThumbWorkaround: function() {
				this.element.closest(".ui-page").addClass( "ui-android-2x-fixed" );
			},
			//this addresses issues #4337 Fixed header problem after scrolling content on iOS and Android
			//and device bugs project issue #1 Form elements can lose click hit area in position: fixed containers.
			//this also addresses not on fixed toolbars page in docs
			//adding 1px of padding to the bottom then removing it causes a "redraw"
			//which positions the toolbars correctly (they will always be visually correct) 
			_triggerRedraw: function() {
				var paddingBottom = parseFloat( $( ".ui-page-active" ).css( "padding-bottom" ) );
				//trigger page redraw to fix incorrectly positioned fixed elements
				$( ".ui-page-active" ).css( "padding-bottom", ( paddingBottom + 1 ) +"px" );
				//if the padding is reset with out a timeout the reposition will not occure.
				//this is independant of JQM the browser seems to need the time to react.
				setTimeout( function() {
					$( ".ui-page-active" ).css( "padding-bottom", paddingBottom + "px" );
				}, 0 );
			},

			destroy: function() {
				this._super();
				//Remove the class we added to the page previously in android 2.x 
				this.element.closest(".ui-page-active").removeClass( "ui-android-2x-fix" );
			}
	});

	})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.panel", $.mobile.widget, {
	options: {
		classes: {
			panel: "ui-panel",
			panelOpen: "ui-panel-open",
			panelClosed: "ui-panel-closed",
			panelFixed: "ui-panel-fixed",
			panelInner: "ui-panel-inner",
			modal: "ui-panel-dismiss",
			modalOpen: "ui-panel-dismiss-open",
			pagePanel: "ui-page-panel",
			pagePanelOpen: "ui-page-panel-open",
			contentWrap: "ui-panel-content-wrap",
			contentWrapOpen: "ui-panel-content-wrap-open",
			contentWrapClosed: "ui-panel-content-wrap-closed",
			contentFixedToolbar: "ui-panel-content-fixed-toolbar",
			contentFixedToolbarOpen: "ui-panel-content-fixed-toolbar-open",
			contentFixedToolbarClosed: "ui-panel-content-fixed-toolbar-closed",
			animate: "ui-panel-animate"
		},
		animate: true,
		theme: "c",
		position: "left",
		dismissible: true,
		display: "reveal", //accepts reveal, push, overlay
		initSelector: ":jqmData(role='panel')",
		swipeClose: true,
		positionFixed: false
	},

	_panelID: null,
	_closeLink: null,
	_page: null,
	_modal: null,
	_panelInner: null,
	_wrapper: null,
	_fixedToolbar: null,

	_create: function() {
		var self = this,
			$el = self.element,
			page = $el.closest( ":jqmData(role='page')" ),
			_getPageTheme = function() {
				var $theme = $.data( page[0], "mobile-page" ).options.theme,
				$pageThemeClass = "ui-body-" + $theme;
				return $pageThemeClass;
			},
			_getPanelInner = function() {
				var $panelInner = $el.find( "." + self.options.classes.panelInner );
				if ( $panelInner.length === 0 ) {
					$panelInner = $el.children().wrapAll( '<div class="' + self.options.classes.panelInner + '" />' ).parent();
				}
				return $panelInner;
			},
			_getWrapper = function() {
				var $wrapper = page.find( "." + self.options.classes.contentWrap );
				if ( $wrapper.length === 0 ) {
					$wrapper = page.children( ".ui-header:not(:jqmData(position='fixed')), .ui-content:not(:jqmData(role='popup')), .ui-footer:not(:jqmData(position='fixed'))" ).wrapAll( '<div class="' + self.options.classes.contentWrap + ' ' + _getPageTheme() + '" />' ).parent();
					if ( $.support.cssTransform3d && !!self.options.animate ) {
						$wrapper.addClass( self.options.classes.animate );
					}
				}
				return $wrapper;
			},
			_getFixedToolbar = function() {
				var $fixedToolbar = page.find( "." + self.options.classes.contentFixedToolbar );
				if ( $fixedToolbar.length === 0 ) {
					$fixedToolbar = page.find( ".ui-header:jqmData(position='fixed'), .ui-footer:jqmData(position='fixed')" ).addClass( self.options.classes.contentFixedToolbar );
					if ( $.support.cssTransform3d && !!self.options.animate ) {
						$fixedToolbar.addClass( self.options.classes.animate );
					}
				}
				return $fixedToolbar;
			};

		// expose some private props to other methods
		$.extend( this, {
			_panelID: $el.attr( "id" ),
			_closeLink: $el.find( ":jqmData(rel='close')" ),
			_page: $el.closest( ":jqmData(role='page')" ),
			_pageTheme: _getPageTheme(),
			_panelInner: _getPanelInner(),
			_wrapper: _getWrapper(),
			_fixedToolbar: _getFixedToolbar()
		});
		
		self._addPanelClasses();
		self._wrapper.addClass( this.options.classes.contentWrapClosed );
		self._fixedToolbar.addClass( this.options.classes.contentFixedToolbarClosed );
		// add class to page so we can set "overflow-x: hidden;" for it to fix Android zoom issue
		self._page.addClass( self.options.classes.pagePanel );
		
		// if animating, add the class to do so
		if ( $.support.cssTransform3d && !!self.options.animate ) {
			this.element.addClass( self.options.classes.animate );
		}
		
		self._bindUpdateLayout();
		self._bindCloseEvents();
		self._bindLinkListeners();
		self._bindPageEvents();

		if ( !!self.options.dismissible ) {
			self._createModal();
		}

		self._bindSwipeEvents();
	},

	_createModal: function( options ) {
		var self = this;
		
		self._modal = $( "<div class='" + self.options.classes.modal + "' data-panelid='" + self._panelID + "'></div>" )
			.on( "mousedown", function() {
				self.close();
			})
			.appendTo( this._page );
	},

	_getPosDisplayClasses: function( prefix ) {
		return prefix + "-position-" + this.options.position + " " + prefix + "-display-" + this.options.display;
	},

	_getPanelClasses: function() {
		var panelClasses = this.options.classes.panel +
			" " + this._getPosDisplayClasses( this.options.classes.panel ) +
			" " + this.options.classes.panelClosed;

		if ( this.options.theme ) {
			panelClasses += " ui-body-" + this.options.theme;
		}
		if ( !!this.options.positionFixed ) {
			panelClasses += " " + this.options.classes.panelFixed;
		}
		return panelClasses;
	},

	_addPanelClasses: function() {
		this.element.addClass( this._getPanelClasses() );
	},

	_bindCloseEvents: function() {
		var self = this;
		
		self._closeLink.on( "click.panel" , function( e ) {
			e.preventDefault();
			self.close();
			return false;
		});
		self.element.on( "click.panel" , "a:jqmData(ajax='false')", function( e ) {
			self.close();
		});		
	},

	_positionPanel: function() {
		var self = this,
			panelInnerHeight = self._panelInner.outerHeight(),
			expand = panelInnerHeight > $.mobile.getScreenHeight();

		if ( expand || !self.options.positionFixed ) {
			if ( expand ) {
				self._unfixPanel();
				$.mobile.resetActivePageHeight( panelInnerHeight );
			}
			self._scrollIntoView( panelInnerHeight );
		} else {
			self._fixPanel();
		}
	},

	_scrollIntoView: function( panelInnerHeight ) {
		if ( panelInnerHeight < $( window ).scrollTop() ) {
			window.scrollTo( 0, 0 );
		}	
	},

	_bindFixListener: function() {
		this._on( $( window ), { "throttledresize": "_positionPanel" });
	},

	_unbindFixListener: function() {
		this._off( $( window ), "throttledresize" );
	},

	_unfixPanel: function() {
		if ( !!this.options.positionFixed && $.support.fixedPosition ) {
			this.element.removeClass( this.options.classes.panelFixed );
		}
	},

	_fixPanel: function() {
		if ( !!this.options.positionFixed && $.support.fixedPosition ) {
			this.element.addClass( this.options.classes.panelFixed );
		}
	},
	
	_bindUpdateLayout: function() {
		var self = this;
		
		self.element.on( "updatelayout", function( e ) {
			if ( self._open ) {
				self._positionPanel();
			}
		});
	},

	_bindLinkListeners: function() {
		var self = this;

		self._page.on( "click.panel" , "a", function( e ) {
			if ( this.href.split( "#" )[ 1 ] === self._panelID && self._panelID !== undefined ) {
				e.preventDefault();
				var $link = $( this );
				if ( ! $link.hasClass( "ui-link" ) ) {
					$link.addClass( $.mobile.activeBtnClass );
					self.element.one( "panelopen panelclose", function() {
						$link.removeClass( $.mobile.activeBtnClass );
					});
				}
				self.toggle();
				return false;
			}
		});
	},
	
	_bindSwipeEvents: function() {
		var self = this,
			area = self._modal ? self.element.add( self._modal ) : self.element;
		
		// on swipe, close the panel
		if( !!self.options.swipeClose ) {
			if ( self.options.position === "left" ) {
				area.on( "swipeleft.panel", function( e ) {
					self.close();
				});
			} else {
				area.on( "swiperight.panel", function( e ) {
					self.close();
				});
			}
		}
	},

	_bindPageEvents: function() {
		var self = this;
			
		self._page
			// Close the panel if another panel on the page opens
			.on( "panelbeforeopen", function( e ) {
				if ( self._open && e.target !== self.element[ 0 ] ) {
					self.close();
				}
			})
			// clean up open panels after page hide
			.on( "pagehide", function( e ) {
				if ( self._open ) {
					self.close( true );
				}
			})
			// on escape, close? might need to have a target check too...
			.on( "keyup.panel", function( e ) {
				if ( e.keyCode === 27 && self._open ) {
					self.close();
				}
			});
	},

	// state storage of open or closed
	_open: false,

	_contentWrapOpenClasses: null,
	_fixedToolbarOpenClasses: null,
	_modalOpenClasses: null,

	open: function( immediate ) {
		if ( !this._open ) {
			var self = this,
				o = self.options,
				_openPanel = function() {
					self._page.off( "panelclose" );
					self._page.jqmData( "panel", "open" );
					
					if ( !immediate && $.support.cssTransform3d && !!o.animate ) {
						self.element.add( self._wrapper ).on( self._transitionEndEvents, complete );
					} else {
						setTimeout( complete, 0 );
					}
					
					if ( self.options.theme && self.options.display !== "overlay" ) {
						self._page
							.removeClass( self._pageTheme )
							.addClass( "ui-body-" + self.options.theme );
					}
					
					self.element.removeClass( o.classes.panelClosed ).addClass( o.classes.panelOpen );
					
					self._positionPanel();
					
					// Fix for IE7 min-height bug
					if ( self.options.theme && self.options.display !== "overlay" ) {
						self._wrapper.css( "min-height", self._page.css( "min-height" ) );
					}
					
					self._contentWrapOpenClasses = self._getPosDisplayClasses( o.classes.contentWrap );
					self._wrapper
						.removeClass( o.classes.contentWrapClosed )
						.addClass( self._contentWrapOpenClasses + " " + o.classes.contentWrapOpen );
						
					self._fixedToolbarOpenClasses = self._getPosDisplayClasses( o.classes.contentFixedToolbar );
					self._fixedToolbar
						.removeClass( o.classes.contentFixedToolbarClosed )
						.addClass( self._fixedToolbarOpenClasses + " " + o.classes.contentFixedToolbarOpen );
						
					self._modalOpenClasses = self._getPosDisplayClasses( o.classes.modal ) + " " + o.classes.modalOpen;
					if ( self._modal ) {
						self._modal.addClass( self._modalOpenClasses );
					}
				},
				complete = function() {
					self.element.add( self._wrapper ).off( self._transitionEndEvents, complete );

					self._page.addClass( o.classes.pagePanelOpen );
					
					self._bindFixListener();
					
					self._trigger( "open" );
				};

			if ( this.element.closest( ".ui-page-active" ).length < 0 ) {
				immediate = true;
			}
			
			self._trigger( "beforeopen" );
			
			if ( self._page.jqmData('panel') === "open" ) {
				self._page.on( "panelclose", function() {
					_openPanel();
				});
			} else {
				_openPanel();
			}
			
			self._open = true;
		}
	},

	close: function( immediate ) {
		if ( this._open ) {
			var o = this.options,
				self = this,
				_closePanel = function() {
					if ( !immediate && $.support.cssTransform3d && !!o.animate ) {
						self.element.add( self._wrapper ).on( self._transitionEndEvents, complete );
					} else {
						setTimeout( complete, 0 );
					}
					
					self._page.removeClass( o.classes.pagePanelOpen );
					self.element.removeClass( o.classes.panelOpen );
					self._wrapper.removeClass( o.classes.contentWrapOpen );
					self._fixedToolbar.removeClass( o.classes.contentFixedToolbarOpen );
					
					if ( self._modal ) {
						self._modal.removeClass( self._modalOpenClasses );
					}
				},
				complete = function() {
					if ( self.options.theme && self.options.display !== "overlay" ) {
						self._page.removeClass( "ui-body-" + self.options.theme ).addClass( self._pageTheme );
						// reset fix for IE7 min-height bug
						self._wrapper.css( "min-height", "" );
					}
					self.element.add( self._wrapper ).off( self._transitionEndEvents, complete );
					self.element.addClass( o.classes.panelClosed );
					
					self._wrapper
						.removeClass( self._contentWrapOpenClasses )
						.addClass( o.classes.contentWrapClosed );
						
					self._fixedToolbar
						.removeClass( self._fixedToolbarOpenClasses )
						.addClass( o.classes.contentFixedToolbarClosed );
						
					self._fixPanel();
					self._unbindFixListener();
					$.mobile.resetActivePageHeight();
					
					self._page.jqmRemoveData( "panel" );
					self._trigger( "close" );
				};
				
			if ( this.element.closest( ".ui-page-active" ).length < 0 ) {
				immediate = true;
			}
			self._trigger( "beforeclose" );

			_closePanel();

			self._open = false;
		}
	},
	
	toggle: function( options ) {
		this[ this._open ? "close" : "open" ]();
	},

	_transitionEndEvents: "webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd",

	_destroy: function() {
		var classes = this.options.classes,
			theme = this.options.theme,
			hasOtherSiblingPanels = this.element.siblings( "." + classes.panel ).length;

		// create
		if ( !hasOtherSiblingPanels ) {
			this._wrapper.children().unwrap();
			this._page.find( "a" ).unbind( "panelopen panelclose" );
			this._page.removeClass( classes.pagePanel );
			if ( this._open ) {
				this._page.jqmRemoveData( "panel" );
				this._page.removeClass( classes.pagePanelOpen );
				if ( theme ) {
					this._page.removeClass( "ui-body-" + theme ).addClass( this._pageTheme );
				}
				$.mobile.resetActivePageHeight();
			}
		} else if ( this._open ) {
			this._wrapper.removeClass( classes.contentWrapOpen );
			this._fixedToolbar.removeClass( classes.contentFixedToolbarOpen );
			this._page.jqmRemoveData( "panel" );
			this._page.removeClass( classes.pagePanelOpen );
			if ( theme ) {
				this._page.removeClass( "ui-body-" + theme ).addClass( this._pageTheme );
			}
		}
		
		this._panelInner.children().unwrap();

		this.element.removeClass( [ this._getPanelClasses(), classes.panelAnimate ].join( " " ) )
			.off( "swipeleft.panel swiperight.panel" )
			.off( "panelbeforeopen" )
			.off( "panelhide" )
			.off( "keyup.panel" )
			.off( "updatelayout" );

		this._closeLink.off( "click.panel" );

		if ( this._modal ) {
			this._modal.remove();
		}

		// open and close
		this.element.off( this._transitionEndEvents )
			.removeClass( [ classes.panelUnfixed, classes.panelClosed, classes.panelOpen ].join( " " ) );
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ) {
	$.mobile.panel.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.table", $.mobile.widget, {

		options: {
			classes: {
				table: "ui-table"
			},
			initSelector: ":jqmData(role='table')"
		},

		_create: function() {
			var self = this;
			self.refresh( true );
		},

		refresh: function (create) {
			var self = this,
				trs = this.element.find( "thead tr" );

			if ( create ) {
				this.element.addClass( this.options.classes.table );
			}

			// Expose headers and allHeaders properties on the widget
			// headers references the THs within the first TR in the table
			self.headers = this.element.find( "tr:eq(0)" ).children();

			// allHeaders references headers, plus all THs in the thead, which may include several rows, or not
			self.allHeaders = self.headers.add( trs.children() );

			trs.each(function(){

				var coltally = 0;

				$( this ).children().each(function( i ){

					var span = parseInt( $( this ).attr( "colspan" ), 10 ),
						sel = ":nth-child(" + ( coltally + 1 ) + ")";
					$( this )
						.jqmData( "colstart", coltally + 1 );

					if( span ){
						for( var j = 0; j < span - 1; j++ ){
							coltally++;
							sel += ", :nth-child(" + ( coltally + 1 ) + ")";
						}
					}

					if ( create === undefined ) {
						$(this).jqmData("cells", "");
					}
					// Store "cells" data on header as a reference to all cells in the same column as this TH
					$( this )
						.jqmData( "cells", self.element.find( "tr" ).not( trs.eq(0) ).not( this ).children( sel ) );

					coltally++;

				});

			});

			// update table modes
			if ( create === undefined ) {
				this.element.trigger( 'refresh' );
			}
	}

});

//auto self-init widgets
$.mobile.document.bind( "pagecreate create", function( e ) {
	$.mobile.table.prototype.enhanceWithin( e.target );
});

})( jQuery );


(function( $, undefined ) {

$.mobile.table.prototype.options.mode = "columntoggle";

$.mobile.table.prototype.options.columnBtnTheme = null;

$.mobile.table.prototype.options.columnPopupTheme = null;

$.mobile.table.prototype.options.columnBtnText = "Columns...";

$.mobile.table.prototype.options.classes = $.extend(
	$.mobile.table.prototype.options.classes,
	{
		popup: "ui-table-columntoggle-popup",
		columnBtn: "ui-table-columntoggle-btn",
		priorityPrefix: "ui-table-priority-",
		columnToggleTable: "ui-table-columntoggle"
	}
);

$.mobile.document.delegate( ":jqmData(role='table')", "tablecreate refresh", function( e ) {
	
	var $table = $( this ),
		self = $table.data( "mobile-table" ),
		event = e.type,
		o = self.options,
		ns = $.mobile.ns,
		id = ( $table.attr( "id" ) || o.classes.popup ) + "-popup", /* TODO BETTER FALLBACK ID HERE */
		$menuButton,
		$popup,
		$menu,
		$switchboard;

	if ( o.mode !== "columntoggle" ) {
		return;
	}

	if ( event !== "refresh" ) {
		self.element.addClass( o.classes.columnToggleTable );
	
		$menuButton = $( "<a href='#" + id + "' class='" + o.classes.columnBtn + "' data-" + ns + "rel='popup' data-" + ns + "mini='true'>" + o.columnBtnText + "</a>" ),
		$popup = $( "<div data-" + ns + "role='popup' data-" + ns + "role='fieldcontain' class='" + o.classes.popup + "' id='" + id + "'></div>"),
		$menu = $("<fieldset data-" + ns + "role='controlgroup'></fieldset>");
	}
	
	// create the hide/show toggles
	self.headers.not( "td" ).each(function( i ) {

		var priority = $( this ).jqmData( "priority" ),
			$cells = $( this ).add( $( this ).jqmData( "cells" ) );

		if ( priority ) {

			$cells.addClass( o.classes.priorityPrefix + priority );

			if ( event !== "refresh" ) {
				$("<label><input type='checkbox' checked />" + $( this ).text() + "</label>" )
					.appendTo( $menu )
					.children( 0 )
					.jqmData( "cells", $cells )
					.checkboxradio({
						theme: o.columnPopupTheme
					});
			} else {
				$( '#' + id + ' fieldset div:eq(' + i +')').find('input').jqmData( 'cells', $cells );
			}
		}
	});
	
	if ( event !== "refresh" ) {
		$menu.appendTo( $popup );
	}

	// bind change event listeners to inputs - TODO: move to a private method?
	if ( $menu === undefined ) {
		$switchboard = $('#' + id + ' fieldset');
	} else {
		$switchboard = $menu;
	}

	if ( event !== "refresh" ) {
		$switchboard.on( "change", "input", function( e ){
			if( this.checked ){
				$( this ).jqmData( "cells" ).removeClass( "ui-table-cell-hidden" ).addClass( "ui-table-cell-visible" );
			} else {
				$( this ).jqmData( "cells" ).removeClass( "ui-table-cell-visible" ).addClass( "ui-table-cell-hidden" );
			}
		});

		$menuButton
			.insertBefore( $table )
			.buttonMarkup({
				theme: o.columnBtnTheme
			});

		$popup
			.insertBefore( $table )
			.popup();
	}

	// refresh method
	self.update = function(){
		$switchboard.find( "input" ).each( function(){
			if (this.checked) {
				this.checked = $( this ).jqmData( "cells" ).eq(0).css( "display" ) === "table-cell";
				if (event === "refresh") {
					$( this ).jqmData( "cells" ).addClass('ui-table-cell-visible');
				}
			} else {
				$( this ).jqmData( "cells" ).addClass('ui-table-cell-hidden');
			}
			$( this ).checkboxradio( "refresh" );
		});
	};

	$.mobile.window.on( "throttledresize", self.update );

	self.update();

});

})( jQuery );

(function( $, undefined ) {

$.mobile.table.prototype.options.mode = "reflow";

$.mobile.table.prototype.options.classes = $.extend(
	$.mobile.table.prototype.options.classes,
	{
		reflowTable: "ui-table-reflow",
		cellLabels: "ui-table-cell-label"
	}
);

$.mobile.document.delegate( ":jqmData(role='table')", "tablecreate refresh", function( e ) {

	var $table = $( this ),
		event = e.type,
		self = $table.data( "mobile-table" ),
		o = self.options;

	// If it's not reflow mode, return here.
	if( o.mode !== "reflow" ){
		return;
	}

	if ( event !== "refresh" ) {
		self.element.addClass( o.classes.reflowTable );
	}

	// get headers in reverse order so that top-level headers are appended last
	var reverseHeaders =  $( self.allHeaders.get().reverse() );

	// create the hide/show toggles
	reverseHeaders.each(function( i ){
		var $cells = $( this ).jqmData( "cells" ),
			colstart = $( this ).jqmData( "colstart" ),
			hierarchyClass = $cells.not( this ).filter( "thead th" ).length && " ui-table-cell-label-top",
			text = $(this).text();

			if( text !== ""  ){

				if( hierarchyClass ){
					var iteration = parseInt( $( this ).attr( "colspan" ), 10 ),
						filter = "";

					if( iteration ){
						filter = "td:nth-child("+ iteration +"n + " + ( colstart ) +")";
					}
					$cells.filter( filter ).prepend( "<b class='" + o.classes.cellLabels + hierarchyClass + "'>" + text + "</b>"  );
				}
				else {
					$cells.prepend( "<b class='" + o.classes.cellLabels + "'>" + text + "</b>"  );
				}

			}
	});

});

})( jQuery );

(function( $, window ) {

	$.mobile.iosorientationfixEnabled = true;

	// This fix addresses an iOS bug, so return early if the UA claims it's something else.
	var ua = navigator.userAgent;
	if( !( /iPhone|iPad|iPod/.test( navigator.platform ) && /OS [1-5]_[0-9_]* like Mac OS X/i.test( ua ) && ua.indexOf( "AppleWebKit" ) > -1 ) ){
		$.mobile.iosorientationfixEnabled = false;
		return;
	}

	var zoom = $.mobile.zoom,
		evt, x, y, z, aig;

	function checkTilt( e ) {
		evt = e.originalEvent;
		aig = evt.accelerationIncludingGravity;

		x = Math.abs( aig.x );
		y = Math.abs( aig.y );
		z = Math.abs( aig.z );

		// If portrait orientation and in one of the danger zones
		if ( !window.orientation && ( x > 7 || ( ( z > 6 && y < 8 || z < 8 && y > 6 ) && x > 5 ) ) ) {
				if ( zoom.enabled ) {
					zoom.disable();
				}
		}	else if ( !zoom.enabled ) {
				zoom.enable();
		}
	}

	$.mobile.document.on( "mobileinit", function(){
		if( $.mobile.iosorientationfixEnabled ){
			$.mobile.window
				.bind( "orientationchange.iosorientationfix", zoom.enable )
				.bind( "devicemotion.iosorientationfix", checkTilt );
		}
	});

}( jQuery, this ));

(function( $, window, undefined ) {
	var	$html = $( "html" ),
			$head = $( "head" ),
			$window = $.mobile.window;

	//remove initial build class (only present on first pageshow)
	function hideRenderingClass() {
		$html.removeClass( "ui-mobile-rendering" );
	}

	// trigger mobileinit event - useful hook for configuring $.mobile settings before they're used
	$( window.document ).trigger( "mobileinit" );

	// support conditions
	// if device support condition(s) aren't met, leave things as they are -> a basic, usable experience,
	// otherwise, proceed with the enhancements
	if ( !$.mobile.gradeA() ) {
		return;
	}

	// override ajaxEnabled on platforms that have known conflicts with hash history updates
	// or generally work better browsing in regular http for full page refreshes (BB5, Opera Mini)
	if ( $.mobile.ajaxBlacklist ) {
		$.mobile.ajaxEnabled = false;
	}

	// Add mobile, initial load "rendering" classes to docEl
	$html.addClass( "ui-mobile ui-mobile-rendering" );

	// This is a fallback. If anything goes wrong (JS errors, etc), or events don't fire,
	// this ensures the rendering class is removed after 5 seconds, so content is visible and accessible
	setTimeout( hideRenderingClass, 5000 );

	$.extend( $.mobile, {
		// find and enhance the pages in the dom and transition to the first page.
		initializePage: function() {
			// find present pages
			var path = $.mobile.path,
				$pages = $( ":jqmData(role='page'), :jqmData(role='dialog')" ),
				hash = path.stripHash( path.stripQueryParams(path.parseLocation().hash) ),
				hashPage = document.getElementById( hash );

			// if no pages are found, create one with body's inner html
			if ( !$pages.length ) {
				$pages = $( "body" ).wrapInner( "<div data-" + $.mobile.ns + "role='page'></div>" ).children( 0 );
			}

			// add dialogs, set data-url attrs
			$pages.each(function() {
				var $this = $( this );

				// unless the data url is already set set it to the pathname
				if ( !$this.jqmData( "url" ) ) {
					$this.attr( "data-" + $.mobile.ns + "url", $this.attr( "id" ) || location.pathname + location.search );
				}
			});

			// define first page in dom case one backs out to the directory root (not always the first page visited, but defined as fallback)
			$.mobile.firstPage = $pages.first();

			// define page container
			$.mobile.pageContainer = $.mobile.firstPage.parent().addClass( "ui-mobile-viewport" );

			// alert listeners that the pagecontainer has been determined for binding
			// to events triggered on it
			$window.trigger( "pagecontainercreate" );

			// cue page loading message
			$.mobile.showPageLoadingMsg();

			//remove initial build class (only present on first pageshow)
			hideRenderingClass();

			// if hashchange listening is disabled, there's no hash deeplink,
			// the hash is not valid (contains more than one # or does not start with #)
			// or there is no page with that hash, change to the first page in the DOM
			// Remember, however, that the hash can also be a path!
			if ( ! ( $.mobile.hashListeningEnabled &&
				$.mobile.path.isHashValid( location.hash ) &&
				( $( hashPage ).is( ':jqmData(role="page")' ) ||
					$.mobile.path.isPath( hash ) ||
					hash === $.mobile.dialogHashKey ) ) ) {

				// Store the initial destination
				if ( $.mobile.path.isHashValid( location.hash ) ) {
					$.mobile.urlHistory.initialDst = hash.replace( "#", "" );
				}

				// make sure to set initial popstate state if it exists
				// so that navigation back to the initial page works properly
				if( $.event.special.navigate.isPushStateEnabled() ) {
					$.mobile.navigate.navigator.squash( path.parseLocation().href );
				}

				$.mobile.changePage( $.mobile.firstPage, {
					transition: "none",
					reverse: true,
					changeHash: false,
					fromHashChange: true
				});
			} else {
				// trigger hashchange or navigate to squash and record the correct
				// history entry for an initial hash path
				if( !$.event.special.navigate.isPushStateEnabled() ) {
					$window.trigger( "hashchange", [true] );
				} else {
					// TODO figure out how to simplify this interaction with the initial history entry
					// at the bottom js/navigate/navigate.js
					$.mobile.navigate.history.stack = [];
					$.mobile.navigate( $.mobile.path.isPath( location.hash ) ? location.hash : location.href );
				}
			}
		}
	});

	// initialize events now, after mobileinit has occurred
	$.mobile.navreadyDeferred.resolve();

	// check which scrollTop value should be used by scrolling to 1 immediately at domready
	// then check what the scroll top is. Android will report 0... others 1
	// note that this initial scroll won't hide the address bar. It's just for the check.
	$(function() {
		window.scrollTo( 0, 1 );

		// if defaultHomeScroll hasn't been set yet, see if scrollTop is 1
		// it should be 1 in most browsers, but android treats 1 as 0 (for hiding addr bar)
		// so if it's 1, use 0 from now on
		$.mobile.defaultHomeScroll = ( !$.support.scrollTop || $.mobile.window.scrollTop() === 1 ) ? 0 : 1;

		//dom-ready inits
		if ( $.mobile.autoInitializePage ) {
			$.mobile.initializePage();
		}

		// window load event
		// hide iOS browser chrome on load
		$window.load( $.mobile.silentScroll );

		if ( !$.support.cssPointerEvents ) {
			// IE and Opera don't support CSS pointer-events: none that we use to disable link-based buttons
			// by adding the 'ui-disabled' class to them. Using a JavaScript workaround for those browser.
			// https://github.com/jquery/jquery-mobile/issues/3558

			$.mobile.document.delegate( ".ui-disabled", "vclick",
				function( e ) {
					e.preventDefault();
					e.stopImmediatePropagation();
				}
			);
		}
	});
}( jQuery, this ));


}));
;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function __initHelix() {
    window.Helix = {
    
    };
}
(function() {
    if (window.Helix === undefined) {
        __initHelix();
    }
})();


Helix.Ajax = {
    
};

Helix.Utils = {
    
};

Helix.Layout = {
    
};

Helix.postInit = function(fn, thisArg, args) {
    if (!args) {
        args = [];
    }
    if (!thisArg) {
        thisArg = window;
    }
    if (Helix.ready) {
        fn.apply(thisArg, args);
    } else {
        $(document).on('helixinit', function() {
            fn.apply(thisArg, args);
        });
    }
};

Helix.ready = false;

(function($) {
    $(document).on('hxPersistenceReady', function() {
        /* Update the .val method on textareas to preserve newlines. See
         * http://api.jquery.com/val/
         */
        $.valHooks.textarea = {
            get: function( elem ) {
                return elem.value.replace( /\r?\n/g, "\r\n" );
            }
        };

        $(document).trigger('helixinit');
        Helix.ready = true;
        
        $(document).trigger('helixready');
    });

})(jQuery);

$(document).on('ready', function() {
    window.onerror = function (desc,page,line,chr) { 
        var msg = 'Captured javascript error "' + desc + '" on page "' + page + '" line "' + line + '"';
        alert(msg);
        if (Helix && Helix.errorHook) {
            Helix.errorHook(msg);
        }
    };
});
;/**
 * PrimeFaces core functions
 * 
 * Direct copy of useful utility functions from the PrimeFaces project.
 */
PrimeFaces = {
    escapeClientId : function(id) {
        return "#" + id.replace(/:/g,"\\:");
    }
};;/**
 * PrimeFaces Growl Widget
 * 
 * Converted into a jQuery plugin by Mobile Helix.
 */
(function($) {
    $.widget("helix.helixGrowl", {
        options: {
            /**
             * An array of messages to display in growl boxes. Each message is represented
             * by an object with three fields. The first, 'summary', is the header
             * of the growl box. The second, 'detail', is a more detailed message
             * in the growl box. The third, 'severity', is one of info, warn, error,
             * or fatal, and it dictates the status image shown in the growl box.  
             */
            msgs: [],
            
            /**
             * Indicate if the growl messages are text or raw HTML. true means
             * text, in which case the messages are escaped before rendering.
             */
            escape: true,
            
            /**
             * Indicate if this growl is sticky - i.e. it must display until the
             * user closes it manually. Otherwise it will close after the timeout
             * specified with the 'life' option. Default is false.
             */
            sticky: false,
            
            /**
             * Time (in milliseconds) after which the growl disappears. Note that
             * this option is only used if sticky is false. The default is 4 seconds.
             */
            life: 4000
            
        },
    
        _create: function() {
            this.id = Helix.Utils.getUniqueID();
            this.element.attr('id', this.id);
            this.jqId = PrimeFaces.escapeClientId(this.id);

            this.render();
        
            $(this.jqId + '_s').remove();
        },
    
        //Override
        refresh: function() {
            this.show(this.options.msgs);
        },
    
        show: function(msgs) {
            var _self = this;
        
            this.element.css('z-index', ++PrimeFaces.zindex);

            //clear previous messages
            this.removeAll();

            $.each(msgs, function(index, msg) {
                _self.renderMessage(msg);
            }); 
        },
    
        removeAll: function() {
            this.element.children('div.ui-growl-item-container').remove();
        },
    
        render: function() {
            //create container
            this.element.addClass('ui-growl');
            this.element.addClass('ui-widget');
            this.element.appendTo($(document.body));

            //render messages
            this.show(this.options.msgs);
        },
    
        renderMessage: function(msg) {
            var markup = '<div class="ui-growl-item-container ui-state-highlight ui-corner-all ui-helper-hidden ui-shadow">';
            markup += '<div class="ui-growl-item">';
            markup += '<div class="ui-growl-icon-close ui-icon ui-icon-delete" style="display:none"></div>';
            markup += '<span class="ui-growl-image ui-growl-image-' + msg.severity + '" />';
            markup += '<div class="ui-growl-message">';
            markup += '<span class="ui-growl-title"></span>';
            markup += '<p></p>';
            markup += '</div><div style="clear: both;"></div></div></div>';

            var message = $(markup),
            summaryEL = message.find('span.ui-growl-title'),
            detailEL = summaryEL.next();
        
            if(this.options.escape) {
                summaryEL.text(msg.summary);
                detailEL.text(msg.detail);
            }
            else {
                summaryEL.html(msg.summary);
                detailEL.html(msg.detail);
            }

            message.appendTo(this.element).fadeIn();
            this.bindEvents(message);
        },
    
        bindEvents: function(message) {
            var _self = this,
            sticky = this.options.sticky;

/*
            message.mouseover(function() {
                var msg = $(this);

                //visuals
                if(!msg.is(':animated')) {
                    msg.find('div.ui-growl-icon-close:first').show();
                }
            })
            .mouseout(function() {        
                //visuals
                $(this).find('div.ui-growl-icon-close:first').hide();
            }); */

            //remove message on click of close icon
            if (!Helix.hasTouch) {
                message.on('click', function(ev) {
                    _self.removeMessage(message);

                    //clear timeout if removed manually
                    if(!sticky) {
                        clearTimeout(message.data('timeout'));
                    }
                    ev.stopImmediatePropagation();
                    return false;
                });
            } else {
                message.on('tap', function(ev) {
                    _self.removeMessage(message);

                    //clear timeout if removed manually
                    if(!sticky) {
                        clearTimeout(message.data('timeout'));
                    }
                    ev.stopImmediatePropagation();
                    return false;
                });
            }

            //hide the message after given time if not sticky
            if(!sticky) {
                this.setRemovalTimeout(message);
            }
        },
    
        removeMessage: function(message) {
            message.fadeTo('normal', 0, function() {
                message.remove();
            });
        },
    
        setRemovalTimeout: function(message) {
            var _self = this;

            var timeout = setTimeout(function() {
                _self.removeMessage(message);
            }, this.options.life);

            message.data('timeout', timeout);
        }
    });
}( jQuery ));;/*
 * jQuery Mobile Framework : plugin to provide a date and time picker.
 * Copyright (c) JTSage
 * CC 3.0 Attribution.  May be relicensed without permission/notification.
 * https://github.com/jtsage/jquery-mobile-datebox
 */
/* CORE Functions */

(function($) {
    $.widget( "mobile.datebox", $.mobile.widget, {
        options: {
            // All widget options, including some internal runtime details
            version: '2-1.1.0-2012091200', // jQMMajor.jQMMinor.DBoxMinor-YrMoDaySerial
            theme: false,
            themeDefault: 'c',
            themeHeader: 'a',
            mode: false,
			
            centerHoriz: false,
            centerVert: false,
            transition: 'pop',
            useAnimation: true,
            hideInput: false,
            hideFixedToolbars: false,
			
            lockInput: true,
            enhanceInput: true,
			
            zindex: '500',
            clickEvent: 'vclick',
            clickEventAlt: 'click',
            resizeListener: true,
			
            defaultValue: false,
			
            dialogEnable: false,
            dialogForce: false,
			
            useModal: false,
            useInline: false,
            useInlineBlind: false,
            useHeader: true,
            useImmediate: false,
            useNewStyle: false,
            useAltIcon: false,
            overrideStyleClass: false,
			
            useButton: true,
            useFocus: false,
            useClearButton: false,
            useCollapsedBut: false,
            usePlaceholder: false,
			
            openCallback: false,
            openCallbackArgs: [],
            closeCallback: false,
            closeCallbackArgs: [],
			
            afterToday: false,
            beforeToday: false,
            notToday: false,
            maxDays: false,
            minDays: false,
            maxYear: false,
            minYear: false,
            blackDates: false,
            blackDays: false,
            minHour: false,
            maxHour: false,
            minuteStep: 1,
            minuteStepRound: 0,
                        
            /* SAH */
            displayInline : false,
			
            rolloverMode: {
                'm': true, 
                'd': true, 
                'h': true, 
                'i': true, 
                's': true
            },
			
            useLang: 'default',
            lang: {
                'default' : {
                    setDateButtonLabel: 'Set Date',
                    setTimeButtonLabel: 'Set Time',
                    setDurationButtonLabel: 'Set Duration',
                    calTodayButtonLabel: 'Jump to Today',
                    titleDateDialogLabel: 'Set Date',
                    titleTimeDialogLabel: 'Set Time',
                    daysOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    daysOfWeekShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
                    monthsOfYear: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    monthsOfYearShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                    durationLabel: ['Days', 'Hours', 'Minutes', 'Seconds'],
                    durationDays: ['Day', 'Days'],
                    timeFormat: 24,
                    headerFormat: '%A, %B %-d, %Y',
                    tooltip: 'Open Date Picker',
                    nextMonth: 'Next Month',
                    prevMonth: 'Previous Month',
                    dateFieldOrder: ['m', 'd', 'y'],
                    timeFieldOrder: ['h', 'i', 'a'],
                    slideFieldOrder: ['y', 'm', 'd'],
                    dateFormat: '%Y-%m-%d',
                    useArabicIndic: false,
                    isRTL: false,
                    calStartDay: 0,
                    clearButton: 'Clear',
                    durationOrder: ['d', 'h', 'i', 's'],
                    meridiem: ['AM', 'PM'],
                    timeOutput: '%k:%M', //{ '12': '%l:%M %p', '24': '%k:%M' },
                    durationFormat: '%Dd %DA, %Dl:%DM:%DS'
                }
            }
        },
        _enhanceDate: function() {
            $.extend(this._date.prototype, {
                copy: function(adjust, override) {
                    /* Get a modified copy of the date.
					 * First array - Offset the new date by #  (position determines date part)
					 * Second array - If non-zero, force the new date by # (position determines date part)
					 */
                    if ( typeof adjust === 'undefined' ) {
                        adjust = [0,0,0,0,0,0,0];
                    }
                    if ( typeof override === 'undefined' ) {
                        override = [0,0,0,0,0,0,0];
                    }
                    while ( adjust.length < 7 ) {
                        adjust.push(0);
                    }
                    while ( override.length < 7 ) {
                        override.push(0);
                    }
                    return new Date(
                        ((override[0] > 0 ) ? override[0] : this.getFullYear() + adjust[0]),
                        ((override[1] > 0 ) ? override[1] : this.getMonth() + adjust[1]),
                        ((override[2] > 0 ) ? override[2] : this.getDate() + adjust[2]),
                        ((override[3] > 0 ) ? override[3] : this.getHours() + adjust[3]),
                        ((override[4] > 0 ) ? override[4] : this.getMinutes() + adjust[4]),
                        ((override[5] > 0 ) ? override[5] : this.getSeconds() + adjust[5]),
                        ((override[6] > 0 ) ? override[5] : this.getMilliseconds() + adjust[6]));
                },
                adj: function (type, amount) {
                    /* Adjust the date.  Yes, this is chainable */
                    if ( typeof amount !== 'number' ) {
                        throw new Error("Adjustment value not specified");
                    }
                    if ( typeof type !== 'number' ) {
                        throw new Error("Adjustment type not specified");
                    }
                    switch ( type ) {
                        case 0:
                            this.setFullYear(this.getFullYear() + amount);
                            break;
                        case 1:
                            this.setMonth(this.getMonth() + amount);
                            break;
                        case 2:
                            this.setDate(this.getDate() + amount);
                            break;
                        case 3:
                            this.setHours(this.getHours() + amount);
                            break;
                        case 4:
                            this.setMinutes(this.getMinutes() + amount);
                            break;
                        case 5:
                            this.setSeconds(this.getSeconds() + amount);
                            break;
                        case 6:
                            this.setMilliseconds(this.getMilliseconds() + amount);
                            break;
                    }
                    return this;
                },
                dbset: function(type, amount) {
                    /* A chainable version of setWhatever() */
                    switch ( type ) {
                        case 0:
                            this.setFullYear(amount);
                            break;
                        case 1:
                            this.setMonth(amount);
                            break;
                        case 2:
                            this.setDate(amount);
                            break;
                        case 3:
                            this.setHours(amount);
                            break;
                        case 4:
                            this.setMinutes(amount);
                            break;
                        case 5:
                            this.setSeconds(amount);
                            break;
                        case 6:
                            this.setMilliseconds(amount);
                            break;
                    }
                    return this;
                },
                get: function(type) {
                    switch ( type ) {
                        case 0:
                            return this.getFullYear();
                        case 1:
                            return this.getMonth();
                        case 2:
                            return this.getDate();
                        case 3:
                            return this.getHours();
                        case 4:
                            return this.getMinutes();
                        case 5:
                            return this.getSeconds();
                    }
                    return false;
                },
                iso: function() {
                    return String(this.getFullYear()) + '-' + (( this.getMonth() < 9 ) ? "0" : "") + String(this.getMonth()+1) + '-' + ((this.getDate() < 10 ) ? "0" : "") + String(this.getDate());
                },
                comp: function () { 
                    return parseInt(this.iso().replace(/-/g,''),10); 
                },
                getEpoch: function() { 
                    return (this.getTime() - this.getMilliseconds()) / 1000; 
                },
                getArray: function() {
                    return [this.getFullYear(), this.getMonth(), this.getDate(), this.getHours(), this.getMinutes(), this.getSeconds()];
                },
                setFirstDay: function (day) {
                    this.dbset(2,1).adj(2, (day - this.getDay()));
                    if ( this.get(2) > 10 ) {
                        this.adj(2,7);
                    }
                    return this; 
                },
                setWeek: function (type,num) {
                    if ( type === 4 ) {
                        return this.dbset(1,0).dbset(2,1).setFirstDay(4).adj(2,-3).adj(2,(num-1)*7);
                    }
                    return this.dbset(1,0).dbset(2,1).setFirstDay(type).adj(2,(num-1)*7);
                },
                getWeek: function (type) {
                    var t1, t2;
					
                    switch ( type ) {
                        case 0:
                            t1 = this.copy([0,-1*this.getMonth()]).setFirstDay(0);
                            return Math.floor((this.getTime() - ( t1.getTime() + (( this.getTimezoneOffset() - t1.getTimezoneOffset()) * 60000))) / 6048e5) + 1;
                        //return Math.floor((this.getTime() - t1.getTime()) / 6048e5) + 1;
                        case 1:
                            t1 = this.copy([0,-1*this.getMonth()]).setFirstDay(1);
                            return Math.floor((this.getTime() - ( t1.getTime() + (( this.getTimezoneOffset() - t1.getTimezoneOffset()) * 60000))) / 6048e5) + 1;
                        //return Math.floor((this.getTime() - t1.getTime()) / 6048e5) + 1;
                        case 4:
                            // this line is some bullshit.  but it does work.
                            // (trap for dec 29, 30, or 31st being in the new year's week - these are the
                            //  only 3 that can possibly fall like this)
                            if ( this.getMonth() === 11 && this.getDate() > 28 ) {
                                return 1;
                            } 
							
                            t1 = this.copy([0,-1*this.getMonth()],true).setFirstDay(4).adj(2,-3);
                            t2 = Math.floor((this.getTime() - ( t1.getTime() + (( this.getTimezoneOffset() - t1.getTimezoneOffset()) * 60000))) / 6048e5) + 1;
							
                            if ( t2 < 1 ) {
                                t1 = this.copy([-1,-1*this.getMonth()]).setFirstDay(4).adj(2,-3);
                                return Math.floor((this.getTime() - t1.getTime()) / 6048e5) + 1;
                            }
                            return t2;
                        default:
                            return 0;
                    }
                }
            });
        },
        _event: function(e, p) {
            //console.log($(this).data());
            var w = $(this).data('mobile-datebox');
            if ( ! e.isPropagationStopped() ) {
                switch (p.method) {
                    case 'close':
                        w.close();
                        break;
                    case 'open':
                        w.open();
                        break;
                    case 'set':
                        if (p.value === undefined) {
                            p.value = new Date();
                        } else if (p.value === null || p.value == 0) {
                            p.value = '';
                            w.theDate = null;
                        } else if (Helix.Utils.isString(p.value)) {
                            w.theDate = w._makeDate(p.value);
                        } else if (typeof p.value === 'number') {
                            if (p.value > 0) {
                                w.theDate = new Date(p.value);                                                    
                            } else {
                                p.value = '';
                                w.theDate = null;
                            }
                        } else {
                            w.theDate = p.value;
                        }
                        $(this).val(p.value);
                        $(this).trigger('change');
                        break;
                    case 'doset':
                        if ( $.isFunction(w['_'+w.options.mode+'DoSet']) ) {
                            w['_'+w.options.mode+'DoSet'].apply(w,[]);
                        } else {
                            $(this).trigger('datebox', {
                                'method':'set', 
                                'value':w.theDate ? w._formatter(w.__fmt(), w.theDate) : '', 
                                'date':w.theDate
                                });
                        }
                        break;
                    case 'dooffset':
                        if (p.type) {
                            w._offset(p.type, p.amount, true);
                        }
                        break; 
                    case 'dorefresh':
                        w.refresh();
                        break;
                    case 'doreset':
                        w.hardreset();
                        break;
                    case 'doclear':
                        $(this).val('').trigger('change');
                        break;
                    case 'clear':
                        $(this).trigger('change');
                }
            }
        },
        _hoover: function(item) {
            // Hover toggle class, for calendar
            $(item).toggleClass('ui-btn-up-'+$(item).jqmData('theme')+' ui-btn-down-'+$(item).jqmData('theme'));
        },
        _ord: {
            'default': function (num) {
                // Return an ordinal suffix (1st, 2nd, 3rd, etc)
                var ending = num % 10;
                if ( num > 9 && num < 21 ) {
                    return 'th';
                }
                if ( ending > 3 ) {
                    return 'th';
                }
                return ['th','st','nd','rd'][ending];
            }
        },
        __ : function(val) {
            var o = this.options,
            oride = 'override' + val.charAt(0).toUpperCase() + val.slice(1);
				
            if ( typeof o[oride] !== 'undefined' ) {
                return o[oride];
            }
            if ( typeof o.lang[o.useLang][val] !== 'undefined' ) {
                return o.lang[o.useLang][val];
            }
            if ( typeof o[o.mode+'lang'][val] !== 'undefined' ) {
                return o[o.mode+'lang'][val];
            }
            return o.lang['default'][val];
        },
        __fmt: function() {
            var w = this,
            o = this.options;
			
            switch ( o.mode ) {
                case 'timebox':
                case 'timeflipbox':
                    return w.__('timeOutput');
                case 'durationbox':
                    return w.__('durationFormat');
                default:
                    return w.__('dateFormat');
            }
        },
        _zPad: function(number) {
            return (( number < 10 ) ? '0' + String(number) : String(number));
        },
        _dRep: function(oper, direction) {
            var start = 48,
            end = 57,
            adder = 1584,
            i = null, 
            ch = null,
            newd = '';
				
            if ( direction === -1 ) {
                start += adder;
                end += adder;
                adder = -1584;
            }
			
            for ( i=0; i<oper.length; i++ ) {
                ch = oper.charCodeAt(i);
                if ( ch >= start && ch <= end ) {
                    newd = newd + String.fromCharCode(ch+adder);
                } else {
                    newd = newd + String.fromCharCode(ch);
                }
            }
			
            return newd;
        },
        _doIndic: function() {
            var w = this;
				
            w.d.intHTML.find('*').each(function() {
                if ( $(this).children().length < 1 ) {
                    $(this).text(w._dRep($(this).text()));
                } else if ( $(this).hasClass('ui-datebox-slideday') ) {
                    $(this).html(w._dRep($(this).html()));
                }
            });
            w.d.intHTML.find('input').each(function() {
                $(this).val(w._dRep($(this).val()));
            });
        },
        _parser: {
            'default': function (str) {
                return false;
            }
        },
        _n: function (val,def) {
            return ( val < 0 ) ? def : val;
        },
        _pa: function (arr,date) {
            if ( typeof date === 'boolean' ) {
                return new this._date(arr[0],arr[1],arr[2],0,0,0,0);
            }
            return new this._date(date.getFullYear(), date.getMonth(), date.getDate(), arr[0], arr[1], arr[2], 0);
        },
        _makeDate: function (str) {
            // Date Parser
            str = $.trim(((this.__('useArabicIndic') === true)?this._dRep(str, -1):str));
            var w = this,
            o = this.options,
            adv = w.__fmt(),
            exp_input = null,
            exp_names = [],
            exp_format = null,
            exp_temp = null,
            date = new w._date(),
            d = {
                year: -1, 
                mont: -1, 
                date: -1, 
                hour: -1, 
                mins: -1, 
                secs: -1, 
                week: false, 
                wtyp: 4, 
                wday: false, 
                yday: false, 
                meri: 0
            },
            i;
			
            if ( typeof o.mode === 'undefined' ) {
                return date;
            }
            if ( typeof w._parser[o.mode] !== 'undefined' ) {
                return w._parser[o.mode].apply(w,[str]);
            }
			
            if ( o.mode === 'durationbox' ) {
                adv = adv.replace(/%D([a-z])/gi, function(match, oper) {
                    switch (oper) {
                        case 'd':
                        case 'l':
                        case 'M':
                        case 'S':
                            return '(' + match + '|' +'[0-9]+' + ')';
                        default:
                            return '.+?';
                    }
                });
				
                adv = new RegExp('^' + adv + '$');
                exp_input = adv.exec(str);
                exp_format = adv.exec(w.__fmt());
				
                if ( exp_input === null || exp_input.length !== exp_format.length ) {
                    if ( typeof o.defaultValue === "number" && o.defaultValue > 0 ) {
                        return new w._date(o.defaultValue);
                    //return new w._date((w.initDate.getEpoch() + parseInt(o.defaultValue,10))*1000);
                    } 
                    return new w._date(w.initDate.getTime());
                } 
				
                exp_temp = w.initDate.getEpoch();
                for ( i=0; i<exp_input.length; i++ ) { //0y 1m 2d 3h 4i 5s
                    if ( exp_format[i].match(/^%Dd$/i) )   {
                        exp_temp = exp_temp + (parseInt(exp_input[i],10)*60*60*24);
                    }
                    if ( exp_format[i].match(/^%Dl$/i) )   {
                        exp_temp = exp_temp + (parseInt(exp_input[i],10)*60*60);
                    }
                    if ( exp_format[i].match(/^%DM$/i) )   {
                        exp_temp = exp_temp + (parseInt(exp_input[i],10)*60);
                    }
                    if ( exp_format[i].match(/^%DS$/i) )   {
                        exp_temp = exp_temp + (parseInt(exp_input[i],10));
                    }
                }
                return new w._date((exp_temp*1000));
            }
			
            adv = adv.replace(/%(0|-)*([a-z])/gi, function(match, pad, oper) {
                exp_names.push(oper);
                switch (oper) {
                    case 'p':
                    case 'P':
                    case 'b':
                    case 'B':
                        return '(' + match + '|' +'.+?' + ')';
                    case 'H':
                    case 'k':
                    case 'I':
                    case 'l':
                    case 'm':
                    case 'M':
                    case 'S':
                    case 'V':
                    case 'U':
                    case 'u':
                    case 'W':
                    case 'd':
                        return '(' + match + '|' + (( pad === '-' ) ? '[0-9]{1,2}' : '[0-9]{2}') + ')';
                    case 'j':
                        return '(' + match + '|' + '[0-9]{3}' + ')';
                    case 's':
                        return '(' + match + '|' + '[0-9]+' + ')';
                    case 'g':
                    case 'y':
                        return '(' + match + '|' + '[0-9]{2}' + ')';
                    case 'E':
                    case 'G':
                    case 'Y':
                        return '(' + match + '|' + '[0-9]{1,4}' + ')';
                    default:
                        exp_names.pop();
                        return '.+?';	
                }
            });
			
            adv = new RegExp('^' + adv + '$');
            exp_input = adv.exec(str);
            exp_format = adv.exec(w.__fmt());
			
            if ( exp_input === null || exp_input.length !== exp_format.length ) {
                if ( o.defaultValue !== false ) {
                    if (Object.prototype.toString.call(o.defaultValue) === "[object Date]") {
                        /* we already have a date. No more parsing needed. */
                        date = o.defaultValue;
                    } else {
                        switch ( typeof o.defaultValue ) {
                            case 'object':
                                if ( o.defaultValue.length === 3 ) {
                                    date =  w._pa(o.defaultValue,((o.mode === 'timebox' || o.mode === 'timeflipbox') ? date : false));
                                }
                                break;
                            case 'number':
                                date =  new w._date(o.defaultValue);
                                break;
                            case 'string':
                                if ( o.mode === 'timebox' || o.mode === 'timeflipbox' ) {
                                    exp_temp = o.defaultValue.split(':');
                                    if ( exp_temp.length === 3 ) {
                                        date = w._pa([exp_temp[0],exp_temp[1],exp_temp[2]], date);
                                    }
                                } else {
                                    exp_temp = o.defaultValue.split('-');
                                    if ( exp_temp.length === 3 ) {
                                        date = w._pa([exp_temp[0],exp_temp[1]-1,exp_temp[2]], false);
                                    }
                                }
                                break;
                        }
                    }
                }
                if ( isNaN(date.getDate()) ) {
                    date = new w._date();
                }
            } else {
                for ( i=1; i<exp_input.length; i++ ) {
                    switch ( exp_names[i-1] ) {
                        case 's':
                            return new w._date(parseInt(exp_input[i],10) * 1000);
                        case 'Y':
                        case 'G':
                            d.year = parseInt(exp_input[i],10);
                            break;
                        case 'E':
                            d.year = parseInt(exp_input[i],10) - 543;
                            break;
                        case 'y':
                        case 'g':
                            if ( o.afterToday === true || parseInt(exp_input[i],10) < 38 ) {
                                d.year = parseInt('20' + exp_input[i],10);
                            } else {
                                d.year = parseInt('19' + exp_input[i],10);
                            }
                            break;
                        case 'm':
                            d.mont = parseInt(exp_input[i],10)-1;
                            break;
                        case 'd':
                            d.date = parseInt(exp_input[i],10);
                            break;
                        case 'H':
                        case 'k':
                        case 'I':
                        case 'l':
                            d.hour = parseInt(exp_input[i],10);
                            break;
                        case 'M':
                            d.mins = parseInt(exp_input[i],10);
                            break;
                        case 'S':
                            d.secs = parseInt(exp_input[i],10);
                            break;
                        case 'u':
                            d.wday = parseInt(exp_input[i],10)-1;
                            break;
                        case 'w':
                            d.wday = parseInt(exp_input[i],10);
                            break;
                        case 'j':
                            d.yday = parseInt(exp_input[i],10);
                            break;
                        case 'V':
                            d.week = parseInt(exp_input[i],10);
                            d.wtyp = 4;
                            break;
                        case 'U':
                            d.week = parseInt(exp_input[i],10);
                            d.wtyp = 0;
                            break;
                        case 'W':
                            d.week = parseInt(exp_input[i],10);
                            d.wtyp = 1;
                            break;
                        case 'p':
                        case 'P':
                            d.meri = (( exp_input[i].toLowerCase() === w.__('meridiem')[0].toLowerCase() )? -1:1);
                            break;
                        case 'b':
                            exp_temp = $.inArray(exp_input[i], w.__('monthsOfYearShort'));
                            if ( exp_temp > -1 ) {
                                d.mont = exp_temp;
                            }
                            break;
                        case 'B':
                            exp_temp = $.inArray(exp_input[i], w.__('monthsOfYear'));
                            if ( exp_temp > -1 ) {
                                d.mont = exp_temp;
                            }
                            break;
                    }
                }
                if ( d.meri !== 0 ) {
                    if ( d.meri === -1 && d.hour === 12 ) {
                        d.hour = 0;
                    }
                    if ( d.meri === 1 && d.hour !== 12 ) {
                        d.hour = d.hour + 12;
                    }
                }
				
                date = new w._date(w._n(d.year,1),w._n(d.mont,1),w._n(d.date,1),w._n(d.hour,0),w._n(d.mins,0),w._n(d.secs,0),0);
				
                if ( d.year < 100 && d.year !== -1 ) {
                    date.setFullYear(d.year);
                }
				
                if ( ( d.mont > -1 && d.date > -1 ) || ( d.hour > -1 && d.mins > -1 && d.secs > -1 ) ) {
                    return date;
                }
				
                if ( d.week !== false ) {
                    date.setWeek(d.wtyp, d.week);
                    if ( d.date > -1 ) {
                        date.setDate(d.date);
                    } 
                }
                if ( d.yday !== false ) {
                    date.dbset(1,0).dbset(2,1).adj(2,(d.yday-1));
                }
                if ( d.wday !== false ) {
                    date.adj(2,(d.wday - date.getDay()));
                }
            }
            return date;
        },
        _customformat: {
            'default': function(oper, date) {
                return false;
            }
        },
        _formatter: function(format, date) {
            var w = this,
            o = this.options, tmp,
            dur = {
                part: [0,0,0,0], 
                tp: 0
            };
				
            if ( o.mode === 'durationbox' ) {
                dur.tp = this.theDate.getEpoch() - this.initDate.getEpoch();
                dur.part[0] = parseInt( dur.tp / (60*60*24),10);
                dur.tp -=(dur.part[0]*60*60*24); // Days
                dur.part[1] = parseInt( dur.tp / (60*60),10);
                dur.tp -= (dur.part[1]*60*60); // Hours
                dur.part[2] = parseInt( dur.tp / (60),10);
                dur.tp -= (dur.part[2]*60); // Minutes
                dur.part[3] = dur.tp; // Seconds
			
                if ( ! format.match(/%Dd/) ) {
                    dur.part[1] += (dur.part[0]*24);
                }
                if ( ! format.match(/%Dl/) ) {
                    dur.part[2] += (dur.part[1]*60);
                }
                if ( ! format.match(/%DM/) ) {
                    dur.part[3] += (dur.part[2]*60);
                }
            }
				
            format = format.replace(/%(D|X|0|-)*([1-9a-zA-Z])/g, function(match, pad, oper) {
                if ( pad === 'X' ) {
                    if ( typeof w._customformat[o.mode] !== 'undefined' ) {
                        return w._customformat[o.mode](oper, date);
                    }
                    return match;
                }
                if ( pad === 'D' ) {
                    switch ( oper ) {
                        case 'd':
                            return dur.part[0];
                        case 'l':
                            return w._zPad(dur.part[1]);
                        case 'M':
                            return w._zPad(dur.part[2]);
                        case 'S':
                            return w._zPad(dur.part[3]);
                        case 'A':
                            return ((dur.part[0] > 1)?w.__('durationDays')[1]:w.__('durationDays')[0]);
                        default:
                            return match;
                    }
                }
                switch ( oper ) {
                    case '%': // Literal %
                        return '%';
                    case 'a': // Short Day
                        return w.__('daysOfWeekShort')[date.getDay()];
                    case 'A': // Full Day of week
                        return w.__('daysOfWeek')[date.getDay()];
                    case 'b': // Short month
                        return w.__('monthsOfYearShort')[date.getMonth()];
                    case 'B': // Full month
                        return w.__('monthsOfYear')[date.getMonth()];
                    case 'C': // Century
                        return date.getFullYear().toString().substr(0,2);
                    case 'd': // Day of month
                        return (( pad === '-' ) ? date.getDate() : w._zPad(date.getDate()));
                    case 'H': // Hour (01..23)
                    case 'k':
                        return (( pad === '-' ) ? date.getHours() : w._zPad(date.getHours()));
                    case 'I': // Hour (01..12)
                    case 'l':
                        return (( pad === '-' ) ? ((date.getHours() === 0 || date.getHours() === 12)?12:((date.getHours()<12)?date.getHours():(date.getHours()-12))) : w._zPad(((date.getHours() === 0 || date.getHours() === 12)?12:((date.getHours()<12)?date.getHours():date.getHours()-12))));
                    case 'm': // Month
                        return (( pad === '-' ) ? date.getMonth()+1 : w._zPad(date.getMonth()+1));
                    case 'M': // Minutes
                        return (( pad === '-' ) ? date.getMinutes() : w._zPad(date.getMinutes()));
                    case 'p': // AM/PM (ucase)
                        return ((date.getHours() < 12)?w.__('meridiem')[0].toUpperCase():w.__('meridiem')[1].toUpperCase());
                    case 'P': // AM/PM (lcase)
                        return ((date.getHours() < 12)?w.__('meridiem')[0].toLowerCase():w.__('meridiem')[1].toLowerCase());
                    case 's': // Unix Seconds
                        return date.getEpoch();
                    case 'S': // Seconds
                        return (( pad === '-' ) ? date.getSeconds() : w._zPad(date.getSeconds()));
                    case 'u': // Day of week (1-7)
                        return (( pad === '-' ) ? date.getDay() + 1 : w._zPad(date.getDay() + 1));
                    case 'w': // Day of week
                        return date.getDay();
                    case 'y': // Year (2 digit)
                        return date.getFullYear().toString().substr(2,2);
                    case 'Y': // Year (4 digit)
                        return date.getFullYear();
                    case 'E': // BE (Buddist Era, 4 Digit)
                        return date.getFullYear() + 543;
                    case 'V':
                        return (( pad === '-' ) ? date.getWeek(4) : w._zPad(date.getWeek(4)));
                    case 'U':
                        return (( pad === '-' ) ? date.getWeek(0) : w._zPad(date.getWeek(0)));
                    case 'W':
                        return (( pad === '-' ) ? date.getWeek(1) : w._zPad(date.getWeek(1)));
                    case 'o': // Ordinals
                        if ( typeof w._ord[o.useLang] !== 'undefined' ) {
                            return w._ord[o.useLang](date.getDate());
                        }
                        return w._ord['default'](date.getDate());
                    case 'j':
                        tmp = new Date(date.getFullYear(),0,1);
                        tmp = Math.ceil((date - tmp) / 86400000)+1;
                        return (( tmp < 100 ) ? (( tmp < 10 )? '00' : '0') : '' ) + String(tmp);
                    case 'G':
                        if ( date.getWeek(4) === 1 && date.getMonth() > 0 ) {
                            return date.getFullYear() + 1;
                        } 
                        if ( date.getWeek(4) > 51 && date.getMonth() < 11 ) {
                            return date.getFullYear() - 1;
                        }
                        return date.getFullYear();
                    case 'g':
                        if ( date.getWeek(4) === 1 && date.getMonth() > 0 ) {
                            return parseInt(date.getFullYear().toString().substr(2,2),10) + 1;
                        }
                        if ( date.getWeek(4) > 51 && date.getMonth() < 11 ) {
                            return parseInt(date.getFullYear().toString().substr(2,2),10) - 1;
                        }
                        return date.getFullYear().toString().substr(2,2);
                    default:
                        return match;
                }
            });
		
            if ( w.__('useArabicIndic') === true ) {
                format = w._dRep(format);
            }
		
            return format;
        },
        _btwn: function(value, low, high) {
            return ( value > low && value < high );
        },
        _minStepFix: function() {
            var tempMin = this.theDate.get(4), tmp,
            w = this,
            o = this.options;
				
            if ( o.minuteStep > 1 && tempMin % o.minuteStep > 0 ) {
                if ( o.minuteStepRound < 0 ) {
                    tempMin = tempMin - (tempMin % o.minuteStep);
                } else if ( o.minStepRound > 0 ) {
                    tempMin = tempMin + ( o.minuteStep - ( tempMin % o.minuteStep ) );
                } else {
                    if ( tempMin % o.minuteStep < o.minuteStep / 2 ) {
                        tempMin = tempMin - (tempMin % o.minuteStep);
                    } else {
                        tempMin = tempMin + ( o.minuteStep - ( tempMin % o.minuteStep ) );
                    }
                }
                w.theDate.setMinutes(tempMin);
            }
        },
        _offset: function(mode, amount, update) {
            // Compute a date/time offset.
            //   update = false to prevent controls refresh
            var w = this,
            o = this.options,
            ok = false;
				
            mode = (mode || "").toLowerCase();
				
            if ( typeof(update) === "undefined" ) {
                update = true;
            }
            w.d.input.trigger('datebox', {
                'method':'offset', 
                'type':mode, 
                'amount':amount
            });
			
            if ( mode !== 'a' && ( typeof o.rolloverMode[mode] === 'undefined' || o.rolloverMode[mode] === true )) {
                ok = $.inArray(mode, ['y','m','d','h','i','s']);
            } else {
                switch(mode) {
                    case 'y':
                        ok = 0;
                        break;
                    case 'm':
                        if ( w._btwn(w.theDate.getMonth()+amount,-1,12) ) {
                            ok = 1;
                        }
                        break;
                    case 'd':
                        if ( w._btwn(w.theDate.getDate() + amount,0,(32 - w.theDate.copy([0],[0,0,32,13]).getDate() + 1) )) {
                            ok = 2;
                        }
                        break;
                    case 'h':
                        if ( w._btwn(w.theDate.getHours() + amount,-1,24) ) {
                            ok = 3;
                        }
                        break;
                    case 'i':
                        if ( w._btwn(w.theDate.getMinutes() + amount,-1,60) ) {
                            ok = 4;
                        }
                        break;
                    case 's':
                        if ( w._btwn(w.theDate.getSeconds() + amount,-1,60) ) {
                            ok = 5;
                        }
                        break;
                    case 'a':
                        w._offset('h',((amount>0)?1:-1)*12,false);
                        break;
                }
            }
            if ( ok !== false ) {
                w.theDate.adj(ok,amount);
            }
            if ( update === true ) {
                w._doBuild();
                w.refresh();
            }
            if ( o.useImmediate ) {
                w.d.input.trigger('datebox', {
                    'method':'doset'
                });
            }
        },
        _create: function() {
            // Create the widget, called automatically by widget system
            $( document ).trigger( "dateboxcreate" );
		
            var w = this,
            o = $.extend(this.options, (typeof this.element.jqmData('options') !== 'undefined') ? this.element.jqmData('options') : this._getLongOptions(this.element) ),
            thisTheme = ( o.theme === false && typeof($(this).jqmData('theme')) === 'undefined' ) ?
            ( ( typeof(this.element.parentsUntil(':jqmData(theme)').parent().jqmData('theme')) === 'undefined' ) ?
                o.themeDefault : this.element.parentsUntil(':jqmData(theme)').parent().jqmData('theme') )
            : o.theme,
            trans = o.useAnimation ? o.transition : 'none',
            d = o.useNewStyle === false ? {
                input: this.element,
                wrap: this.element.wrap('<div class="ui-input-datebox ui-shadow-inset ui-corner-all '+ (this.element.jqmData("mini") === true ? 'ui-mini ':'') +'ui-body-'+ thisTheme + '"></div>').parent(),
                mainWrap: $("<div>", {
                    "class": 'ui-datebox-container ui-overlay-shadow ui-corner-all ui-datebox-hidden '+trans+' ui-body-'+thisTheme
                    } ).css('zIndex', o.zindex),
                intHTML: false
            } : {
                input: this.element,
                wrap: this.element,
                mainWrap: $("<div>", {
                    "class": 'ui-datebox-container ui-overlay-shadow ui-corner-all ui-datebox-hidden '+trans+' ui-body-'+thisTheme
                    } ).css('zIndex', o.zindex),
                intHTML: false
            },
            touch = ( typeof window.ontouchstart !== 'undefined' ),
            drag = {
                eStart : (touch ? 'touchstart' : 'mousedown')+'.datebox',
                eMove  : (touch ? 'touchmove' : 'mousemove')+'.datebox',
                eEnd   : (touch ? 'touchend' : 'mouseup')+'.datebox',
                eEndA  : (touch ? 'mouseup.datebox touchend.datebox touchcancel.datebox touchmove.datebox' : 'mouseup.datebox'),
                move   : false,
                start  : false,
                end    : false,
                pos    : false,
                target : false,
                delta  : false,
                tmp    : false
            },
            ns = (typeof $.mobile.ns !== 'undefined')?$.mobile.ns:'';
				
                                
            /* SAH */
            if (o.displayInline) {
                d.wrap.addClass('hx-display-inline');
            }
            $.extend(w, {
                d: d, 
                ns: ns, 
                drag: drag, 
                touch:touch
            });
			
            if ( o.usePlaceholder !== false ) {
                if ( o.usePlaceholder === true && w._grabLabel() !== false ) {
                    w.d.input.attr('placeholder', w._grabLabel());
                }
                if ( typeof o.usePlaceholder === 'string' ) {
                    w.d.input.attr('placeholder', o.usePlaceholder);
                }
            }
			
            o.theme = thisTheme;
			
            w.clearFunc = false;
            w.disabled = false;
            w.runButton = false;
            w._date = window.Date;
            w._enhanceDate();
			
            w.initDate = new w._date();
            if (o.defaultValue !== undefined &&
                o.defaultValue != null) {
                if (o.defaultValue == 0) {
                    w.theDate = null;
                } else {
                    w.theDate = w._makeDate(o.defaultValue);
                }
            } else {
                w.theDate = new w._date();
            }
            w.initDone = false;
			
            if ( o.useButton === true && o.useInline === false && o.useNewStyle === false ) {
                w.d.open = $('<a href="#" class="ui-input-clear" title="'+this.__('tooltip')+'">'+this.__('tooltip')+'</a>')
                .on(o.clickEvent, function(e) {
                    e.preventDefault();
                    if ( !w.disabled ) {
                        w.d.input.trigger('datebox', {
                            'method': 'open'
                        });
                        w.d.wrap.addClass('ui-focus');
                    }
                    setTimeout( function() {
                        $(e.target).closest('a').removeClass($.mobile.activeBtnClass);
                    }, 300);
                }).appendTo(w.d.wrap).buttonMarkup({
                    icon: 'grid', 
                    iconpos: 'notext', 
                    corners:true, 
                    shadow:true
                })
                .css({
                    'vertical-align': 'middle', 
                    'display': 'inline-block'
                });
            }
			
            w.d.screen = $("<div>", {
                'class':'ui-datebox-screen ui-datebox-hidden'+((o.useModal)?' ui-datebox-screen-modal':'')
                })
            .css({
                'z-index': o.zindex-1
                })
            .on(o.clickEventAlt, function(e) {
                e.preventDefault();
                w.d.input.trigger('datebox', {
                    'method':'close'
                });
            });
			
            if ( o.enhanceInput === true && navigator.userAgent.match(/Android/i) ){
                w.inputType = 'number';
            } else {
                w.inputType = 'text';
            }
			
            if ( o.hideInput ) {
                w.d.wrap.hide();
            }
		
            $('label[for=\''+w.d.input.attr('id')+'\']').addClass('ui-input-text').css('verticalAlign', 'middle');

            w.d.wrap.on(o.clickEvent, function() {
                if ( !w.disabled && ( o.noButtonFocusMode || o.focusMode ) ) { 
                    w.d.input.trigger('datebox', {
                        'method': 'open'
                    });
                    w.d.wrap.addClass('ui-focus');
                    w.d.input.removeClass('ui-focus');
                }
            });
		
            w.d.input
            .removeClass('ui-corner-all ui-shadow-inset')
            .bind(w.touch?'touchend':'click', function(e){
                if ( w.disabled === false && o.useNewStyle === true && o.useFocus === false ) {
                    if ( ((w.touch ? e.originalEvent.changedTouches[0].pageX : e.pageX) - e.target.offsetLeft) > (e.target.offsetWidth - 20) ) {
                        w.d.input.trigger('datebox', {
                            'method': 'open'
                        });
                        w.d.wrap.addClass('ui-focus');
                    }
                }
            })
            .focus(function(){
                if ( w.disabled === false && o.useFocus === true ) {
                    w.d.input.trigger('datebox', {
                        'method': 'open'
                    });
                    w.d.wrap.addClass('ui-focus');
                } 
                if ( o.useNewStyle === false ) {
                    w.d.input.removeClass('ui-focus');
                }
            })
            .blur(function(){
                w.d.wrap.removeClass('ui-focus');
                w.d.input.removeClass('ui-focus');
            })
            .change(function() {
                if (w.d.input.val()) {
                    w.theDate = w._makeDate(w.d.input.val());                
                }
                w.refresh();
            })
            .attr("readonly", o.lockInput)
            .on('datebox', w._event);
			
            if ( o.useNewStyle === true ) {
                /* SAH: took out ui-shadow-inset from front of style list. */
                w.d.input.addClass('ui-corner-all '+((o.useAltIcon===true)?'ui-icon-datebox-alt':'ui-icon-datebox'));
                if ( o.overrideStyleClass !== false ) {
                    w.d.input.addClass(o.overrideStyleClass);
                }
            }
			
            // Check if mousewheel plugin is loaded
            if ( typeof $.event.special.mousewheel !== 'undefined' ) {
                w.wheelExists = true;
            }
		
            // Disable when done if element attribute disabled is true.
            if ( w.d.input.is(':disabled') ) {
                w.disable();
            }
			
            if ( o.useInline === true || o.useInlineBlind ) {
                w.open();
            }
			
            if (o.defaultValue != null &&
                o.defaultValue !== undefined) {
                w.d.input.trigger('datebox', {
                    'method':'set', 
                    'value':w.theDate ? w._formatter(w.__fmt(),w.theDate) : 0, 
                    'date':w.theDate
                    });
            }
                        
            //Throw dateboxinit event
            $( document ).trigger( "dateboxaftercreate" );
        },
        _build: {
            'default': function () {
                this.d.headerText = "Error";
                this.d.intHTML = $("<div class='ui-body-e'><h2 style='text-align:center'>There is no mode by that name loaded / mode not given</h2></div>");
            }
        },
        _doBuild: function() {
            var o = this.options;
            if ( typeof this._build[o.mode] === 'undefined' ) {
                this._build['default'].apply(this,[]);
            } else {
                this._build[o.mode].apply(this,[]);
            }  
        },
        _applyCoords: function(e) {
            var w = e.widget,
            o = e.widget.options,
            fixd = {
                h: $.mobile.activePage.find('.ui-header').jqmData('position'),
                f: $.mobile.activePage.find('.ui-footer').jqmData('position'),
                fh: $.mobile.activePage.find('.ui-footer').outerHeight(),
                hh: $.mobile.activePage.find('.ui-header').outerHeight()
            },
            iput = {
                x: w.d.wrap.offset().left + (w.d.wrap.outerWidth() / 2),
                y: w.d.wrap.offset().top + (w.d.wrap.outerHeight() / 2)
            },
            size = {
                w: w.d.mainWrap.outerWidth(),
                h: w.d.mainWrap.outerHeight()
            },
            doc = {
                t: $(window).scrollTop(),
                h: $(window).height(),
                w: $.mobile.activePage.width(),
                ah: $(document).height()
            },
            pos = {
                y: (o.centerVert) ? doc.t + ((doc.h / 2) - (size.h / 2)) : iput.y  - ( size.h / 2 ),
                x: (doc.w < 400 || o.centerHoriz ) ? (doc.w / 2) - (size.w /2) : iput.x  - (size.w / 2)
            };
            if (pos.x < 10) {
                /* SAH - make sure the edge of box is never off the screen, and provide 10px of padding on the left so that
                             * it is not right on the edge either.
                             */
                pos.x = 10;
            }
				
            if ( o.centerVert === false ) {
                if ( o.hideFixedToolbars === true && ( typeof fixd.f !== 'undefined' || typeof fixd.h !== 'undefined' )) {
                    $.mobile.activePage.find(":jqmData(position='fixed')").fixedtoolbar('hide');
                    fixd.f = undefined;
                    fixd.h = undefined;
                }
				
                if ( typeof fixd.f !== 'undefined' ) {
                    if ( ( pos.y + size.h ) > ( doc.h - fixd.fh - 2 ) ) {
                        pos.y = doc.h - fixd.fh - 2 - size.h;
                    }
                } else {
                    if ( ( pos.y + size.h ) > ( doc.ah - fixd.fh - 2 ) ) {
                        pos.y = doc.ah - fixd.fh - 2 - size.h;
                    }
                    if ( ( doc.h + doc.t ) < ( size.h + pos.y + 2 ) ) {
                        pos.y = doc.h + doc.t - size.h - 2;
                    }
                }
				
                if ( typeof fixd.h !== 'undefined' ) {
                    if ( ( doc.t + fixd.hh + 2 ) > pos.y ) {
                        pos.y = doc.t + fixd.hh + 2;
                    }
                } else {
                    if ( fixd.hh + 2 > pos.y ) {
                        pos.y = fixd.hh + 2;
                    }
                    if ( pos.y < doc.t + 2 ) {
                        pos.y = doc.t + 2;
                    }
                }
            }
            w.d.mainWrap.css({
                'position': 'absolute', 
                'top': pos.y, 
                'left': pos.x
                });
        },
        _drag: {
            'default': function () {
                return false;
            }
        },
        open: function () {
            var w = this,
            o = this.options,
            qns = 'data-'+this.ns,
            trans = o.useAnimation ? o.transition : 'none';
			
            if ( o.useFocus === true && w.fastReopen === true ) {
                w.d.input.blur();
                return false;
            }
            if ( w.clearFunc !== false ) {
                clearTimeout(w.clearFunc);
                w.clearFunc = false;
            }
			
            // Call the open callback if provided. Additionally, if this
            // returns false then the open/update will stop.
            if ( o.openCallback !== false ) {
                if ( ! $.isFunction(o.openCallback) ) {
                    if ( typeof window[o.openCallback] !== 'undefined' ) {
                        o.openCallback = window[o.openCallback];
                    }
                    else {
                        o.openCallback = new Function(o.openCallback);
                    }
                }
                if ( o.openCallback.apply(w, $.merge([w.theDate],o.openCallbackArgs)) === false ) {
                    return false;
                }
            }
				
            w.theDate = w._makeDate(w.d.input.val());
            w.d.input.blur();
			
            if ( typeof w._build[o.mode] === 'undefined' ) {
                w._build['default'].apply(w,[]);
            } else {
                w._build[o.mode].apply(w,[]);
            }
            if ( typeof w._drag[o.mode] !== 'undefined' ) {
                w._drag[o.mode].apply(w, []);
            }
            w.d.input.trigger('datebox', {
                'method':'refresh'
            });
            if ( w.__('useArabicIndic') === true ) {
                w._doIndic();
            }
			
            if ( ( o.useInline === true || o.useInlineBlind === true ) && w.initDone === false ) {
                w.d.mainWrap.append(w.d.intHTML);
                w.d.input.parent().parent().append(w.d.mainWrap);
                w.d.mainWrap.removeClass('ui-datebox-hidden');
                if ( o.useInline === true ) {
                    w.d.mainWrap.addClass('ui-datebox-inline');
                } else {
                    w.d.mainWrap.addClass('ui-datebox-inlineblind');
                    w.d.mainWrap.hide();
                }
                w.initDone = false;
                w.d.input.trigger('datebox',{
                    'method':'postrefresh'
                });
            }
			
            if ( o.useImmediate ) {
                w.d.input.trigger('datebox', {
                    'method':'doset'
                });
            }
            if ( o.useInline ) {
                return true;
            }
            if ( o.useInlineBlind ) { 
                if ( w.initDone ) {
                    w.d.mainWrap.slideDown();
                }
                else {
                    w.initDone = true;
                }
                return true;
            }
            if ( w.d.intHTML.is(':visible') ) {
                return false;
            } // Ignore if already open
				
            if ( o.dialogForce || ( o.dialogEnable && window.width() < 400 ) ) {
                w.d.dialogPage = $("<div "+qns+"role='dialog' "+qns+"theme='"+o.theme+"' >" +
                    "<div "+qns+"role='header' "+qns+"theme='"+o.themeHeader+"'>" +
                    "<h1>"+w.d.headerText+"</h1></div><div "+qns+"role='content'></div>")
                .appendTo( $.mobile.pageContainer )
                .page().css('minHeight', '0px').addClass(trans);
                w.d.dialogPage.find('.ui-header').find('a').off('click vclick').on(o.clickEventAlt, function(e) {
                    e.preventDefault();
                    w.d.input.trigger('datebox', {
                        'method':'close'
                    });
                });
                w.d.mainWrap.append(w.d.intHTML).css({
                    'marginLeft':'auto', 
                    'marginRight':'auto'
                }).removeClass('ui-datebox-hidden');
                w.d.dialogPage.find('.ui-content').append(w.d.mainWrap);
                w.d.input.trigger('datebox',{
                    'method':'postrefresh'
                });
                $.mobile.activePage.off( "pagehide.remove" );
                $.mobile.changePage(w.d.dialogPage, {
                    'transition': trans
                });
            }
            else {
                w.d.dialogPage = false;
                w.d.mainWrap.empty();
                if ( o.useHeader === true ) {
                    w.d.headHTML = $('<div class="ui-header ui-bar-'+o.themeHeader+'"></div>');
                    $("<a class='ui-btn-left' href='#'>Close</a>").appendTo(w.d.headHTML)
                    .buttonMarkup({
                        theme  : o.themeHeader, 
                        icon   : 'delete', 
                        iconpos: 'notext', 
                        corners: true, 
                        shadow : true
                    })
                    .on(o.clickEventAlt, function(e) {
                        e.preventDefault();
                        w.d.input.trigger('datebox', {
                            'method':'close'
                        });
                    });
                    $('<h1 class="ui-title">'+w.d.headerText+'</h1>').appendTo(w.d.headHTML);
                    w.d.mainWrap.append(w.d.headHTML);
                }
                w.d.mainWrap.append(w.d.intHTML).css('zIndex', o.zindex);
                w.d.mainWrap.appendTo($.mobile.activePage);
                w.d.screen.appendTo($.mobile.activePage);
                w.d.input.trigger('datebox',{
                    'method':'postrefresh'
                });
                w._applyCoords({
                    widget:w
                });
				
                if ( o.useModal === true ) { 
                    if(o.useAnimation) {
                        w.d.screen.fadeIn('slow');
                    } else {
                        w.d.screen.show();
                    }

                } else {
                    setTimeout(function () {
                        w.d.screen.removeClass('ui-datebox-hidden');
                    }, 500);
                }
				
                w.d.mainWrap.addClass('ui-overlay-shadow in').removeClass('ui-datebox-hidden');
				
                $(document).on('orientationchange.datebox', {
                    widget:w
                }, function(e) {
                    w._applyCoords(e.data);
                });
                if ( o.resizeListener === true ) {
                    $(window).on('resize.datebox', {
                        widget:w
                    }, function (e) {
                        w._applyCoords(e.data);
                    });
                }
            }
        },
        close: function() {
            var w = this,
            o = this.options;
			
            if ( o.useInlineBlind === true ) {
                w.d.mainWrap.slideUp();
                return true;
            }
            if ( o.useInline === true ) {
                return true;
            }

            if ( w.d.dialogPage !== false ) {
                $(w.d.dialogPage).dialog('close');
				
                if ( ! $.mobile.activePage.jqmData('page').options.domCache ) {
                    $.mobile.activePage.on('pagehide.remove', function () {
                        $(this).remove();
                    });
                }
				
                w.d.intHTML.detach().empty();
                w.d.mainWrap.detach().empty();
                w.d.wrap.removeClass('ui-focus');
                w.clearFunc = setTimeout(function () {
                    w.d.dialogPage.empty().remove();
                    w.clearFunc = false;
                }, 1500);
            } else {
                if ( o.useModal ) {
                    if(o.useAnimation) {
                        w.d.screen.fadeOut('slow');
                    } else {
                        w.d.screen.hide();
                    }

                } else {
                    w.d.screen.addClass('ui-datebox-hidden');
                }
                w.d.screen.detach();
                w.d.mainWrap.addClass('ui-datebox-hidden').removeAttr('style').removeClass('in ui-overlay-shadow').empty().detach();
                w.d.intHTML.detach();
                w.d.wrap.removeClass('ui-focus');
				
                $(document).off('orientationchange.datebox');
                if ( o.resizeListener === true ) {
                    $(window).off('resize.datebox');
                }
            }
					
            $(document).off(w.drag.eMove);
            $(document).off(w.drag.eEnd);
            $(document).off(w.drag.eEndA);
			
            if ( o.useFocus ) { 
                w.fastReopen = true;
                setTimeout(function(t) {
                    return function () {
                        t.fastReopen = false;
                    };
                
                }(w), 300);
        }
			
        if ( o.closeCallback !== false ) {
            if ( ! $.isFunction(o.closeCallback) ) {
                if ( typeof window[o.closeCallback] !== 'undefined' ) {
                    o.closeCallback = window[o.closeCallback];
                } else {
                    o.closeCallback = new Function(o.closeCallback);
                }
            }
            o.closeCallback.apply(w, $.merge([w.theDate], o.closeCallbackArgs));
        }
    },
    refresh: function() {
        // SAH: this code refreshes the actual visual display of the date in the input
        // component (e.g., the flipbox). However, refresh may be called often - i.e., any
        // time that d.input changes values. The open: method is already responsible for
        // refreshing the visual display of the component.
        /*if ( typeof this._build[this.options.mode] === 'undefined' ) {
            this._build['default'].apply(this,[]);
        } else {
            this._build[this.options.mode].apply(this,[]);
        }*/
        if ( this.__('useArabicIndic') === true ) {
            this._doIndic();
        }
        this.d.mainWrap.append(this.d.intHTML);
        this.d.input.trigger('datebox',{
            'method':'postrefresh'
        });
    },
    _check: function() {
        var w = this,
        td = null,
        o = this.options;
			
        w.dateOK = true;
			
        if ( o.afterToday !== false ) {
            td = new w._date();
            if ( w.theDate < td ) {
                w.theDate = td;
            }
        }
        if ( o.beforeToday !== false ) {
            td = new w._date();
            if ( w.theDate > td ) {
                w.theDate = td;
            }
        }
        if ( o.maxDays !== false ) {
            td = new w._date();
            td.adj(2, o.maxDays);
            if ( w.theDate > td ) {
                w.theDate = td;
            }
        }
        if ( o.minDays !== false ) {
            td = new w._date();
            td.adj(2, -1*o.minDays);
            if ( w.theDate < td ) {
                w.theDate = td;
            }
        }
        if ( o.minHour !== false ) {
            if ( w.theDate.getHours() < o.minHour ) {
                w.theDate.setHours(o.minHour);
            }
        }
        if ( o.maxHour !== false ) {
            if ( w.theDate.getHours() > o.maxHour ) {
                w.theDate.setHours(o.maxHour);
            }
        }
        if ( o.maxYear !== false ) {
            td = new w._date(o.maxYear, 0, 1);
            td.adj(2, -1);
            if ( w.theDate > td ) {
                w.theDate = td;
            }
        }
        if ( o.minYear !== false ) {
            td = new w._date(o.minYear, 0, 1);
            if ( w.theDate < td ) {
                w.theDate = td;
            }
        }
			
        if ( $.inArray(o.mode, ['timebox','durationbox','timeflipbox']) > -1 ) { 
            if ( o.mode === 'timeflipbox' && o.validHours !== false ) {
                if ( $.inArray(w.theDate.getHours(), o.validHours) < 0 ) {
                    w.dateOK = false;
                }
            }
        } else {
            if ( o.blackDates !== false ) {
                if ( $.inArray(w.theDate.iso(), o.blackDates) > -1 ) {
                    w.dateOK = false;
                }
            }
            if ( o.blackDays !== false ) {
                if ( $.inArray(w.theDate.getDay(), o.blackDays) > -1 ) {
                    w.dateOK = false;
                }
            }
        }
    },
    _grabLabel: function() {
        var w = this,
        o = this.options;
				
        if ( typeof o.overrideDialogLabel === 'undefined' ) {
            if ( typeof w.d.input.attr('title') !== 'undefined' ) {
                return w.d.input.attr('title');
            }
            if ( w.d.wrap.parent().find('label[for='+w.d.input.attr('id')+']').text() !== '' ) {
                return w.d.wrap.parent().find('label[for='+w.d.input.attr('id')+']').text();
            }
            return false;
        }
        return o.overrideDialogLabel;
    },
    _makeEl: function(source, parts) {
        var part = false,
        retty = false;
			
        retty = source.clone();
			
        if ( typeof parts.attr !== 'undefined' ) {
            for ( part in parts.attr ) {
                if ( parts.attr.hasOwnProperty(part) ) {
                    retty.jqmData(part, parts.attr[part]);
                }
            }
        }
        return retty;
    },
    _getLongOptions: function(element) {
        var key, retty = {}, prefix, temp;
			
        if ( $.mobile.ns === "" ) { 
            prefix = "datebox";
        } else { 
            prefix = $.mobile.ns.substr(0, $.mobile.ns.length - 1) + 'Datebox';
        }
			
        for ( key in element.data() ) {
            if ( key.substr(0, prefix.length) === prefix && key.length > prefix.length ) {
                temp = key.substr(prefix.length);
                temp = temp.charAt(0).toLowerCase() + temp.slice(1);
                retty[temp] = element.data(key);
            }
        }
        return retty;
    },
    disable: function(){
        // Disable the element
        this.d.input.attr("disabled",true);
        this.d.wrap.addClass("ui-disabled").blur();
        this.disabled = true;
        this.d.input.trigger('datebox', {
            'method':'disable'
        });
    },
    enable: function(){
        // Enable the element
        this.d.input.attr("disabled", false);
        this.d.wrap.removeClass("ui-disabled");
        this.disabled = false;
        this.d.input.trigger('datebox', {
            'method':'enable'
        });
    },
    get: function() {
        if (this.d.input.val()) {
            return this.theDate;
        }
        return null;
    },
    _setOption: function() {
        $.Widget.prototype._setOption.apply( this, arguments );
        this.refresh();
    }
    });
	  
// Degrade date inputs to text inputs, suppress standard UI functions.
$( document ).on( "pagebeforecreate", function( e ) {
    $( ":jqmData(role='datebox')", e.target ).each(function() {
        $(this).prop('type', 'text');
    });
});
// Automatically bind to data-role='datebox' items.
$( document ).on( "pagecreate create", function( e ){
    $( document ).trigger( "dateboxbeforecreate" );
    $( ":jqmData(role='datebox')", e.target ).each(function() {
        if ( typeof($(this).jqmData('datebox')) === "undefined" ) {
            $(this).datebox();
        }
    });
});
})( jQuery );
;/*
 * jQuery Mobile Framework : plugin to provide a date and time picker.
 * Copyright (c) JTSage
 * CC 3.0 Attribution.  May be relicensed without permission/notification.
 * https://github.com/jtsage/jquery-mobile-datebox
 */
/* FLIPBOX Mode */

(function($) {
    $.extend( $.mobile.datebox.prototype.options, {
        themeDateHigh: 'e',
        themeDatePick: 'a',
        themeDate: 'd',
        useSetButton: true,
        validHours: false,
        flen: {
            'y': 15, 
            'm':12, 
            'd':15, 
            'h':12, 
            'i':15, 
            'a':3
        }
    });
    $.extend( $.mobile.datebox.prototype, {
        '_fbox_pos': function () {
            var w = this,
            ech = null,
            top = null,
            par = this.d.intHTML.find('.ui-datebox-flipcontent').innerHeight(),
            tot = null;
				
            w.d.intHTML.find('.ui-datebox-flipcenter').each(function() {
                ech = $(this);
                top = ech.innerHeight();
                ech.css('top', ((par/2)-(top/2)+4)*-1);
            });
            w.d.intHTML.find('ul').each(function () {
                ech = $(this);
                par = ech.parent().innerHeight();
                top = ech.find('li').first();
                tot = ech.find('li').size() * top.outerHeight();
                top.css('marginTop', ((tot/2)-(par/2)+(top.outerHeight()/2))*-1);
            });
        }
    });
    $.extend( $.mobile.datebox.prototype._build, {
        'timeflipbox': function() {
            this._build.flipbox.apply(this);
        },
        'flipbox': function () {
            var w = this,
            o = this.options, i, y, hRow, tmp, testDate,
            iDate = this._makeDate(this.d.input.val()),
            uid = 'ui-datebox-',
            flipBase = $("<div class='ui-overlay-shadow'><ul></ul></div>"),
            ctrl = $("<div>", {
                "class":uid+'flipcontent'
                });
			
            if ( typeof w.d.intHTML !== 'boolean' ) {
                w.d.intHTML.empty();
            }
			
            w.d.input.on('datebox', function (e,p) {
                if ( p.method === 'postrefresh' ) {
                    w._fbox_pos();
                }
            });
			
            w.d.headerText = ((w._grabLabel() !== false)?w._grabLabel():((o.mode==='flipbox')?w.__('titleDateDialogLabel'):w.__('titleTimeDialogLabel')));
            w.d.intHTML = $('<span>')
			
            w.fldOrder = ((o.mode==='flipbox')?w.__('dateFieldOrder'):w.__('timeFieldOrder'));
            w._check();
            w._minStepFix();
			
            if ( o.mode === 'flipbox' ) { 
                $('<div class="'+uid+'header"><h4>'+w._formatter(w.__('headerFormat'), w.theDate)+'</h4></div>').appendTo(w.d.intHTML); 
            }
			
            w.d.intHTML.append(ctrl);
			
            for ( y=0; y<w.fldOrder.length; y++ ) {
                switch (w.fldOrder[y]) {
                    case 'y':
                        hRow = w._makeEl(flipBase, {
                            'attr': {
                                'field':'y',
                                'amount':1
                            }
                        });
                        for ( i=o.flen.y*-1; i<(o.flen.y+1); i++ ) {
                            tmp = (i!==0)?((iDate.get(0) === (w.theDate.get(0) + i))?o.themeDateHigh:o.themeDate):o.themeDatePick;
                            $('<li>', {
                                'class':'ui-body-'+tmp
                                })
                            .html('<span>'+(w.theDate.get(0)+i)+'</span>').appendTo(hRow.find('ul'));
                        }
                        hRow.appendTo(ctrl);
                        break;
                    case 'm':
                        hRow = w._makeEl(flipBase, {
                            'attr': {
                                'field':'m',
                                'amount':1
                            }
                        });
                        for ( i=o.flen.m*-1; i<(o.flen.m+1); i++ ) {
                            testDate = w.theDate.copy([0],[0,0,1]);
                            testDate.adj(1,i);
                            tmp = (i!==0)?((iDate.get(1) === testDate.get(1) && iDate.get(0) === testDate.get(0))?o.themeDateHigh:o.themeDate):o.themeDatePick;
                            $("<li>", {
                                'class' : 'ui-body-'+tmp
                                })
                            .html("<span>"+w.__('monthsOfYearShort')[testDate.getMonth()]+"</span>").appendTo(hRow.find('ul'));
                        }
                        hRow.appendTo(ctrl);
                        break;
                    case 'd':
                        hRow = w._makeEl(flipBase, {
                            'attr': {
                                'field':'d',
                                'amount':1
                            }
                        });
                        for ( i=o.flen.d*-1; i<(o.flen.d+1); i++ ) {
                            testDate = w.theDate.copy();
                            testDate.adj(2,i);
                            tmp = (i!==0)?((iDate.comp() === testDate.comp())?o.themeDateHigh:o.themeDate):o.themeDatePick;
                            if ( ( o.blackDates !== false && $.inArray(testDate.iso(), o.blackDates) > -1 ) ||
                                ( o.blackDays !== false && $.inArray(testDate.getDay(), o.blackDays) > -1 ) ) {
                                tmp += ' '+uid+'griddate-disable';
                            }
                            $("<li>", {
                                'class' : 'ui-body-'+tmp
                                })
                            .html("<span>"+testDate.getDate()+"</span>").appendTo(hRow.find('ul'));
                        }
                        hRow.appendTo(ctrl);
                        break;
                    case 'h':
                        hRow = w._makeEl(flipBase, {
                            'attr': {
                                'field':'h',
                                'amount':1
                            }
                        });
                        for ( i=o.flen.h*-1; i<(o.flen.h+1); i++ ) {
                            testDate = w.theDate.copy();
                            testDate.adj(3,i);
                            tmp = (i!==0)?o.themeDate:o.themeDatePick;
                            if ( o.validHours !== false && $.inArray(testDate.get(3), o.validHours) < 0 ) {
                                tmp += ' '+uid+'griddate-disable';
                            }
                            $("<li>", {
                                'class' : 'ui-body-'+tmp
                                })
                            .html("<span>"+((w.__('timeFormat')===12) ? (( testDate.get(3) === 0 ) ? '12' : (( testDate.get(3) < 13 ) ? testDate.get(3) : (testDate.get(3)-12))) : testDate.get(3))+"</span>").appendTo(hRow.find('ul'));
                        }
                        hRow.appendTo(ctrl);
                        break;
                    case 'i':
                        hRow = w._makeEl(flipBase, {
                            'attr': {
                                'field':'i',
                                'amount':o.minuteStep
                                }
                            });
                        for ( i=o.flen.i*-1; i<(o.flen.i+1); i++ ) {
                            testDate = w.theDate.copy();
                            testDate.adj(4,(i*o.minuteStep));
                            tmp = (i!==0)?o.themeDate:o.themeDatePick;
                            $("<li>", {
                                'class' : 'ui-body-'+tmp
                                })
                            .html("<span>"+w._zPad(testDate.get(4))+"</span>").appendTo(hRow.find('ul'));
                        }
                        hRow.appendTo(ctrl);
                        break;
                    case 'a':
                        if ( w.__('timeFormat') !== 12 ) {
                            break;
                        }
                        hRow = w._makeEl(flipBase, {
                            'attr': {
                                'field':'a',
                                'amount':1
                            }
                        });
                        testDate = $("<li class='ui-body-"+o.themeDate+"'><span> </span></li>");

                        for ( i=0; i<o.flen.a; i++ ) {
                            testDate.clone().appendTo(hRow.find('ul'));
                        }
                        if ( w.theDate.get(3) < 12 ) {
                            testDate.clone().appendTo(hRow.find('ul'));
                        }

                        tmp = (w.theDate.get(3) > 11) ? [o.themeDate,o.themeDatePick] : [o.themeDatePick,o.themeDate];

                        $("<li>", {
                            'class' : 'ui-body-'+tmp[0]
                            }).html('<span>'+w.__('meridiem')[0]+'</span>').appendTo(hRow.find('ul'));
                        $("<li>", {
                            'class' : 'ui-body-'+tmp[1]
                            }).html('<span>'+w.__('meridiem')[1]+'</span>').appendTo(hRow.find('ul'));

                        if ( w.theDate.get(3) > 11 ) {
                            testDate.clone().appendTo(hRow.find('ul'));
                        }
                        for ( i=0; i<o.flen.a; i++ ) {
                            testDate.clone().appendTo(hRow.find('ul'));
                        }

                        hRow.appendTo(ctrl);
                        break;
                }
            }
			
            $("<div>", {
                "class":uid+'flipcenter ui-overlay-shadow'
                }).css('pointerEvents', 'none').appendTo(w.d.intHTML);

            if ( o.useSetButton || o.useClearButton ) {
                y = $('<div>', {
                    'class':uid+'controls'
                    });

                if ( o.useSetButton ) {
                    $('<a href="#">'+((o.mode==='flipbox')?w.__('setDateButtonLabel'):w.__('setTimeButtonLabel'))+'</a>')
                    .appendTo(y).buttonMarkup({
                        theme: o.theme, 
                        icon: 'check', 
                        iconpos: 'left', 
                        corners:true, 
                        shadow:true
                    })
                    .on(o.clickEventAlt, function(e) {
                        e.preventDefault();
                        if ( w.dateOK === true ) {
                            w.d.input.trigger('datebox', {
                                'method':'set', 
                                'value':w._formatter(w.__fmt(),w.theDate), 
                                'date':w.theDate
                                });
                            w.d.input.trigger('datebox', {
                                'method':'close'
                            });
                        }
                    });
                }
                if ( o.useClearButton ) {
                    $('<a href="#">'+w.__('clearButton')+'</a>')
                    .appendTo(y).buttonMarkup({
                        theme: o.theme, 
                        icon: 'delete', 
                        iconpos: 'left', 
                        corners:true, 
                        shadow:true
                    })
                    .on(o.clickEventAlt, function(e) {
                        e.preventDefault();
                        w.d.input.val('');
                        w.d.input.trigger('datebox',{
                            'method':'clear'
                        });
                        w.d.input.trigger('datebox',{
                            'method':'close'
                        });
                    });
                }
                if ( o.useCollapsedBut ) {
                    y.addClass('ui-datebox-collapse');
                }
                y.appendTo(w.d.intHTML);
            }

            if ( w.wheelExists ) { // Mousewheel operation, if plugin is loaded
                w.d.intHTML.on('mousewheel', '.ui-overlay-shadow', function(e,d) {
                    e.preventDefault();
                    w._offset($(this).jqmData('field'), ((d<0)?-1:1)*$(this).jqmData('amount'));
                });
            }

            w.d.intHTML.on(w.drag.eStart, 'ul', function(e,f) {
                if ( !w.drag.move ) {
                    if ( typeof f !== "undefined" ) {
                        e = f;
                    }
                    w.drag.move = true;
                    w.drag.target = $(this).find('li').first();
                    w.drag.pos = parseInt(w.drag.target.css('marginTop').replace(/px/i, ''),10);
                    w.drag.start = w.touch ? e.originalEvent.changedTouches[0].pageY : e.pageY;
                    w.drag.end = false;
                    e.stopPropagation();
                    e.preventDefault();
                }
            });

            w.d.intHTML.on(w.drag.eStart, '.'+uid+'flipcenter', function(e) { // Used only on old browsers and IE.
                if ( !w.drag.move ) {
                    w.drag.target = w.touch ? e.originalEvent.changedTouches[0].pageX - $(e.currentTarget).offset().left : e.pageX - $(e.currentTarget).offset().left;
                    w.drag.tmp = w.d.intHTML.find('.'+uid+'flipcenter').innerWidth() / (( $.inArray('a', w.fldOrder) > -1 && w.__('timeFormat') !== 12 )?w.fldOrder.length-1:w.fldOrder.length);
                    $(w.d.intHTML.find('ul').get(parseInt(w.drag.target / w.drag.tmp,10))).trigger(w.drag.eStart,e);
                }
            });
        }
    });
    $.extend( $.mobile.datebox.prototype._drag, {
        'timeflipbox': function() {
            this._drag.flipbox.apply(this);
        },
        'flipbox': function() {
            var w = this,
            o = this.options,
            g = this.drag;

            $(document).on(g.eMove, function(e) {
                if ( g.move && ( o.mode === 'flipbox' || o.mode === 'timeflipbox' )) {
                    g.end = w.touch ? e.originalEvent.changedTouches[0].pageY : e.pageY;
                    g.target.css('marginTop', (g.pos + g.end - g.start) + 'px');
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            });

            $(document).on(g.eEnd, function(e) {
                if ( g.move && (o.mode === 'flipbox' || o.mode === 'timeflipbox' )) {
                    g.move = false;
                    if ( g.end !== false ) {
                        e.preventDefault();
                        e.stopPropagation();
                        g.tmp = g.target.parent().parent();
                        //w._offset(g.tmp.jqmData('field'), (parseInt((g.start - g.end) / g.target.innerHeight(),10) * g.tmp.jqmData('amount')));
                        var _amt = g.tmp.jqmData('amount');
                        w._offset(g.tmp.jqmData('field'), (Math.round((g.start - g.end) / g.target.innerHeight()) * _amt));
                    }
                    g.start = false;
                    g.end = false;
                }
            });
        }
    });
})( jQuery );
;/*!
 * FullCalendar v1.6.4
 * Docs & License: http://arshaw.com/fullcalendar/
 * (c) 2013 Adam Shaw
 */

/*
 * Use fullcalendar.css for basic styling.
 * For event drag & drop, requires jQuery UI draggable.
 * For event resizing, requires jQuery UI resizable.
 */
 
(function($, undefined) {


;;

var defaults = {

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	weekNumbers: false,
	weekNumberCalculation: 'iso',
	weekNumberTitle: 'W',
	
	// editing
	//editable: false,
	//disableDragging: false,
	//disableResizing: false,
	
	allDayDefault: true,
	ignoreTimezone: true,
	
	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	
	// time formats
	titleFormat: {
		// month: 'MMMM yyyy',
                month: "MMMM '&#39;'yy",
		//week: "MMM d[ yyyy]{ '&#8212;'[ MMM] d yyyy}",
                week: "MMM d[ yy]{ '&#8212;'[ MMM] d '&#39;'yy}",
		//day: 'dddd, MMM d, yyyy'
                day: "MMM d, '&#39;'yy"
	},
	columnFormat: {
		month: 'ddd',
		week: 'ddd M/d',
		day: 'dddd M/d'
	},
	timeFormat: { // for event elements
		'': 'h(:mm)t' // default
	},
	
	// locale
	isRTL: false,
	firstDay: 0,
	monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],
	monthNamesShort: ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
	dayNames: ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
	dayNamesShort: ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
	buttonText: {
		prev: "<span class='fc-text-arrow'>&lsaquo;</span>",
		next: "<span class='fc-text-arrow'>&rsaquo;</span>",
		prevYear: "<span class='fc-text-arrow'>&laquo;</span>",
		nextYear: "<span class='fc-text-arrow'>&raquo;</span>",
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},
	
	// jquery-ui theming
	theme: false,
	buttonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e'
	},
	
	//selectable: false,
	unselectAuto: true,
	
	dropAccept: '*',
	
	handleWindowResize: true,

        /* SAH - layout full page with the calendar contents scrolling. */
        fullPage : true,
        
        /* SAH - offset event start/end by a timezone offset. tzOffset is the standard time offset.
         * dstOffset is the daylight savings time offset. The default is to offset based on the browser
         * locale.
         */
        tzOffset : -((new Date()).getTimezoneOffset() / 60.0),
        dstOffset : -((new Date((new Date()).getUTCFullYear(), 6, 1)).getTimezoneOffset() / 60.0),
        
        /* SAH - when the user clicks on the calendar, treat all clicks like slot clicks even if the user
         * clicks on an event. This is useful in the free/busy view where events appear on the calendar but
         * the user taps to select a time slot, not an event.
         */
        passThroughEventClicks: false,
        
        /**
         * SAH - parameterized the right column buffer used in the calendar.
         */
        rightBuffer: .025
};

// right-to-left defaults
var rtlDefaults = {
	header: {
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonText: {
		prev: "<span class='fc-text-arrow'>&rsaquo;</span>",
		next: "<span class='fc-text-arrow'>&lsaquo;</span>",
		prevYear: "<span class='fc-text-arrow'>&raquo;</span>",
		nextYear: "<span class='fc-text-arrow'>&laquo;</span>"
	},
	buttonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w'
	}
};



;;

var fc = $.fullCalendar = { version: "1.6.4" };
var fcViews = fc.views = {};


$.fn.fullCalendar = function(options) {


	// method calling
	if (typeof options == 'string') {
		var args = Array.prototype.slice.call(arguments, 1);
		var res;
		this.each(function() {
			var calendar = $.data(this, 'fullCalendar');
			if (calendar && $.isFunction(calendar[options])) {
				var r = calendar[options].apply(calendar, args);
				if (res === undefined) {
					res = r;
				}
				if (options == 'destroy') {
					$.removeData(this, 'fullCalendar');
				}
			}
		});
		if (res !== undefined) {
			return res;
		}
		return this;
	}

	options = options || {};
	
	// would like to have this logic in EventManager, but needs to happen before options are recursively extended
	var eventSources = options.eventSources || [];
	delete options.eventSources;
	if (options.events) {
		eventSources.push(options.events);
		delete options.events;
	}
	

	options = $.extend(true, {},
		defaults,
		(options.isRTL || options.isRTL===undefined && defaults.isRTL) ? rtlDefaults : {},
		options
	);
	
	
	this.each(function(i, _element) {
		var element = $(_element);
		var calendar = new Calendar(element, options, eventSources);
		element.data('fullCalendar', calendar); // TODO: look into memory leak implications
		calendar.render();
	});
	
	
	return this;
	
};


// function for adding/overriding defaults
function setDefaults(d) {
	$.extend(true, defaults, d);
}



;;

 
function Calendar(element, options, eventSources) {
	var t = this;
	
	
	// exports
	t.options = options;
	t.render = render;
	t.destroy = destroy;
	t.refetchEvents = refetchEvents;
	t.reportEvents = reportEvents;
	t.reportEventChange = reportEventChange;
	t.rerenderEvents = rerenderEvents;
	t.changeView = changeView;
	t.select = select;
	t.unselect = unselect;
	t.prev = prev;
	t.next = next;
	t.prevYear = prevYear;
	t.nextYear = nextYear;
	t.today = today;
	t.gotoDate = gotoDate;
	t.incrementDate = incrementDate;
	t.formatDate = function(format, date) { return formatDate(format, date, options) };
	t.formatDates = function(format, date1, date2) { return formatDates(format, date1, date2, options) };
	t.getDate = getDate;
	t.getView = getView;
	t.option = option;
	t.trigger = trigger;
        t.contentOffset = getContentOffset;
        t.gotoHour = gotoHour;
	
	
	// imports
	EventManager.call(t, options, eventSources);
	var isFetchNeeded = t.isFetchNeeded;
	var fetchEvents = t.fetchEvents;
	
	
	// locals
	var _element = element[0];
	var header;
	var headerElement;
	var content;
	var tm; // for making theme classes
	var currentView;
	var elementOuterWidth;
	var suggestedViewHeight;
	var resizeUID = 0;
	var ignoreWindowResize = 0;
	var date = new Date();
	var events = [];
	var _dragElement;
	
	
	
	/* Main Rendering
	-----------------------------------------------------------------------------*/
	
	
	setYMD(date, options.year, options.month, options.date);
	
	
	function render(inc) {
		if (!content) {
			initialRender();
		}
		else if (elementVisible()) {
			// mainly for the public API
			calcSize();
			_renderView(inc);
		}
	}
	
	
	function initialRender() {
		tm = options.theme ? 'ui' : 'fc';
		element.addClass('fc');
		if (options.isRTL) {
			element.addClass('fc-rtl');
		}
		else {
			element.addClass('fc-ltr');
		}
		if (options.theme) {
			element.addClass('ui-widget');
		}
                var fullheightStyle = '';
                fullheightStyle = 'hx-layout-full-height hx-no-scroll';
                
                var markup = "<div class='fc-content " + fullheightStyle + "' style='position:relative'/>"
		content = $(markup)
			.prependTo(element);

		header = new Header(t, options);
		headerElement = header.render();
		if (headerElement) {
			element.prepend(headerElement);
		}

		changeView(options.defaultView);

		if (options.handleWindowResize) {
			$(window).resize(windowResize);
		}

		// needed for IE in a 0x0 iframe, b/c when it is resized, never triggers a windowResize
		if (!bodyVisible()) {
			lateRender();
		}
	}
	
	
	// called when we know the calendar couldn't be rendered when it was initialized,
	// but we think it's ready now
	function lateRender() {
		setTimeout(function() { // IE7 needs this so dimensions are calculated correctly
			if (!currentView.start && bodyVisible()) { // !currentView.start makes sure this never happens more than once
				renderView();
			}
		},0);
	}
	
	
	function destroy() {

		if (currentView) {
			trigger('viewDestroy', currentView, currentView, currentView.element);
			currentView.triggerEventDestroy();
		}

		$(window).unbind('resize', windowResize);

		header.destroy();
		content.remove();
		element.removeClass('fc fc-rtl ui-widget');
	}
	
	
	function elementVisible() {
		return element.is(':visible');
	}
	
	
	function bodyVisible() {
		return $('body').is(':visible');
	}
	
	
	
	/* View Rendering
	-----------------------------------------------------------------------------*/
	

	function changeView(newViewName) {
		if (!currentView || newViewName != currentView.name) {
			_changeView(newViewName);
		}
	}


	function _changeView(newViewName) {
		ignoreWindowResize++;

		if (currentView) {
			trigger('viewDestroy', currentView, currentView, currentView.element);
			unselect();
			currentView.triggerEventDestroy(); // trigger 'eventDestroy' for each event
			freezeContentHeight();
			currentView.element.remove();
			header.deactivateButton(currentView.name);
		}

		header.activateButton(newViewName);

                var fullheightStyle = '';
                if (newViewName === 'month') {
                    fullheightStyle = 'pm-layout-full-height hx-scroller-nozoom';
                    if ($.mobile.activePage) {
                        $.mobile.activePage.off('pageshow.fc').on('pageshow.fc', function() {
                            $(content).find('.fc-view-month').scrollTop(0);
                        });
                    }
                } else {
                    fullheightStyle = 'pm-layout-full-height hx-no-scroll';
                }
                var markup = "<div class='fc-view " + fullheightStyle + " fc-view-" + newViewName + "' style='position:relative'/>";

		currentView = new fcViews[newViewName](
			$(markup)
				.appendTo(content),
			t // the calendar object
		);

		renderView();
		unfreezeContentHeight();

		ignoreWindowResize--;
	}


	function renderView(inc) {
		if (
			!currentView.start || // never rendered before
			inc || date < currentView.start || date >= currentView.end // or new date range
		) {
                        // SAH - we render on pagebeforeshow, when this page is NOT visible.
			//if (elementVisible()) {
				_renderView(inc);
			//}
		}
	}


	function _renderView(inc) { // assumes elementVisible
		ignoreWindowResize++;

		if (currentView.start) { // already been rendered?
			trigger('viewDestroy', currentView, currentView, currentView.element);
			unselect();
			clearEvents();
		}

		freezeContentHeight();
		currentView.render(date, inc || 0); // the view's render method ONLY renders the skeleton, nothing else
		setSize();
		unfreezeContentHeight();
		(currentView.afterRender || noop)();

		updateTitle();
		updateTodayButton();

		trigger('viewRender', currentView, currentView, currentView.element);
		currentView.trigger('viewDisplay', _element); // deprecated

		ignoreWindowResize--;

		getAndRenderEvents();
	}
	
	

	/* Resizing
	-----------------------------------------------------------------------------*/
	
	
	function updateSize() {
		if (elementVisible()) {
			unselect();
			clearEvents();
			calcSize();
			setSize();
			renderEvents();
		}
	}
	
	
	function calcSize() { // assumes elementVisible
		if (options.contentHeight) {
			suggestedViewHeight = options.contentHeight;
		}
		else if (options.height) {
			suggestedViewHeight = options.height - (headerElement ? headerElement.height() : 0) - vsides(content);
		}
		else {
			suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
		}
	}
	
	
	function setSize() { // assumes elementVisible

		if (suggestedViewHeight === undefined) {
			calcSize(); // for first time
				// NOTE: we don't want to recalculate on every renderView because
				// it could result in oscillating heights due to scrollbars.
		}

		ignoreWindowResize++;
		currentView.setHeight(suggestedViewHeight, options.viewPortHeight);
		currentView.setWidth(content.width());
		ignoreWindowResize--;

		elementOuterWidth = element.outerWidth();
	}
	
	
	function windowResize() {
		if (!ignoreWindowResize) {
			if (currentView.start) { // view has already been rendered
				var uid = ++resizeUID;
				setTimeout(function() { // add a delay
					if (uid == resizeUID && !ignoreWindowResize && elementVisible()) {
						if (elementOuterWidth != (elementOuterWidth = element.outerWidth())) {
							ignoreWindowResize++; // in case the windowResize callback changes the height
							updateSize();
							currentView.trigger('windowResize', _element);
							ignoreWindowResize--;
						}
					}
				}, 200);
			}else{
				// calendar must have been initialized in a 0x0 iframe that has just been resized
				lateRender();
			}
		}
	}
	
        $(element).closest('.ui-page').on('hxLayoutDone', function() {
            updateSize();
            (currentView.afterRender || noop)();
        });
	
	
	/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/
	// TODO: going forward, most of this stuff should be directly handled by the view


	function refetchEvents() { // can be called as an API method
		clearEvents();
		fetchAndRenderEvents();
	}


	function rerenderEvents(modifiedEventID) { // can be called as an API method
		clearEvents();
		renderEvents(modifiedEventID);
	}


	function renderEvents(modifiedEventID) { // TODO: remove modifiedEventID hack
		// SAH: render events even when the calendar is not visible. This allows
                // operations like creating a new calendar event to complete in the background,
                // at which point a re-render is triggered before showing the user the calendar
                // again. This is a much smoother experience.
                //if (elementVisible()) {
			currentView.setEventData(events); // for View.js, TODO: unify with renderEvents
			currentView.renderEvents(events, modifiedEventID); // actually render the DOM elements
			currentView.trigger('eventAfterAllRender');
		//}
	}


	function clearEvents() {
		currentView.triggerEventDestroy(); // trigger 'eventDestroy' for each event
		currentView.clearEvents(); // actually remove the DOM elements
		currentView.clearEventData(); // for View.js, TODO: unify with clearEvents
	}
	

	function getAndRenderEvents() {
		if (!options.lazyFetching || isFetchNeeded(currentView.visStart, currentView.visEnd)) {
			fetchAndRenderEvents();
		}
		else {
			renderEvents();
		}
	}


	function fetchAndRenderEvents() {
		fetchEvents(currentView.visStart, currentView.visEnd);
			// ... will call reportEvents
			// ... which will call renderEvents
	}

	
	// called when event data arrives
	function reportEvents(_events) {
		events = _events;
		renderEvents();
	}


	// called when a single event's data has been changed
	function reportEventChange(eventID) {
		rerenderEvents(eventID);
	}



	/* Header Updating
	-----------------------------------------------------------------------------*/


	function updateTitle() {
		header.updateTitle(currentView.title);
	}


	function updateTodayButton() {
		var today = new Date();
		if (today >= currentView.start && today < currentView.end) {
			header.disableButton('today');
		}
		else {
			header.enableButton('today');
		}
	}
	


	/* Selection
	-----------------------------------------------------------------------------*/
	

	function select(start, end, allDay) {
		currentView.select(start, end, allDay===undefined ? true : allDay);
	}
	

	function unselect() { // safe to be called before renderView
		if (currentView) {
			currentView.unselect();
		}
	}
	
	
	
	/* Date
	-----------------------------------------------------------------------------*/
	
	
	function prev() {
		renderView(-1);
	}
	
	
	function next() {
		renderView(1);
	}
	
	
	function prevYear() {
		addYears(date, -1);
		renderView();
	}
	
	
	function nextYear() {
		addYears(date, 1);
		renderView();
	}
	
	
	function today() {
		date = new Date();
		renderView();
	}
	
	
	function gotoDate(year, month, dateOfMonth) {
		if (year instanceof Date) {
			date = cloneDate(year); // provided 1 argument, a Date
		}else{
			setYMD(date, year, month, dateOfMonth);
		}
		renderView();
	}
        
        function gotoHour(firstHour) {
                this.options['firstHour'] = firstHour;
                if (currentView.resetScroll) {
                    currentView.resetScroll();
                }
        }
	
	function incrementDate(years, months, days) {
		if (years !== undefined) {
			addYears(date, years);
		}
		if (months !== undefined) {
			addMonths(date, months);
		}
		if (days !== undefined) {
			addDays(date, days);
		}
		renderView();
	}
	
	
	function getDate() {
		return cloneDate(date);
	}



	/* Height "Freezing"
	-----------------------------------------------------------------------------*/


	function freezeContentHeight() {
		content.css({
			width: '100%',
			height: content.height(),
			overflow: 'hidden'
		});
	}


	function unfreezeContentHeight() {
		content.css({
			width: '',
			height: '',
			overflow: ''
		});
	}
	
	
	
	/* Misc
	-----------------------------------------------------------------------------*/
	
	
	function getView() {
		return currentView;
	}
	
	
	function option(name, value) {
		if (value === undefined) {
			return options[name];
		}
		if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
			options[name] = value;
			updateSize();
		}
	}
	
	
	function trigger(name, thisObj) {
		if (options[name]) {
			return options[name].apply(
				thisObj || _element,
				Array.prototype.slice.call(arguments, 2)
			);
		}
	}
	
        function getContentOffset() {
            return content.position().top;
        }
	
	
	/* External Dragging
	------------------------------------------------------------------------*/
	
	if (options.droppable) {
		$(document)
			.bind('dragstart', function(ev, ui) {
				var _e = ev.target;
				var e = $(_e);
				if (!e.parents('.fc').length) { // not already inside a calendar
					var accept = options.dropAccept;
					if ($.isFunction(accept) ? accept.call(_e, e) : e.is(accept)) {
						_dragElement = _e;
						currentView.dragStart(_dragElement, ev, ui);
					}
				}
			})
			.bind('dragstop', function(ev, ui) {
				if (_dragElement) {
					currentView.dragStop(_dragElement, ev, ui);
					_dragElement = null;
				}
			});
	}
	

}

;;

function Header(calendar, options) {
	var t = this;
	
	
	// exports
	t.render = render;
	t.destroy = destroy;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	
	
	// locals
	var element = $([]);
	var tm;
	


	function render() {
		tm = options.theme ? 'ui' : 'fc';
		var sections = options.header;
		if (sections) {
			element = $("<table class='fc-header' style='width:100%'/>")
				.append(
					$("<tr/>")
						.append(renderSection('left'))
						.append(renderSection('center'))
						.append(renderSection('right'))
				);
			return element;
		}
	}
	
	
	function destroy() {
		element.remove();
	}
	
	
	function renderSection(position) {
		var e = $("<td class='fc-header-" + position + "'/>");
		var buttonStr = options.header[position];
		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				if (i > 0) {
					e.append("<span class='fc-header-space'/>");
				}
				var prevButton;
				$.each(this.split(','), function(j, buttonName) {
					if (buttonName == 'title') {
						e.append("<span class='fc-header-title'><h3>&nbsp;</h3></span>");
						if (prevButton) {
							prevButton.addClass(tm + '-corner-right');
						}
						prevButton = null;
					}else{
						var buttonClick;
						if (calendar[buttonName]) {
							buttonClick = calendar[buttonName]; // calendar method
						}
						else if (fcViews[buttonName]) {
							buttonClick = function() {
								button.removeClass(tm + '-state-hover'); // forget why
								calendar.changeView(buttonName);
							};
						}
						if (buttonClick) {
							var icon = options.theme ? smartProperty(options.buttonIcons, buttonName) : null; // why are we using smartProperty here?
							var text = smartProperty(options.buttonText, buttonName); // why are we using smartProperty here?
							var button = $(
								"<span class='fc-button fc-button-" + buttonName + " " + tm + "-state-default'>" +
									(icon ?
										"<span class='fc-icon-wrap'>" +
											"<span class='ui-icon ui-icon-" + icon + "'/>" +
										"</span>" :
										text
										) +
								"</span>"
								)
								.click(function() {
									if (!button.hasClass(tm + '-state-disabled')) {
										buttonClick();
									}
								})
								.mousedown(function() {
									button
										.not('.' + tm + '-state-active')
										.not('.' + tm + '-state-disabled')
										.addClass(tm + '-state-down');
								})
								.mouseup(function() {
									button.removeClass(tm + '-state-down');
								})
								.hover(
									function() {
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-hover');
									},
									function() {
										button
											.removeClass(tm + '-state-hover')
											.removeClass(tm + '-state-down');
									}
								)
								.appendTo(e);
							disableTextSelection(button);
							if (!prevButton) {
								button.addClass(tm + '-corner-left');
							}
							prevButton = button;
						}
					}
				});
				if (prevButton) {
					prevButton.addClass(tm + '-corner-right');
				}
			});
		}
		return e;
	}
	
	
	function updateTitle(html) {
		element.find('h3')
			.html(html);
	}
	
	
	function activateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-active');
	}
	
	
	function deactivateButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-active');
	}
	
	
	function disableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.addClass(tm + '-state-disabled');
	}
	
	
	function enableButton(buttonName) {
		element.find('span.fc-button-' + buttonName)
			.removeClass(tm + '-state-disabled');
	}


}

;;

fc.sourceNormalizers = [];
fc.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager(options, _sources) {
	var t = this;
	
	
	// exports
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.updateEvent = updateEvent;
	t.renderEvent = renderEvent;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.normalizeEvent = normalizeEvent;
	
	
	// imports
	var trigger = t.trigger;
	var getView = t.getView;
	var reportEvents = t.reportEvents;
	
	
	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var currentFetchID = 0;
	var pendingSourceCnt = 0;
	var loadingLevel = 0;
	var cache = [];
	
	
	for (var i=0; i<_sources.length; i++) {
		_addEventSource(_sources[i]);
	}
	
	
	
	/* Fetching
	-----------------------------------------------------------------------------*/
	
	
	function isFetchNeeded(start, end) {
		return !rangeStart || start < rangeStart || end > rangeEnd;
	}
	
	
	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		cache = [];
		var fetchID = ++currentFetchID;
		var len = sources.length;
		pendingSourceCnt = len;
		for (var i=0; i<len; i++) {
			fetchEventSource(sources[i], fetchID);
		}
	}
	
	
	function fetchEventSource(source, fetchID) {
		_fetchEventSource(source, function(events) {
			if (fetchID == currentFetchID) {
				if (events) {

					if (options.eventDataTransform) {
						events = $.map(events, options.eventDataTransform);
					}
					if (source.eventDataTransform) {
						events = $.map(events, source.eventDataTransform);
					}
					// TODO: this technique is not ideal for static array event sources.
					//  For arrays, we'll want to process all events right in the beginning, then never again.
				
					for (var i=0; i<events.length; i++) {
						events[i].source = source;
						normalizeEvent(events[i]);
					}
					cache = cache.concat(events);
				}
				pendingSourceCnt--;
				if (!pendingSourceCnt) {
					reportEvents(cache);
				}
			}
		});
	}
	
	
	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = fc.sourceFetchers;
		var res;
		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i](source, rangeStart, rangeEnd, callback);
			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}
		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				pushLoading();
				events(cloneDate(rangeStart), cloneDate(rangeEnd), function(events) {
					callback(events);
					popLoading();
				});
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;

				// retrieve any outbound GET/POST $.ajax data from the options
				var customData;
				if ($.isFunction(source.data)) {
					// supplied as a function that returns a key/value object
					customData = source.data();
				}
				else {
					// supplied as a straight key/value object
					customData = source.data;
				}

				// use a copy of the custom data so we can modify the parameters
				// and not affect the passed-in object.
				var data = $.extend({}, customData || {});

				var startParam = firstDefined(source.startParam, options.startParam);
				var endParam = firstDefined(source.endParam, options.endParam);
				if (startParam) {
					data[startParam] = Math.round(+rangeStart / 1000);
				}
				if (endParam) {
					data[endParam] = Math.round(+rangeEnd / 1000);
				}

				pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}
	
	
	
	/* Sources
	-----------------------------------------------------------------------------*/
	

	function addEventSource(source) {
		source = _addEventSource(source);
		if (source) {
			pendingSourceCnt++;
			fetchEventSource(source, currentFetchID); // will eventually call reportEvents
		}
	}
	
	
	function _addEventSource(source) {
		if ($.isFunction(source) || $.isArray(source)) {
			source = { events: source };
		}
		else if (typeof source == 'string') {
			source = { url: source };
		}
		if (typeof source == 'object') {
			normalizeSource(source);
			sources.push(source);
			return source;
		}
	}
	

	function removeEventSource(source) {
		sources = $.grep(sources, function(src) {
			return !isSourcesEqual(src, source);
		});
		// remove all client events from that source
		cache = $.grep(cache, function(e) {
			return !isSourcesEqual(e.source, source);
		});
		reportEvents(cache);
	}
	
	
	
	/* Manipulation
	-----------------------------------------------------------------------------*/
	
	
	function updateEvent(event) { // update an existing event
		var i, len = cache.length, e,
			defaultEventEnd = getView().defaultEventEnd, // getView???
			startDelta = event.start - event._start,
			endDelta = event.end ?
				(event.end - (event._end || defaultEventEnd(event))) // event._end would be null if event.end
				: 0;                                                      // was null and event was just resized
		for (i=0; i<len; i++) {
			e = cache[i];
			if (e._id == event._id && e != event) {
				e.start = new Date(+e.start + startDelta);
				if (event.end) {
					if (e.end) {
						e.end = new Date(+e.end + endDelta);
					}else{
						e.end = new Date(+defaultEventEnd(e) + endDelta);
					}
				}else{
					e.end = null;
				}
				e.title = event.title;
				e.url = event.url;
				e.allDay = event.allDay;
				e.className = event.className;
				e.editable = event.editable;
				e.color = event.color;
				e.backgroundColor = event.backgroundColor;
				e.borderColor = event.borderColor;
				e.textColor = event.textColor;
				normalizeEvent(e);
			}
		}
		normalizeEvent(event);
		reportEvents(cache);
	}
	
	
	function renderEvent(event, stick) {
		normalizeEvent(event);
		if (!event.source) {
			if (stick) {
				stickySource.events.push(event);
				event.source = stickySource;
			}
			cache.push(event);
		}
		reportEvents(cache);
	}
	
	
	function removeEvents(filter) {
		if (!filter) { // remove all
			cache = [];
			// clear all array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = [];
				}
			}
		}else{
			if (!$.isFunction(filter)) { // an event ID
				var id = filter + '';
				filter = function(e) {
					return e._id == id;
				};
			}
			cache = $.grep(cache, filter, true);
			// remove events from array sources
			for (var i=0; i<sources.length; i++) {
				if ($.isArray(sources[i].events)) {
					sources[i].events = $.grep(sources[i].events, filter, true);
				}
			}
		}
		reportEvents(cache);
	}
	
	
	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter) { // an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}
	
	
	
	/* Loading State
	-----------------------------------------------------------------------------*/
	
	
	function pushLoading() {
		if (!loadingLevel++) {
			trigger('loading', null, true, getView());
		}
	}
	
	
	function popLoading() {
		if (!--loadingLevel) {
			trigger('loading', null, false, getView());
		}
	}
	
	
	
	/* Event Normalization
	-----------------------------------------------------------------------------*/
	
	
	function normalizeEvent(event) {
		var source = event.source || {};
		var ignoreTimezone = firstDefined(source.ignoreTimezone, options.ignoreTimezone);
                var tzOffset = firstDefined(event.tzOffset, options.tzOffset);
                var dstOffset = firstDefined(event.dstOffset, options.dstOffset);
                event.tzOffset = tzOffset;
		event._id = event._id || (event.id === undefined ? '_fc' + eventGUID++ : event.id + '');
		if (event.date) {
			if (!event.start) {
				event.start = event.date;
			}
			delete event.date;
		}
		event._start = cloneDate(event.start = parseDate(event.start, ignoreTimezone, tzOffset, dstOffset));
		event.end = parseDate(event.end, ignoreTimezone, tzOffset, dstOffset);
		if (event.end && event.end <= event.start) {
			event.end = null;
		}
		event._end = event.end ? cloneDate(event.end) : null;
		if (event.allDay === undefined) {
			event.allDay = firstDefined(source.allDayDefault, options.allDayDefault);
		}
		if (event.className) {
			if (typeof event.className == 'string') {
				event.className = event.className.split(/\s+/);
			}
		}else{
			event.className = [];
		}
		// TODO: if there is no start date, return false to indicate an invalid event
	}
	
	
	
	/* Utils
	------------------------------------------------------------------------------*/
	
	
	function normalizeSource(source) {
		if (source.className) {
			// TODO: repeat code, same code for event classNames
			if (typeof source.className == 'string') {
				source.className = source.className.split(/\s+/);
			}
		}else{
			source.className = [];
		}
		var normalizers = fc.sourceNormalizers;
		for (var i=0; i<normalizers.length; i++) {
			normalizers[i](source);
		}
	}
	
	
	function isSourcesEqual(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}
	
	
	function getSourcePrimitive(source) {
		return ((typeof source == 'object') ? (source.events || source.url) : '') || source;
	}


}

;;


fc.addDays = addDays;
fc.cloneDate = cloneDate;
fc.parseDate = parseDate;
fc.parseISO8601 = parseISO8601;
fc.parseTime = parseTime;
fc.formatDate = formatDate;
fc.formatDates = formatDates;



/* Date Math
-----------------------------------------------------------------------------*/

var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'],
	DAY_MS = 86400000,
	HOUR_MS = 3600000,
	MINUTE_MS = 60000;
	

function addYears(d, n, keepTime) {
	d.setFullYear(d.getFullYear() + n);
	if (!keepTime) {
		clearTime(d);
	}
	return d;
}


function addMonths(d, n, keepTime) { // prevents day overflow/underflow
	if (+d) { // prevent infinite looping on invalid dates
		var m = d.getMonth() + n,
			check = cloneDate(d);
		check.setDate(1);
		check.setMonth(m);
		d.setMonth(m);
		if (!keepTime) {
			clearTime(d);
		}
		while (d.getMonth() != check.getMonth()) {
			d.setDate(d.getDate() + (d < check ? 1 : -1));
		}
	}
	return d;
}


function addDays(d, n, keepTime) { // deals with daylight savings
	if (+d) {
            /* SAH - changed to UTC */
            if (!keepTime) {
                // Set the time to mid-day to avoid DST issues
                d.setUTCHours(12);
            }
            
		var dd = d.getUTCDate() + n,
			check = cloneDate(d);
		//check.setHours(9); // set to middle of day
		//check.setDate(dd);
                d.setUTCDate(dd);
		//if (!keepTime) {
			//clearTime(d);
		//}
		//fixDate(d, check);
	}
	return d;
}


function fixDate(d, check) { // force d to be on check's YMD, for daylight savings purposes
	if (+d) { // prevent infinite looping on invalid dates
		while (d.getDate() != check.getDate()) {
			d.setTime(+d + (d < check ? 1 : -1) * HOUR_MS);
		}
	}
}


function addMinutes(d, n) {
	d.setMinutes(d.getMinutes() + n);
	return d;
}


function clearTime(d) {
	/*d.setHours(0);
	d.setMinutes(0);
	d.setSeconds(0); 
	d.setMilliseconds(0);*/
        d.setUTCHours(0);
        d.setUTCMinutes(0);
        d.setUTCSeconds(0);
        d.setUTCMilliseconds(0);
	return d;
}


function cloneDate(d, dontKeepTime) {
	if (dontKeepTime) {
		return clearTime(new Date(+d));
	}
	return new Date(+d);
}


function zeroDate() { // returns a Date with time 00:00:00 and dateOfMonth=1
	/*var i=0, d;
	do {
		d = new Date(1970, i++, 1);
	} while (d.getHours()); // != 0
	return d;*/
    return new Date(0);
}


function dayDiff(d1, d2) { // d1 - d2
    var cd1 = cloneDate(d1, true);
    var cd2 = cloneDate(d2, true);
    var diff = cd1 - cd2;
    var ndays = Math.round(diff / DAY_MS);
    if (ndays == 38) {
        //alert("HELLO");
    }
    return ndays;
}


function setYMD(date, y, m, d) {
	if (y !== undefined /*&& y != date.getFullYear()*/) {
		date.setUTCDate(1);
		date.setUTCMonth(0);
		date.setUTCFullYear(y);
	}
	if (m !== undefined /*&& m != date.getMonth()*/) {
		date.setUTCDate(1);
		date.setUTCMonth(m);
	}
	if (d !== undefined) {
		date.setUTCDate(d);
	}
}



/* Date Parsing
-----------------------------------------------------------------------------*/

/* SAH - convert to a time zone based on the parameter option tzOffset. tzOffset
 * is the number of hours to offset the date to adjust for the user's selected
 * local timezone. If tzOffset is not set, just return the date, which defaults
 * to the user's local timezone. 
 */
function convertTimezone(s, tzOffset, dstOffset) {
    if (!tzOffset || !dstOffset) {
        alert("MISSING timezone settings.");
        return s;
    }
    
    var minutesOffset = 0;
    if (s.dst()) {
        minutesOffset = (dstOffset) * 60;
    } else {
        minutesOffset = (tzOffset) * 60;
    }
    
    s.addMinutes(minutesOffset);
    return s;
}

function parseDate(s, ignoreTimezone, tzOffset, dstOffset) { // ignoreTimezone defaults to true
	if (typeof s == 'object') { // already a Date object
		return convertTimezone(s, tzOffset, dstOffset);
	}
	if (typeof s == 'number') { // a UNIX timestamp
		return convertTimezone(new Date(s * 1000), tzOffset, dstOffset);
	}
	if (typeof s == 'string') {
		if (s.match(/^\d+(\.\d+)?$/)) { // a UNIX timestamp
			return convertTimezone(new Date(parseFloat(s) * 1000), tzOffset, dstOffset);
		}
		if (ignoreTimezone === undefined) {
			ignoreTimezone = true;
		}
		return parseISO8601(s, ignoreTimezone, tzOffset, dstOffset) || (s ? convertTimezone(new Date(s), tzOffset, dstOffset) : null);
	}
	// TODO: never return invalid dates (like from new Date(<string>)), return null instead
	return null;
}


function parseISO8601(s, ignoreTimezone, tzOffset, dstOffset) { // ignoreTimezone defaults to false
	// derived from http://delete.me.uk/2005/03/iso8601.html
	// TODO: for a know glitch/feature, read tests/issue_206_parseDate_dst.html
	var m = s.match(/^([0-9]{4})(-([0-9]{2})(-([0-9]{2})([T ]([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2})(:?([0-9]{2}))?))?)?)?)?$/);
	if (!m) {
		return null;
	}
	var date = new Date(m[1], 0, 1);
	if (ignoreTimezone || !m[13]) {
		var check = new Date(m[1], 0, 1, 9, 0);
		if (m[3]) {
			date.setMonth(m[3] - 1);
			check.setMonth(m[3] - 1);
		}
		if (m[5]) {
			date.setDate(m[5]);
			check.setDate(m[5]);
		}
		fixDate(date, check);
		if (m[7]) {
			date.setHours(m[7]);
		}
		if (m[8]) {
			date.setMinutes(m[8]);
		}
		if (m[10]) {
			date.setSeconds(m[10]);
		}
		if (m[12]) {
			date.setMilliseconds(Number("0." + m[12]) * 1000);
		}
		fixDate(date, check);
	}else{
		date.setUTCFullYear(
			m[1],
			m[3] ? m[3] - 1 : 0,
			m[5] || 1
		);
		date.setUTCHours(
			m[7] || 0,
			m[8] || 0,
			m[10] || 0,
			m[12] ? Number("0." + m[12]) * 1000 : 0
		);
		if (m[14]) {
			var offset = Number(m[16]) * 60 + (m[18] ? Number(m[18]) : 0);
			offset *= m[15] == '-' ? 1 : -1;
			date = new Date(+date + (offset * 60 * 1000));
		}
	}
	return convertTimezone(date, tzOffset, dstOffset);
}


function parseTime(s) { // returns minutes since start of day
	if (typeof s == 'number') { // an hour
		return s * 60;
	}
	if (typeof s == 'object') { // a Date object
		return s.getHours() * 60 + s.getMinutes();
	}
	var m = s.match(/(\d+)(?::(\d+))?\s*(\w+)?/);
	if (m) {
		var h = parseInt(m[1], 10);
		if (m[3]) {
			h %= 12;
			if (m[3].toLowerCase().charAt(0) == 'p') {
				h += 12;
			}
		}
		return h * 60 + (m[2] ? parseInt(m[2], 10) : 0);
	}
}



/* Date Formatting
-----------------------------------------------------------------------------*/
// TODO: use same function formatDate(date, [date2], format, [options])


function formatDate(date, format, options) {
	return formatDates(date, null, format, options);
}


function formatDates(date1, date2, format, options) {
	options = options || defaults;
	var date = date1,
		otherDate = date2,
		i, len = format.length, c,
		i2, formatter,
		res = '';
	for (i=0; i<len; i++) {
		c = format.charAt(i);
		if (c == "'") {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == "'") {
					if (date) {
						if (i2 == i+1) {
							res += "'";
						}else{
							res += format.substring(i+1, i2);
						}
						i = i2;
					}
					break;
				}
			}
		}
		else if (c == '(') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ')') {
					var subres = formatDate(date, format.substring(i+1, i2), options);
					if (parseInt(subres.replace(/\D/, ''), 10)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '[') {
			for (i2=i+1; i2<len; i2++) {
				if (format.charAt(i2) == ']') {
					var subformat = format.substring(i+1, i2);
					var subres = formatDate(date, subformat, options);
					if (subres != formatDate(otherDate, subformat, options)) {
						res += subres;
					}
					i = i2;
					break;
				}
			}
		}
		else if (c == '{') {
			date = date2;
			otherDate = date1;
		}
		else if (c == '}') {
			date = date1;
			otherDate = date2;
		}
		else {
			for (i2=len; i2>i; i2--) {
				if (formatter = dateFormatters[format.substring(i, i2)]) {
					if (date) {
						res += formatter(date, options);
					}
					i = i2 - 1;
					break;
				}
			}
			if (i2 == i) {
				if (date) {
					res += c;
				}
			}
		}
	}
	return res;
};


var dateFormatters = {
	/*s	: function(d)	{ return d.getSeconds() },
	ss	: function(d)	{ return zeroPad(d.getSeconds()) },
	m	: function(d)	{ return d.getMinutes() },
	mm	: function(d)	{ return zeroPad(d.getMinutes()) },
	h	: function(d)	{ return d.getHours() % 12 || 12 },
	hh	: function(d)	{ return zeroPad(d.getHours() % 12 || 12) },
	H	: function(d)	{ return d.getHours() },
	HH	: function(d)	{ return zeroPad(d.getHours()) },
	d	: function(d)	{ return d.getDate() },
	dd	: function(d)	{ return zeroPad(d.getDate()) },
	ddd	: function(d,o)	{ return o.dayNamesShort[d.getDay()] },
	dddd: function(d,o)	{ return o.dayNames[d.getDay()] },
	M	: function(d)	{ return d.getMonth() + 1 },
	MM	: function(d)	{ return zeroPad(d.getMonth() + 1) },
	MMM	: function(d,o)	{ return o.monthNamesShort[d.getMonth()] },
	MMMM: function(d,o)	{ return o.monthNames[d.getMonth()] },
	yy	: function(d)	{ return (d.getFullYear()+'').substring(2) },
	yyyy: function(d)	{ return d.getFullYear() },
	t	: function(d)	{ return d.getHours() < 12 ? 'a' : 'p' },
	tt	: function(d)	{ return d.getHours() < 12 ? 'am' : 'pm' },
	T	: function(d)	{ return d.getHours() < 12 ? 'A' : 'P' },
	TT	: function(d)	{ return d.getHours() < 12 ? 'AM' : 'PM' }, */
        s	: function(d)	{ return d.getUTCSeconds() },
	ss	: function(d)	{ return zeroPad(d.getUTCSeconds()) },
	m	: function(d)	{ return d.getUTCMinutes() },
	mm	: function(d)	{ return zeroPad(d.getUTCMinutes()) },
	h	: function(d)	{ return d.getUTCHours() % 12 || 12 },
	hh	: function(d)	{ return zeroPad(d.getUTCHours() % 12 || 12) },
	H	: function(d)	{ return d.getUTCHours() },
	HH	: function(d)	{ return zeroPad(d.getUTCHours()) },
	d	: function(d)	{ return d.getUTCDate() },
	dd	: function(d)	{ return zeroPad(d.getUTCDate()) },
	ddd	: function(d,o)	{ return o.dayNamesShort[d.getUTCDay()] },
	dddd: function(d,o)	{ return o.dayNames[d.getUTCDay()] },
	M	: function(d)	{ return d.getUTCMonth() + 1 },
	MM	: function(d)	{ return zeroPad(d.getUTCMonth() + 1) },
	MMM	: function(d,o)	{ return o.monthNamesShort[d.getUTCMonth()] },
	MMMM: function(d,o)	{ return o.monthNames[d.getUTCMonth()] },
	yy	: function(d)	{ return (d.getUTCFullYear()+'').substring(2) },
	yyyy: function(d)	{ return d.getUTCFullYear() },
	t	: function(d)	{ return d.getUTCHours() < 12 ? 'a' : 'p' },
	tt	: function(d)	{ return '<span class="fc-ampm">' + (d.getUTCHours() < 12 ? 'am' : 'pm') + '</span>' },
	T	: function(d)	{ return d.getUTCHours() < 12 ? 'A' : 'P' },
	TT	: function(d)	{ return d.getUTCHours() < 12 ? 'AM' : 'PM' },
	u	: function(d)	{ return formatDate(d, "yyyy-MM-dd'T'HH:mm:ss'Z'") },
	S	: function(d)	{
		var date = d.getDate();
		if (date > 10 && date < 20) {
			return 'th';
		}
		return ['st', 'nd', 'rd'][date%10-1] || 'th';
	},
	w   : function(d, o) { // local
		return o.weekNumberCalculation(d);
	},
	W   : function(d) { // ISO
		return iso8601Week(d);
	}
};
fc.dateFormatters = dateFormatters;


/* thanks jQuery UI (https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js)
 * 
 * Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
 * `date` - the date to get the week for
 * `number` - the number of the week within the year that contains this date
 */
function iso8601Week(date) {
	var time;
	var checkDate = new Date(date.getTime());

	// Find Thursday of this week starting on Monday
	checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

	time = checkDate.getTime();
	checkDate.setMonth(0); // Compare with Jan 1
	checkDate.setDate(1);
	return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
}


;;

fc.applyAll = applyAll;


/* Event Date Math
-----------------------------------------------------------------------------*/


function exclEndDay(event) {
	if (event.end) {
		return _exclEndDay(event.end, event.allDay);
	}else{
		return addDays(cloneDate(event.start), 1);
	}
}


function _exclEndDay(end, allDay) {
	end = cloneDate(end);
	return allDay || end.getHours() || end.getMinutes() ? addDays(end, 1) : clearTime(end);
	// why don't we check for seconds/ms too?
}



/* Event Element Binding
-----------------------------------------------------------------------------*/


function lazySegBind(container, segs, bindHandlers) {
    // Lazy binding does not work on touch devices now that we have a context event
    // (taphold).
    for (var i = 0; i < segs.length; ++i) {
        var seg = segs[i];
        bindHandlers(seg.event, seg.element, seg);
    }
    /*
	container.unbind('mouseover').mouseover(function(ev) {
		var parent=ev.target, e,
			i, seg;
		while (parent != this) {
			e = parent;
			parent = parent.parentNode;
		}
		if ((i = e._fci) !== undefined) {
			e._fci = undefined;
			seg = segs[i];
			bindHandlers(seg.event, seg.element, seg);
			$(ev.target).trigger(ev);
		}
		ev.stopPropagation();
	});*/
}



/* Element Dimensions
-----------------------------------------------------------------------------*/


function setOuterWidth(element, width, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.width(Math.max(0, width - hsides(e, includeMargins)));
	}
}


function setOuterHeight(element, height, includeMargins) {
	for (var i=0, e; i<element.length; i++) {
		e = $(element[i]);
		e.height(Math.max(0, height - vsides(e, includeMargins)));
	}
}


function hsides(element, includeMargins) {
	return hpadding(element) + hborders(element) + (includeMargins ? hmargins(element) : 0);
}


function hpadding(element) {
	return (parseFloat($.css(element[0], 'paddingLeft', true)) || 0) +
	       (parseFloat($.css(element[0], 'paddingRight', true)) || 0);
}


function hmargins(element) {
	return (parseFloat($.css(element[0], 'marginLeft', true)) || 0) +
	       (parseFloat($.css(element[0], 'marginRight', true)) || 0);
}


function hborders(element) {
	return (parseFloat($.css(element[0], 'borderLeftWidth', true)) || 0) +
	       (parseFloat($.css(element[0], 'borderRightWidth', true)) || 0);
}


function vsides(element, includeMargins) {
	return vpadding(element) +  vborders(element) + (includeMargins ? vmargins(element) : 0);
}


function vpadding(element) {
	return (parseFloat($.css(element[0], 'paddingTop', true)) || 0) +
	       (parseFloat($.css(element[0], 'paddingBottom', true)) || 0);
}


function vmargins(element) {
	return (parseFloat($.css(element[0], 'marginTop', true)) || 0) +
	       (parseFloat($.css(element[0], 'marginBottom', true)) || 0);
}


function vborders(element) {
	return (parseFloat($.css(element[0], 'borderTopWidth', true)) || 0) +
	       (parseFloat($.css(element[0], 'borderBottomWidth', true)) || 0);
}



/* Misc Utils
-----------------------------------------------------------------------------*/


//TODO: arraySlice
//TODO: isFunction, grep ?


function noop() { }


function dateCompare(a, b) {
	return a - b;
}


function arrayMax(a) {
	return Math.max.apply(Math, a);
}


function zeroPad(n) {
    if (n == 0) {
        // For compactness sake, do not show 3:00. Just show 3.
        return '';
    }
	return (n < 10 ? '0' : '') + n;
}


function smartProperty(obj, name) { // get a camel-cased/namespaced property of an object
	if (obj[name] !== undefined) {
		return obj[name];
	}
	var parts = name.split(/(?=[A-Z])/),
		i=parts.length-1, res;
	for (; i>=0; i--) {
		res = obj[parts[i].toLowerCase()];
		if (res !== undefined) {
			return res;
		}
	}
	return obj[''];
}


function htmlEscape(s) {
	return s.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}


function disableTextSelection(element) {
	element
		.attr('unselectable', 'on')
		.css('MozUserSelect', 'none')
		.bind('selectstart.ui', function() { return false; });
}


/*
function enableTextSelection(element) {
	element
		.attr('unselectable', 'off')
		.css('MozUserSelect', '')
		.unbind('selectstart.ui');
}
*/


function markFirstLast(e) {
	e.children()
		.removeClass('fc-first fc-last')
		.filter(':first-child')
			.addClass('fc-first')
		.end()
		.filter(':last-child')
			.addClass('fc-last');
}


function setDayID(cell, date) {
	cell.each(function(i, _cell) {
		_cell.className = _cell.className.replace(/^fc-\w*/, 'fc-' + dayIDs[date.getDay()]);
		// TODO: make a way that doesn't rely on order of classes
	});
}


function getSkinCss(event, opt) {
	var source = event.source || {};
	var eventColor = event.color;
	var sourceColor = source.color;
	var optionColor = opt('eventColor');
	var backgroundColor =
		event.backgroundColor ||
		eventColor ||
		source.backgroundColor ||
		sourceColor ||
		opt('eventBackgroundColor') ||
		optionColor;
	var borderColor =
		event.borderColor ||
		eventColor ||
		source.borderColor ||
		sourceColor ||
		opt('eventBorderColor') ||
		optionColor;
	var textColor =
		event.textColor ||
		source.textColor ||
		opt('eventTextColor');
        var isHatched =
                event.isHatched;
	var statements = [];
	if (backgroundColor) {
		statements.push('background-color:' + backgroundColor);
	}
	if (borderColor) {
		statements.push('border-color:' + borderColor);
	}
	if (textColor) {
		statements.push('color:' + textColor);
	}
        if (isHatched) {
            // From http://www.patternify.com/
            statements.push('background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAJElEQVQIW2NkYGD4D8SMQAwHMA6KBLIKuASKNphR6IIgc/8DAACiBQXgDbYOAAAAAElFTkSuQmCC) repeat');
            if (!backgroundColor) {
                statements.push('background-color: white');
            }
            // Otherwise it is hard to read the text on the hatched background.
            statements.push('font-weight: bold');
        }
	return statements.join(';');
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}


;;

fcViews.month = MonthView;

function MonthView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'month');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var skipHiddenDays = t.skipHiddenDays;
	var getCellsPerWeek = t.getCellsPerWeek;
	var formatDate = calendar.formatDate;
	
	
	function render(date, delta) {

		if (delta) {
			addMonths(date, delta);
			date.setDate(1);
		}

		var firstDay = opt('firstDay');

		var start = cloneDate(date, true);
		start.setUTCDate(1); /* SAH - make UTC. */

		var end = addMonths(cloneDate(start), 1);

		var visStart = cloneDate(start);
		addDays(visStart, -((visStart.getUTCDay() - firstDay + 7) % 7)); /* SAH - move to UTC. */
		skipHiddenDays(visStart);

		var visEnd = cloneDate(end);
		addDays(visEnd, (7 - visEnd.getUTCDay() + firstDay) % 7); /* SAH - move to UTC. */
		skipHiddenDays(visEnd, -1, true);

		var colCnt = getCellsPerWeek();
		var rowCnt = Math.round(dayDiff(visEnd, visStart) / 7); // should be no need for Math.round

		if (opt('weekMode') == 'fixed') {
			addDays(visEnd, (6 - rowCnt) * 7); // add weeks to make up for it
			rowCnt = 6;
		}

		t.title = formatDate(start, opt('titleFormat'));

		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;

		renderBasic(rowCnt, colCnt, true);
	}
	
	
}

;;

fcViews.basicWeek = BasicWeekView;

function BasicWeekView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'basicWeek');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var skipHiddenDays = t.skipHiddenDays;
	var getCellsPerWeek = t.getCellsPerWeek;
	var formatDates = calendar.formatDates;
	
	
	function render(date, delta) {

		if (delta) {
			addDays(date, delta * 7);
		}

		var start = addDays(cloneDate(date), -((date.getDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);

		var visStart = cloneDate(start);
		skipHiddenDays(visStart);

		var visEnd = cloneDate(end);
		skipHiddenDays(visEnd, -1, true);

		var colCnt = getCellsPerWeek();

		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;

		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);

		renderBasic(1, colCnt, false);
	}
	
	
}

;;

fcViews.basicDay = BasicDayView;


function BasicDayView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	BasicView.call(t, element, calendar, 'basicDay');
	var opt = t.opt;
	var renderBasic = t.renderBasic;
	var skipHiddenDays = t.skipHiddenDays;
	var formatDate = calendar.formatDate;
	
	
	function render(date, delta) {

		if (delta) {
			addDays(date, delta);
		}
		skipHiddenDays(date, delta < 0 ? -1 : 1);

		var start = cloneDate(date, true);
		var end = addDays(cloneDate(start), 1);

		t.title = formatDate(date, opt('titleFormat'));

		t.start = t.visStart = start;
		t.end = t.visEnd = end;

		renderBasic(1, 1, false);
	}
	
	
}

;;

setDefaults({
	weekMode: 'fixed'
});


function BasicView(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.renderBasic = renderBasic;
	t.setHeight = setHeight;
	t.setWidth = setWidth;
	t.renderDayOverlay = renderDayOverlay;
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // for selection (kinda hacky)
	t.dragStart = dragStart;
	t.dragStop = dragStop;
	t.defaultEventEnd = defaultEventEnd;
	t.getHoverListener = function() { return hoverListener };
	t.colLeft = colLeft;
	t.colRight = colRight;
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.getIsCellAllDay = function() { return true };
	t.allDayRow = allDayRow;
	t.getRowCnt = function() { return rowCnt };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getDaySegmentContainer = function() { return daySegmentContainer };
	
	
	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	BasicEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var daySelectionMousedown = t.daySelectionMousedown;
	var cellToDate = t.cellToDate;
	var dateToCell = t.dateToCell;
	var rangeToSegments = t.rangeToSegments;
	var formatDate = calendar.formatDate;
	
	
	// locals
	
	var table;
	var head;
	var headCells;
	var body;
	var bodyRows;
	var bodyCells;
	var bodyFirstCells;
	var firstRowCellInners;
	var firstRowCellContentInners;
	var daySegmentContainer;
	
	var viewWidth;
	var viewHeight;
	var colWidth;
	var weekNumberWidth;
	
	var rowCnt, colCnt;
	var showNumbers;
	var coordinateGrid;
	var hoverListener;
	var colPositions;
	var colContentPositions;
	
	var tm;
	var colFormat;
	var showWeekNumbers;
	var weekNumberTitle;
	var weekNumberFormat;
	
	
	
	/* Rendering
	------------------------------------------------------------*/
	
	
	disableTextSelection(element.addClass('fc-grid'));
	
	
	function renderBasic(_rowCnt, _colCnt, _showNumbers) {
		rowCnt = _rowCnt;
		colCnt = _colCnt;
		showNumbers = _showNumbers;
		updateOptions();

		if (!body) {
			buildEventContainer();
		}

		buildTable();
	}
	
	
	function updateOptions() {
		tm = opt('theme') ? 'ui' : 'fc';
		colFormat = opt('columnFormat');

		// week # options. (TODO: bad, logic also in other views)
		showWeekNumbers = opt('weekNumbers');
		weekNumberTitle = opt('weekNumberTitle');
		if (opt('weekNumberCalculation') != 'iso') {
			weekNumberFormat = "w";
		}
		else {
			weekNumberFormat = "W";
		}
	}
	
	
	function buildEventContainer() {
		daySegmentContainer =
			$("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(element);
	}
	
	
	function buildTable() {
		var html = buildTableHTML();

		if (table) {
			table.remove();
		}
		table = $(html).appendTo(element);

		head = table.find('thead');
		headCells = head.find('.fc-day-header');
		body = table.find('tbody');
		bodyRows = body.find('tr');
		bodyCells = body.find('.fc-day');
		bodyFirstCells = bodyRows.find('td:first-child');

		firstRowCellInners = bodyRows.eq(0).find('.fc-day > div');
		firstRowCellContentInners = bodyRows.eq(0).find('.fc-day-content > div');
		
		markFirstLast(head.add(head.find('tr'))); // marks first+last tr/th's
		markFirstLast(bodyRows); // marks first+last td's
		bodyRows.eq(0).addClass('fc-first');
		bodyRows.filter(':last').addClass('fc-last');

		bodyCells.each(function(i, _cell) {
			var date = cellToDate(
				Math.floor(i / colCnt),
				i % colCnt
			);
			trigger('dayRender', t, date, $(_cell));
		});

		dayBind(bodyCells);
	}



	/* HTML Building
	-----------------------------------------------------------*/


	function buildTableHTML() {
		var html =
			"<table class='fc-border-separate' style='width:100%' cellspacing='0' class='pm-layout-full-height'>" +
			buildHeadHTML() +
			buildBodyHTML() +
			"</table>";

		return html;
	}


	function buildHeadHTML() {
		var headerClass = tm + "-widget-header";
		var html = '';
		var col;
		var date;

		html += "<thead><tr>";

		if (showWeekNumbers) {
			html +=
				"<th class='fc-week-number " + headerClass + "'>" +
				htmlEscape(weekNumberTitle) +
				"</th>";
		}

		for (col=0; col<colCnt; col++) {
			date = cellToDate(0, col);
			html +=
				"<th class='fc-day-header fc-" + dayIDs[date.getDay()] + " " + headerClass + "'>" +
				htmlEscape(formatDate(date, colFormat)) +
				"</th>";
		}

		html += "</tr></thead>";

		return html;
	}


	function buildBodyHTML() {
		var contentClass = tm + "-widget-content";
		var html = '';
		var row;
		var col;
		var date;

		html += "<tbody class='pm-layout-full-height'>";

		for (row=0; row<rowCnt; row++) {

			html += "<tr class='fc-week pm-layout-full-height'>";

			if (showWeekNumbers) {
				date = cellToDate(row, 0);
				html +=
					"<td class='fc-week-number " + contentClass + "'>" +
					"<div>" +
					htmlEscape(formatDate(date, weekNumberFormat)) +
					"</div>" +
					"</td>";
			}

			for (col=0; col<colCnt; col++) {
				date = cellToDate(row, col);
				html += buildCellHTML(date);
			}

			html += "</tr>";
		}

		html += "</tbody>";

		return html;
	}


	function buildCellHTML(date) {
		var contentClass = tm + "-widget-content";
		var month = t.start.getUTCMonth(); /* SAH - to UTC */
		var today = clearTime(new Date());
		var html = '';
		var classNames = [
			'fc-day',
			'fc-' + dayIDs[date.getUTCDay()], /* SAH - to UTC */
			contentClass
		];

		if (date.getUTCMonth() != month) { /* SAH - to UTC */
			classNames.push('fc-other-month');
		}
		if (+date == +today) {
			classNames.push(
				'fc-today',
				tm + '-state-highlight'
			);
		}
		else if (date < today) {
			classNames.push('fc-past');
		}
		else {
			classNames.push('fc-future');
		}
                classNames.push('pm-layout-full-height');

		html +=
			"<td" +
			" class='" + classNames.join(' ') + "'" +
			" data-date='" + formatDate(date, 'yyyy-MM-dd') + "'" +
			">" +
			"<div class='mh-layout-parent-height'>";

		if (showNumbers) {
			html += "<div class='fc-day-number'>" + date.getUTCDate() + "</div>"; /* SAH - to UTC */
		}

		html +=
			"<div class='fc-day-content'>" +
			"<div style='position:relative'>&nbsp;</div>" +
			"</div>" +
			"</div>" +
			"</td>";

		return html;
	}



	/* Dimensions
	-----------------------------------------------------------*/
	
	
	function setHeight(height, viewPortHeight) {
                if (height === undefined || height === null) {
			height = viewPortHeight;
		}
		viewHeight = height;
		
		var bodyHeight = viewHeight - head.height();
		var rowHeight;
		var rowHeightLast;
		var cell;

                if (bodyHeight < 400) {
                    /* SAH - force a minimum height of 400px */
                    bodyHeight = 400;
                }

		if (opt('weekMode') == 'variable') {
			rowHeight = rowHeightLast = Math.floor(bodyHeight / (rowCnt==1 ? 2 : 6));
		}else{
			rowHeight = Math.floor(bodyHeight / rowCnt);
			rowHeightLast = bodyHeight - rowHeight * (rowCnt-1);
		}
		
		bodyFirstCells.each(function(i, _cell) {
			if (i < rowCnt) {
				cell = $(_cell);
				cell.find('> div').css(
					'min-height',
					(i==rowCnt-1 ? rowHeightLast : rowHeight) - vsides(cell)
				);
			}
		});
		
	}
	
	
	function setWidth(width) {
		viewWidth = width;
		colPositions.clear();
		colContentPositions.clear();

		weekNumberWidth = 0;
		if (showWeekNumbers) {
			weekNumberWidth = head.find('th.fc-week-number').outerWidth();
		}

		colWidth = Math.floor((viewWidth - weekNumberWidth) / colCnt);
		setOuterWidth(headCells.slice(0, -1), colWidth);
	}
	
	
	
	/* Day clicking and binding
	-----------------------------------------------------------*/
	
	
	function dayBind(days) {
		days.click(dayClick)
			.mousedown(daySelectionMousedown);
	}
	
	
	function dayClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
                        var tzOffset = firstDefined(ev.tzOffset, opt('tzOffset'));
                        var dstOffset = firstDefined(ev.dstOffset, opt('dstOffset'));
			var date = parseISO8601($(this).data('date'), true, tzOffset, dstOffset);
			trigger('dayClick', this, date, true, ev);
		}
	}
	
	
	
	/* Semi-transparent Overlay Helpers
	------------------------------------------------------*/
	// TODO: should be consolidated with AgendaView's methods


	function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive

		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}

		var segments = rangeToSegments(overlayStart, overlayEnd);

		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];
			dayBind(
				renderCellOverlay(
					segment.row,
					segment.leftCol,
					segment.row,
					segment.rightCol
				)
			);
		}
	}

	
	function renderCellOverlay(row0, col0, row1, col1) { // row1,col1 is inclusive
		var rect = coordinateGrid.rect(row0, col0, row1, col1, element);
		return renderOverlay(rect, element);
	}
	
	
	
	/* Selection
	-----------------------------------------------------------------------*/
	
	
	function defaultSelectionEnd(startDate, allDay) {
		return cloneDate(startDate);
	}
	
	
	function renderSelection(startDate, endDate, allDay) {
		renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true); // rebuild every time???
	}
	
	
	function clearSelection() {
		clearOverlays();
	}
	
	
	function reportDayClick(date, allDay, ev) {
		var cell = dateToCell(date);
		var _element = bodyCells[cell.row*colCnt + cell.col];
		trigger('dayClick', _element, date, allDay, ev);
	}
	
	
	
	/* External Dragging
	-----------------------------------------------------------------------*/
	
	
	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
			}
		}, ev);
	}
	
	
	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			var d = cellToDate(cell);
			trigger('drop', _dragElement, d, true, ev, ui);
		}
	}
	
	
	
	/* Utilities
	--------------------------------------------------------*/
	
	
	function defaultEventEnd(event) {
		return cloneDate(event.start);
	}
	
	
	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		headCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		bodyRows.each(function(i, _e) {
			if (i < rowCnt) {
				e = $(_e);
				n = e.offset().top;
				if (i) {
					p[1] = n;
				}
				p = [n];
				rows[i] = p;
			}
		});
		p[1] = n + e.outerHeight();
	});
	
	
	hoverListener = new HoverListener(coordinateGrid);
	
	colPositions = new HorizontalPositionCache(function(col) {
		return firstRowCellInners.eq(col);
	});

	colContentPositions = new HorizontalPositionCache(function(col) {
		return firstRowCellContentInners.eq(col);
	});


	function colLeft(col) {
		return colPositions.left(col);
	}


	function colRight(col) {
		return colPositions.right(col);
	}
	
	
	function colContentLeft(col) {
		return colContentPositions.left(col);
	}
	
	
	function colContentRight(col) {
		return colContentPositions.right(col);
	}
	
	
	function allDayRow(i) {
		return bodyRows.eq(i);
	}
	
}

;;

function BasicEventRenderer() {
	var t = this;
	
	
	// exports
	t.renderEvents = renderEvents;
	t.clearEvents = clearEvents;
	

	// imports
	DayEventRenderer.call(t);

	
	function renderEvents(events, modifiedEventId) {
		t.renderDayEvents(events, modifiedEventId);
	}
	
	
	function clearEvents() {
		t.getDaySegmentContainer().empty();
	}


	// TODO: have this class (and AgendaEventRenderer) be responsible for creating the event container div

}

;;

fcViews.agendaWeek = AgendaWeekView;

function AgendaWeekView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	AgendaView.call(t, element, calendar, 'agendaWeek');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var skipHiddenDays = t.skipHiddenDays;
	var getCellsPerWeek = t.getCellsPerWeek;
	var formatDates = calendar.formatDates;

	
	function render(date, delta) {

		if (delta) {
			addDays(date, delta * 7);
		}

		var start = addDays(cloneDate(date), -((date.getUTCDay() - opt('firstDay') + 7) % 7));
		var end = addDays(cloneDate(start), 7);

		var visStart = cloneDate(start);
		skipHiddenDays(visStart);

		var visEnd = cloneDate(end);
		skipHiddenDays(visEnd, -1, true);

		var colCnt = getCellsPerWeek();

		t.title = formatDates(
			visStart,
			addDays(cloneDate(visEnd), -1),
			opt('titleFormat')
		);

		t.start = start;
		t.end = end;
		t.visStart = visStart;
		t.visEnd = visEnd;

		renderAgenda(colCnt);
	}

}

;;

fcViews.agendaDay = AgendaDayView;


function AgendaDayView(element, calendar) {
	var t = this;
	
	
	// exports
	t.render = render;
	
	
	// imports
	AgendaView.call(t, element, calendar, 'agendaDay');
	var opt = t.opt;
	var renderAgenda = t.renderAgenda;
	var skipHiddenDays = t.skipHiddenDays;
	var formatDate = calendar.formatDate;
	
	
	function render(date, delta) {

		if (delta) {
			addDays(date, delta);
		}
		skipHiddenDays(date, delta < 0 ? -1 : 1);

		var start = cloneDate(date, true);
		var end = addDays(cloneDate(start), 1);

		t.title = formatDate(date, opt('titleFormat'));

		t.start = t.visStart = start;
		t.end = t.visEnd = end;

		renderAgenda(1);
	}
	

}

;;

setDefaults({
	allDaySlot: true,
	allDayText: 'all-day',
	firstHour: 6,
	slotMinutes: 30,
	defaultEventMinutes: 30,
	axisFormat: 'h(:mm)tt',
	timeFormat: {
            // SAH - altered to be more compact and to show A/P for the end time.
		agenda: 'h(:mm){-h(:mm)}T'
	},
	dragOpacity: {
		agenda: .5
	},
	minTime: 0,
	maxTime: 24,
	slotEventOverlap: true
});


// TODO: make it work in quirks mode (event corners, all-day height)
// TODO: test liquid width, especially in IE6


function AgendaView(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.renderAgenda = renderAgenda;
	t.setWidth = setWidth;
	t.setHeight = setHeight;
	t.afterRender = afterRender;
        t.resetScroll = resetScroll;
	t.defaultEventEnd = defaultEventEnd;
	t.timePosition = timePosition;
	t.getIsCellAllDay = getIsCellAllDay;
	t.allDayRow = getAllDayRow;
	t.getCoordinateGrid = function() { return coordinateGrid }; // specifically for AgendaEventRenderer
	t.getHoverListener = function() { return hoverListener };
	t.colLeft = colLeft;
	t.colRight = colRight;
	t.colContentLeft = colContentLeft;
	t.colContentRight = colContentRight;
	t.getDaySegmentContainer = function() { return daySegmentContainer };
	t.getSlotSegmentContainer = function() { return slotSegmentContainer };
	t.getMinMinute = function() { return minMinute };
	t.getMaxMinute = function() { return maxMinute };
	t.getSlotContainer = function() { return slotContainer };
	t.getRowCnt = function() { return 1 };
	t.getColCnt = function() { return colCnt };
	t.getColWidth = function() { return colWidth };
	t.getSnapHeight = function() { return snapHeight };
	t.getSnapMinutes = function() { return snapMinutes };
	t.defaultSelectionEnd = defaultSelectionEnd;
	t.renderDayOverlay = renderDayOverlay;
	t.renderSelection = renderSelection;
	t.clearSelection = clearSelection;
	t.reportDayClick = reportDayClick; // selection mousedown hack
	t.dragStart = dragStart;
	t.dragStop = dragStop;
        
        // Export the slot click handler.
        t.slotClick = slotClick;
	
	
	// imports
	View.call(t, element, calendar, viewName);
	OverlayManager.call(t);
	SelectionManager.call(t);
	AgendaEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var renderOverlay = t.renderOverlay;
	var clearOverlays = t.clearOverlays;
	var reportSelection = t.reportSelection;
	var unselect = t.unselect;
	var daySelectionMousedown = t.daySelectionMousedown;
	var slotSegHtml = t.slotSegHtml;
	var cellToDate = t.cellToDate;
	var dateToCell = t.dateToCell;
	var rangeToSegments = t.rangeToSegments;
	var formatDate = calendar.formatDate;
	
	
	// locals
	
	var dayTable;
	var dayHead;
	var dayHeadCells;
	var dayBody;
	var dayBodyCells;
	var dayBodyCellInners;
	var dayBodyCellContentInners;
	var dayBodyFirstCell;
	var dayBodyFirstCellStretcher;
	var slotLayer;
	var daySegmentContainer;
	var allDayTable;
	var allDayRow;
	var slotScroller;
	var slotContainer;
	var slotSegmentContainer;
	var slotTable;
	var selectionHelper;
	
	var viewWidth;
	var viewHeight;
	var axisWidth;
	var colWidth;
	var gutterWidth;
	var slotHeight; // TODO: what if slotHeight changes? (see issue 650)

	var snapMinutes;
	var snapRatio; // ratio of number of "selection" slots to normal slots. (ex: 1, 2, 4)
	var snapHeight; // holds the pixel hight of a "selection" slot
	
	var colCnt;
	var slotCnt;
	var coordinateGrid;
	var hoverListener;
	var colPositions;
	var colContentPositions;
	var slotTopCache = {};
	
	var tm;
	var rtl;
	var minMinute, maxMinute;
	var colFormat;
	var showWeekNumbers;
	var weekNumberTitle;
	var weekNumberFormat;
	

	
	/* Rendering
	-----------------------------------------------------------------------------*/
	
	
	disableTextSelection(element.addClass('fc-agenda'));
	
	
	function renderAgenda(c) {
		colCnt = c;
		updateOptions();

		if (!dayTable) { // first time rendering?
			buildSkeleton(); // builds day table, slot area, events containers
		}
		else {
			buildDayTable(); // rebuilds day table
		}
	}
	
	
	function updateOptions() {

		tm = opt('theme') ? 'ui' : 'fc';
		rtl = opt('isRTL')
		minMinute = parseTime(opt('minTime'));
		maxMinute = parseTime(opt('maxTime'));
		colFormat = opt('columnFormat');

		// week # options. (TODO: bad, logic also in other views)
		showWeekNumbers = opt('weekNumbers');
		weekNumberTitle = opt('weekNumberTitle');
		if (opt('weekNumberCalculation') != 'iso') {
			weekNumberFormat = "w";
		}
		else {
			weekNumberFormat = "W";
		}

		snapMinutes = opt('snapMinutes') || opt('slotMinutes');
	}



	/* Build DOM
	-----------------------------------------------------------------------*/


	function buildSkeleton() {
		var headerClass = tm + "-widget-header";
		var contentClass = tm + "-widget-content";
		var s;
		var d;
		var i;
		var maxd;
		var minutes;
		var slotNormal = opt('slotMinutes') % 15 == 0;
		
		buildDayTable();
		
		slotLayer =
			$("<div style='position:absolute;z-index:2;left:0;width:100%' class='pm-layout-full-height'/>")
				.appendTo(element);
				
		if (opt('allDaySlot')) {
		
			daySegmentContainer =
				$("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
					.appendTo(slotLayer);
		
			s =
				"<table style='width:100%' class='fc-agenda-allday' cellspacing='0'>" +
				"<tr>" +
				"<th class='" + headerClass + " fc-agenda-axis'>" + opt('allDayText') + "</th>" +
				"<td>" +
				"<div class='fc-day-content'><div style='position:relative'/></div>" +
				"</td>" +
				"<th class='" + headerClass + " fc-agenda-gutter'>&nbsp;</th>" +
				"</tr>" +
				"</table>";
			allDayTable = $(s).appendTo(slotLayer);
			allDayRow = allDayTable.find('tr');
			
			dayBind(allDayRow.find('td'));
			
			slotLayer.append(
				"<div class='fc-agenda-divider " + headerClass + "'>" +
				"<div class='fc-agenda-divider-inner'/>" +
				"</div>"
			);
			
		}else{
		
			daySegmentContainer = $([]); // in jQuery 1.4, we can just do $()
		
		}
		
		slotScroller =
			$("<div style='position:absolute;width:100%;overflow-x:hidden;overflow-y:scroll'/>")
				.appendTo(slotLayer);
				
		slotContainer =
			$("<div style='position:relative;width:100%;overflow:hidden'/>")
				.appendTo(slotScroller);
				
		slotSegmentContainer =
			$("<div class='fc-event-container' style='position:absolute;z-index:8;top:0;left:0'/>")
				.appendTo(slotContainer);
		
		s =
			"<table class='fc-agenda-slots' style='width:100%' cellspacing='0'>" +
			"<tbody>";
		d = zeroDate();
		maxd = addMinutes(cloneDate(d), maxMinute);
		addMinutes(d, minMinute);
		slotCnt = 0;
		for (i=0; d < maxd; i++) {
			minutes = d.getMinutes();
			s +=
				"<tr class='fc-slot" + i + ' ' + (!minutes ? '' : 'fc-minor') + "'>" +
				"<th class='fc-agenda-axis " + headerClass + "'>" +
				((!slotNormal || !minutes) ? formatDate(d, opt('axisFormat')) : '&nbsp;') +
				"</th>" +
				"<td class='" + contentClass + "'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</td>" +
				"</tr>";
			addMinutes(d, opt('slotMinutes'));
			slotCnt++;
		}
		s +=
			"</tbody>" +
			"</table>";
		slotTable = $(s).appendTo(slotContainer);
		
		slotBind(slotTable.find('td'));
	}



	/* Build Day Table
	-----------------------------------------------------------------------*/


	function buildDayTable() {
		var html = buildDayTableHTML();

		if (dayTable) {
			dayTable.remove();
		}
		dayTable = $(html).appendTo(element);

		dayHead = dayTable.find('thead');
		dayHeadCells = dayHead.find('th').slice(1, -1); // exclude gutter
		dayBody = dayTable.find('tbody');
		dayBodyCells = dayBody.find('td').slice(0, -1); // exclude gutter
		dayBodyCellInners = dayBodyCells.find('> div');
		dayBodyCellContentInners = dayBodyCells.find('.fc-day-content > div');

		dayBodyFirstCell = dayBodyCells.eq(0);
		dayBodyFirstCellStretcher = dayBodyCellInners.eq(0);
		
		markFirstLast(dayHead.add(dayHead.find('tr')));
		markFirstLast(dayBody.add(dayBody.find('tr')));

		// TODO: now that we rebuild the cells every time, we should call dayRender
	}


	function buildDayTableHTML() {
		var html =
			"<table style='width:100%' class='fc-agenda-days fc-border-separate pm-layout-full-height' cellspacing='0'>" +
			buildDayTableHeadHTML() +
			buildDayTableBodyHTML() +
			"</table>";

		return html;
	}


	function buildDayTableHeadHTML() {
		var headerClass = tm + "-widget-header";
		var date;
		var html = '';
		var weekText;
		var col;

		html +=
			"<thead>" +
			"<tr>";

		if (showWeekNumbers) {
			date = cellToDate(0, 0);
			weekText = formatDate(date, weekNumberFormat);
			if (rtl) {
				weekText += weekNumberTitle;
			}
			else {
				weekText = weekNumberTitle + weekText;
			}
			html +=
				"<th class='fc-agenda-axis fc-week-number " + headerClass + "'>" +
				htmlEscape(weekText) +
				"</th>";
		}
		else {
			html += "<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";
		}

		for (col=0; col<colCnt; col++) {
			date = cellToDate(0, col);
			html +=
				"<th class='fc-" + dayIDs[date.getDay()] + " fc-col" + col + ' ' + headerClass + "'>" +
				htmlEscape(formatDate(date, colFormat)) +
				"</th>";
		}

		html +=
			"<th class='fc-agenda-gutter " + headerClass + "'>&nbsp;</th>" +
			"</tr>" +
			"</thead>";

		return html;
	}


	function buildDayTableBodyHTML() {
		var headerClass = tm + "-widget-header"; // TODO: make these when updateOptions() called
		var contentClass = tm + "-widget-content";
		var date;
		var today = clearTime(new Date());
		var col;
		var cellsHTML;
		var cellHTML;
		var classNames;
		var html = '';

		html +=
			"<tbody>" +
			"<tr>" +
			"<th class='fc-agenda-axis " + headerClass + "'>&nbsp;</th>";

		cellsHTML = '';

		for (col=0; col<colCnt; col++) {

			date = cellToDate(0, col);

			classNames = [
				'fc-col' + col,
				'fc-' + dayIDs[date.getDay()],
				contentClass
			];
			if (+date == +today) {
				classNames.push(
					tm + '-state-highlight',
					'fc-today'
				);
			}
			else if (date < today) {
				classNames.push('fc-past');
			}
			else {
				classNames.push('fc-future');
			}

			cellHTML =
				"<td class='" + classNames.join(' ') + "'>" +
				"<div>" +
				"<div class='fc-day-content'>" +
				"<div style='position:relative'>&nbsp;</div>" +
				"</div>" +
				"</div>" +
				"</td>";

			cellsHTML += cellHTML;
		}

		html += cellsHTML;
		html +=
			"<td class='fc-agenda-gutter " + contentClass + "'>&nbsp;</td>" +
			"</tr>" +
			"</tbody>";

		return html;
	}


	// TODO: data-date on the cells

	
	
	/* Dimensions
	-----------------------------------------------------------------------*/

	
	function setHeight(height, viewPortHeight) {
		if (height === undefined || height === null) {
			height = viewPortHeight;
		}
		viewHeight = height;
		slotTopCache = {};
	
		var headHeight = dayBody.position().top;
                var headOffset = headHeight + calendar.contentOffset();
		var allDayHeight = slotScroller.position().top; // including divider
		
                /*
                var bodyHeight = Math.min( // total body height, including borders
			//height - headHeight,   // when scrollbars
                        height - headOffset,
			slotTable.height() + allDayHeight + 1 // when no scrollbars. +1 for bottom border
		);
                if (bodyHeight < 400) {
                    // SAH - force a minimum height of 400px
                    bodyHeight = 400;
                }*/

		//dayBodyFirstCellStretcher
		//	.height(bodyHeight - vsides(dayBodyFirstCell));
		
                var oldTop = parseInt(slotLayer.css('top'));
		slotLayer.css('top', headHeight);
                if (oldTop != headHeight) {
                    var diff = (headHeight - oldTop);
                    slotScroller.height(slotScroller.height() - diff);
                }
                
		//slotScroller.height(bodyHeight - allDayHeight - 1);
                
		// the stylesheet guarantees that the first row has no border.
		// this allows .height() to work well cross-browser.
		slotHeight = slotTable.find('tr:first').height() + 1; // +1 for bottom border

		snapRatio = opt('slotMinutes') / snapMinutes;
		snapHeight = slotHeight / snapRatio;
	}
	
	
	function setWidth(width) {
		viewWidth = width;
		colPositions.clear();
		colContentPositions.clear();

		var axisFirstCells = dayHead.find('th:first');
		if (allDayTable) {
			axisFirstCells = axisFirstCells.add(allDayTable.find('th:first'));
		}
		axisFirstCells = axisFirstCells.add(slotTable.find('th:first'));
		
		axisWidth = 0;
		setOuterWidth(
			axisFirstCells
				.width('')
				.each(function(i, _cell) {
					axisWidth = Math.max(axisWidth, $(_cell).outerWidth());
				}),
			axisWidth
		);
		
		var gutterCells = dayTable.find('.fc-agenda-gutter');
		if (allDayTable) {
			gutterCells = gutterCells.add(allDayTable.find('th.fc-agenda-gutter'));
		}

		var slotTableWidth = slotScroller[0].clientWidth; // needs to be done after axisWidth (for IE7)
		
		gutterWidth = slotScroller.width() - slotTableWidth;
		if (gutterWidth) {
			setOuterWidth(gutterCells, gutterWidth);
			gutterCells
				.show()
				.prev()
				.removeClass('fc-last');
		}else{
			gutterCells
				.hide()
				.prev()
				.addClass('fc-last');
		}
		
		colWidth = Math.floor((slotTableWidth - axisWidth) / colCnt);
		setOuterWidth(dayHeadCells.slice(0, -1), colWidth);
	}
	


	/* Scrolling
	-----------------------------------------------------------------------*/


	function resetScroll() {
		var d0 = zeroDate();
		var scrollDate = cloneDate(d0);
                // SAH - changed to addHours, which requires date.js
		scrollDate.addHours(opt('firstHour'));
		var top = timePosition(d0, scrollDate) + 1; // +1 for the border
		function scroll() {
                        //slotScroller.height(calendar.options.viewPortHeight);
			slotScroller.scrollTop(top);
		}
		scroll();
		setTimeout(scroll, 0); // overrides any previous scroll state made by the browser
	}


	function afterRender() { // after the view has been freshly rendered and sized
		resetScroll();
	}
	
	
	
	/* Slot/Day clicking and binding
	-----------------------------------------------------------------------*/
	

	function dayBind(cells) {
		cells.click(slotClick)
			.mousedown(daySelectionMousedown);
	}


	function slotBind(cells) {
		cells.click(slotClick)
			.mousedown(slotSelectionMousedown);
	}
	
	
	function slotClick(ev) {
		if (!opt('selectable')) { // if selectable, SelectionManager will worry about dayClick
			var col = Math.min(colCnt-1, Math.floor((ev.pageX - dayTable.offset().left - axisWidth) / colWidth));
			var date = cellToDate(0, col);
			var rowMatch = this.parentNode.className.match(/fc-slot(\d+)/); // TODO: maybe use data
			if (rowMatch) {
				var mins = parseInt(rowMatch[1]) * opt('slotMinutes');
				var hours = Math.floor(mins/60);
				date.setUTCHours(hours); /* SAH changed to UTC. */
				date.setUTCMinutes(mins%60 + minMinute);
				trigger('dayClick', dayBodyCells[col], date, false, ev);
			}else{
				trigger('dayClick', dayBodyCells[col], date, true, ev);
			}
		}
	}
	
	
	
	/* Semi-transparent Overlay Helpers
	-----------------------------------------------------*/
	// TODO: should be consolidated with BasicView's methods


	function renderDayOverlay(overlayStart, overlayEnd, refreshCoordinateGrid) { // overlayEnd is exclusive

		if (refreshCoordinateGrid) {
			coordinateGrid.build();
		}

		var segments = rangeToSegments(overlayStart, overlayEnd);

		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];
			dayBind(
				renderCellOverlay(
					segment.row,
					segment.leftCol,
					segment.row,
					segment.rightCol
				)
			);
		}
	}
	
	
	function renderCellOverlay(row0, col0, row1, col1) { // only for all-day?
		var rect = coordinateGrid.rect(row0, col0, row1, col1, slotLayer);
		return renderOverlay(rect, slotLayer);
	}
	

	function renderSlotOverlay(overlayStart, overlayEnd) {
		for (var i=0; i<colCnt; i++) {
			var dayStart = cellToDate(0, i);
			var dayEnd = addDays(cloneDate(dayStart), 1);
			var stretchStart = new Date(Math.max(dayStart, overlayStart));
			var stretchEnd = new Date(Math.min(dayEnd, overlayEnd));
			if (stretchStart < stretchEnd) {
				var rect = coordinateGrid.rect(0, i, 0, i, slotContainer); // only use it for horizontal coords
				var top = timePosition(dayStart, stretchStart);
				var bottom = timePosition(dayStart, stretchEnd);
				rect.top = top;
				rect.height = bottom - top;
				slotBind(
					renderOverlay(rect, slotContainer)
				);
			}
		}
	}
	
	
	
	/* Coordinate Utilities
	-----------------------------------------------------------------------------*/
	
	
	coordinateGrid = new CoordinateGrid(function(rows, cols) {
		var e, n, p;
		dayHeadCells.each(function(i, _e) {
			e = $(_e);
			n = e.offset().left;
			if (i) {
				p[1] = n;
			}
			p = [n];
			cols[i] = p;
		});
		p[1] = n + e.outerWidth();
		if (opt('allDaySlot')) {
			e = allDayRow;
			n = e.offset().top;
			rows[0] = [n, n+e.outerHeight()];
		}
		var slotTableTop = slotContainer.offset().top;
		var slotScrollerTop = slotScroller.offset().top;
		var slotScrollerBottom = slotScrollerTop + slotScroller.outerHeight();
		function constrain(n) {
			return Math.max(slotScrollerTop, Math.min(slotScrollerBottom, n));
		}
		for (var i=0; i<slotCnt*snapRatio; i++) { // adapt slot count to increased/decreased selection slot count
			rows.push([
				constrain(slotTableTop + snapHeight*i),
				constrain(slotTableTop + snapHeight*(i+1))
			]);
		}
	});
	
	
	hoverListener = new HoverListener(coordinateGrid);
	
	colPositions = new HorizontalPositionCache(function(col) {
		return dayBodyCellInners.eq(col);
	});
	
	colContentPositions = new HorizontalPositionCache(function(col) {
		return dayBodyCellContentInners.eq(col);
	});
	
	
	function colLeft(col) {
		return colPositions.left(col);
	}


	function colContentLeft(col) {
		return colContentPositions.left(col);
	}


	function colRight(col) {
		return colPositions.right(col);
	}
	
	
	function colContentRight(col) {
		return colContentPositions.right(col);
	}


	function getIsCellAllDay(cell) {
		return opt('allDaySlot') && !cell.row;
	}


	function realCellToDate(cell) { // ugh "real" ... but blame it on our abuse of the "cell" system
		var d = cellToDate(0, cell.col);
		var slotIndex = cell.row;
		if (opt('allDaySlot')) {
			slotIndex--;
		}
		if (slotIndex >= 0) {
			addMinutes(d, minMinute + slotIndex * snapMinutes);
		}
		return d;
	}
	
	
	// get the Y coordinate of the given time on the given day (both Date objects)
	function timePosition(day, time) { // both date objects. day holds 00:00 of current day
		day = cloneDate(day, true);
		if (time < addMinutes(cloneDate(day), minMinute)) {
			return 0;
		}
		if (time >= addMinutes(cloneDate(day), maxMinute)) {
			return slotTable.height();
		}
		var slotMinutes = opt('slotMinutes'),
			//minutes = time.getHours()*60 + time.getMinutes() - minMinute,
                        minutes = time.getUTCHours()*60 + time.getUTCMinutes() - minMinute,
			slotI = Math.floor(minutes / slotMinutes),
			slotTop = slotTopCache[slotI];
		if (slotTop === undefined) {
			slotTop = slotTopCache[slotI] =
				slotTable.find('tr').eq(slotI).find('td div')[0].offsetTop;
				// .eq() is faster than ":eq()" selector
				// [0].offsetTop is faster than .position().top (do we really need this optimization?)
				// a better optimization would be to cache all these divs
		}
		return Math.max(0, Math.round(
			slotTop - 1 + slotHeight * ((minutes % slotMinutes) / slotMinutes)
		));
	}
	
	
	function getAllDayRow(index) {
		return allDayRow;
	}
	
	
	function defaultEventEnd(event) {
		var start = cloneDate(event.start);
		if (event.allDay) {
			return start;
		}
		return addMinutes(start, opt('defaultEventMinutes'));
	}
	
	
	
	/* Selection
	---------------------------------------------------------------------------------*/
	
	
	function defaultSelectionEnd(startDate, allDay) {
		if (allDay) {
			return cloneDate(startDate);
		}
		return addMinutes(cloneDate(startDate), opt('slotMinutes'));
	}
	
	
	function renderSelection(startDate, endDate, allDay) { // only for all-day
		if (allDay) {
			if (opt('allDaySlot')) {
				renderDayOverlay(startDate, addDays(cloneDate(endDate), 1), true);
			}
		}else{
			renderSlotSelection(startDate, endDate);
		}
	}
	
	
	function renderSlotSelection(startDate, endDate) {
		var helperOption = opt('selectHelper');
		coordinateGrid.build();
		if (helperOption) {
			var col = dateToCell(startDate).col;
			if (col >= 0 && col < colCnt) { // only works when times are on same day
				var rect = coordinateGrid.rect(0, col, 0, col, slotContainer); // only for horizontal coords
				var top = timePosition(startDate, startDate);
				var bottom = timePosition(startDate, endDate);
				if (bottom > top) { // protect against selections that are entirely before or after visible range
					rect.top = top;
					rect.height = bottom - top;
					rect.left += 2;
					rect.width -= 5;
					if ($.isFunction(helperOption)) {
						var helperRes = helperOption(startDate, endDate);
						if (helperRes) {
							rect.position = 'absolute';
							selectionHelper = $(helperRes)
								.css(rect)
								.appendTo(slotContainer);
						}
					}else{
						rect.isStart = true; // conside rect a "seg" now
						rect.isEnd = true;   //
						selectionHelper = $(slotSegHtml(
							{
								title: '',
								start: startDate,
								end: endDate,
								className: ['fc-select-helper'],
								editable: false
							},
							rect
						));
						selectionHelper.css('opacity', opt('dragOpacity'));
					}
					if (selectionHelper) {
						slotBind(selectionHelper);
						slotContainer.append(selectionHelper);
						setOuterWidth(selectionHelper, rect.width, true); // needs to be after appended
						setOuterHeight(selectionHelper, rect.height, true);
					}
				}
			}
		}else{
			renderSlotOverlay(startDate, endDate);
		}
	}
	
	
	function clearSelection() {
		clearOverlays();
		if (selectionHelper) {
			selectionHelper.remove();
			selectionHelper = null;
		}
	}
	
	
	function slotSelectionMousedown(ev) {
		if (ev.which == 1 && opt('selectable')) { // ev.which==1 means left mouse button
			unselect(ev);
			var dates;
			hoverListener.start(function(cell, origCell) {
				clearSelection();
				if (cell && cell.col == origCell.col && !getIsCellAllDay(cell)) {
					var d1 = realCellToDate(origCell);
					var d2 = realCellToDate(cell);
					dates = [
						d1,
						addMinutes(cloneDate(d1), snapMinutes), // calculate minutes depending on selection slot minutes 
						d2,
						addMinutes(cloneDate(d2), snapMinutes)
					].sort(dateCompare);
					renderSlotSelection(dates[0], dates[3]);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], false, ev);
					}
					reportSelection(dates[0], dates[3], false, ev);
				}
			});
		}
	}


	function reportDayClick(date, allDay, ev) {
		trigger('dayClick', dayBodyCells[dateToCell(date).col], date, allDay, ev);
	}
	
	
	
	/* External Dragging
	--------------------------------------------------------------------------------*/
	
	
	function dragStart(_dragElement, ev, ui) {
		hoverListener.start(function(cell) {
			clearOverlays();
			if (cell) {
				if (getIsCellAllDay(cell)) {
					renderCellOverlay(cell.row, cell.col, cell.row, cell.col);
				}else{
					var d1 = realCellToDate(cell);
					var d2 = addMinutes(cloneDate(d1), opt('defaultEventMinutes'));
					renderSlotOverlay(d1, d2);
				}
			}
		}, ev);
	}
	
	
	function dragStop(_dragElement, ev, ui) {
		var cell = hoverListener.stop();
		clearOverlays();
		if (cell) {
			trigger('drop', _dragElement, realCellToDate(cell), getIsCellAllDay(cell), ev, ui);
		}
	}
	

}

;;

function AgendaEventRenderer() {
	var t = this;
	
	
	// exports
	t.renderEvents = renderEvents;
	t.clearEvents = clearEvents;
	t.slotSegHtml = slotSegHtml;
	
	
	// imports
	DayEventRenderer.call(t);
	var opt = t.opt;
	var trigger = t.trigger;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var eventElementHandlers = t.eventElementHandlers;
	var setHeight = t.setHeight;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var getSlotSegmentContainer = t.getSlotSegmentContainer;
	var getHoverListener = t.getHoverListener;
	var getMaxMinute = t.getMaxMinute;
	var getMinMinute = t.getMinMinute;
	var timePosition = t.timePosition;
	var getIsCellAllDay = t.getIsCellAllDay;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var cellToDate = t.cellToDate;
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var getSnapHeight = t.getSnapHeight;
	var getSnapMinutes = t.getSnapMinutes;
	var getSlotContainer = t.getSlotContainer;
	var reportEventElement = t.reportEventElement;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var eventResize = t.eventResize;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var renderDayEvents = t.renderDayEvents;
	var calendar = t.calendar;
	var formatDate = calendar.formatDate;
	var formatDates = calendar.formatDates;


	// overrides
	t.draggableDayEvent = draggableDayEvent;

	
	
	/* Rendering
	----------------------------------------------------------------------------*/
	

	function renderEvents(events, modifiedEventId) {
		var i, len=events.length,
			dayEvents=[],
			slotEvents=[];
		for (i=0; i<len; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}else{
				slotEvents.push(events[i]);
			}
		}

		if (opt('allDaySlot')) {
			renderDayEvents(dayEvents, modifiedEventId);
			setTimeout(function() {
                            // Allow the time to reset itself before we fix the heights.
                            setHeight(null, calendar.options.viewPortHeight); // no params means set to viewHeight
                        }, 0);
		}

		renderSlotSegs(compileSlotSegs(slotEvents), modifiedEventId);
	}
	
	
	function clearEvents() {
		getDaySegmentContainer().empty();
		getSlotSegmentContainer().empty();
	}

	
	function compileSlotSegs(events) {
		var colCnt = getColCnt(),
			minMinute = getMinMinute(),
			maxMinute = getMaxMinute(),
			d,
			visEventEnds = $.map(events, slotEventEnd),
			i,
			j, seg,
			colSegs,
			segs = [];

		for (i=0; i<colCnt; i++) {

			d = cellToDate(0, i);
			addMinutes(d, minMinute);

			colSegs = sliceSegs(
				events,
				visEventEnds,
				d,
				addMinutes(cloneDate(d), maxMinute-minMinute)
			);

			colSegs = placeSlotSegs(colSegs); // returns a new order

			for (j=0; j<colSegs.length; j++) {
				seg = colSegs[j];
				seg.col = i;
				segs.push(seg);
			}
		}

		return segs;
	}


	function sliceSegs(events, visEventEnds, start, end) {
		var segs = [],
			i, len=events.length, event,
			eventStart, eventEnd,
			segStart, segEnd,
			isStart, isEnd;
		for (i=0; i<len; i++) {
			event = events[i];
			eventStart = event.start;
			eventEnd = visEventEnds[i];
			if (eventEnd > start && eventStart < end) {
				if (eventStart < start) {
					segStart = cloneDate(start);
					isStart = false;
				}else{
					segStart = eventStart;
					isStart = true;
				}
				if (eventEnd > end) {
					segEnd = cloneDate(end);
					isEnd = false;
				}else{
					segEnd = eventEnd;
					isEnd = true;
				}
				segs.push({
					event: event,
					start: segStart,
					end: segEnd,
					isStart: isStart,
					isEnd: isEnd
				});
			}
		}
		return segs.sort(compareSlotSegs);
	}


	function slotEventEnd(event) {
		if (event.end) {
			return cloneDate(event.end);
		}else{
			return addMinutes(cloneDate(event.start), opt('defaultEventMinutes'));
		}
	}
	
	
	// renders events in the 'time slots' at the bottom
	// TODO: when we refactor this, when user returns `false` eventRender, don't have empty space
	// TODO: refactor will include using pixels to detect collisions instead of dates (handy for seg cmp)
	
	function renderSlotSegs(segs, modifiedEventId) {
	
		var i, segCnt=segs.length, seg,
			event,
			top,
			bottom,
			columnLeft,
			columnRight,
			columnWidth,
			width,
			left,
			right,
			html = '',
			eventElements,
			eventElement,
			triggerRes,
			titleElement,
			height,
			slotSegmentContainer = getSlotSegmentContainer(),
			isRTL = opt('isRTL');
			
		// calculate position/dimensions, create html
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			top = timePosition(seg.start, seg.start);
			bottom = timePosition(seg.start, seg.end);
			columnLeft = colContentLeft(seg.col);
			columnRight = colContentRight(seg.col);
			columnWidth = columnRight - columnLeft;

			// shave off space on right near scrollbars (2.5%)
			// TODO: move this to CSS somehow
			columnRight -= columnWidth * opt('rightBuffer');
			columnWidth = columnRight - columnLeft;

			width = columnWidth * (seg.forwardCoord - seg.backwardCoord);

			if (opt('slotEventOverlap')) {
				// double the width while making sure resize handle is visible
				// (assumed to be 20px wide)
				width = Math.max(
					(width - (20/2)) * 2,
					width // narrow columns will want to make the segment smaller than
						// the natural width. don't allow it
				);
			}

			if (isRTL) {
				right = columnRight - seg.backwardCoord * columnWidth;
				left = right - width;
			}
			else {
				left = columnLeft + seg.backwardCoord * columnWidth;
				right = left + width;
			}

			// make sure horizontal coordinates are in bounds
			left = Math.max(left, columnLeft);
			right = Math.min(right, columnRight);
			width = right - left;

			seg.top = top;
			seg.left = left;
			seg.outerWidth = width;
			seg.outerHeight = bottom - top;
			html += slotSegHtml(event, seg);
		}

		slotSegmentContainer[0].innerHTML = html; // faster than html()
		eventElements = slotSegmentContainer.children();
		
		// retrieve elements, run through eventRender callback, bind event handlers
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			event = seg.event;
			eventElement = $(eventElements[i]); // faster than eq()
			triggerRes = trigger('eventRender', event, event, eventElement);
			if (triggerRes === false) {
				eventElement.remove();
			}else{
				if (triggerRes && triggerRes !== true) {
					eventElement.remove();
					eventElement = $(triggerRes)
						.css({
							position: 'absolute',
							top: seg.top,
							left: seg.left
						})
						.appendTo(slotSegmentContainer);
				}
				seg.element = eventElement;
				if (event._id === modifiedEventId) {
					bindSlotSeg(event, eventElement, seg);
				}else{
					eventElement[0]._fci = i; // for lazySegBind
				}
				reportEventElement(event, eventElement);
			}
		}
		
		lazySegBind(slotSegmentContainer, segs, bindSlotSeg);
		
		// record event sides and title positions
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				seg.vsides = vsides(eventElement, true);
				seg.hsides = hsides(eventElement, true);
				titleElement = eventElement.find('.fc-event-title');
				if (titleElement.length) {
					seg.contentTop = titleElement[0].offsetTop;
				}
			}
		}
		
		// set all positions/dimensions at once
		for (i=0; i<segCnt; i++) {
			seg = segs[i];
			if (eventElement = seg.element) {
				eventElement[0].style.width = Math.max(0, seg.outerWidth - seg.hsides) + 'px';
				height = Math.max(0, seg.outerHeight - seg.vsides);
				eventElement[0].style.height = height + 'px';
				event = seg.event;
				if (1 || (seg.contentTop !== undefined && height - seg.contentTop < 10)) {
                                    /* SAH: make this the default behavior. Even on tablets the extra real estate is valuable. */
					// not enough room for title, put it in the time (TODO: maybe make both display:inline instead)
					eventElement.find('div.fc-event-time')
						.text(formatDate(event.start, opt('timeFormat')) + ' - ' + event.title)
                                                .css('white-space', 'normal');
					eventElement.find('div.fc-event-title')
						.remove();
				}
				trigger('eventAfterRender', event, event, eventElement);
			}
		}
					
	}
	
	
	function slotSegHtml(event, seg) {
		var html = "<";
		var url = event.url;
		var skinCss = getSkinCss(event, opt);
		var classes = ['fc-event', 'fc-event-vert'];
		if (isEventDraggable(event)) {
			classes.push('fc-event-draggable');
		}
		if (seg.isStart) {
			classes.push('fc-event-start');
		}
		if (seg.isEnd) {
			classes.push('fc-event-end');
		}
		classes = classes.concat(event.className);
		if (event.source) {
			classes = classes.concat(event.source.className || []);
		}
		if (url) {
			html += "a href='" + htmlEscape(event.url) + "'";
		}else{
			html += "div";
		}
		html +=
			" class='" + classes.join(' ') + "'" +
			" style=" +
				"'" +
				"position:absolute;" +
				"top:" + seg.top + "px;" +
				"left:" + seg.left + "px;" +
				skinCss +
				"'" +
			">" +
			"<div class='fc-event-inner'>" +
			"<div class='fc-event-time'>" +
			htmlEscape(formatDates(event.start, event.end, opt('timeFormat'))) +
			"</div>" +
			"<div class='fc-event-title'>" +
			htmlEscape(event.title || '') +
			"</div>" +
			"</div>" +
			"<div class='fc-event-bg'></div>";
		if (seg.isEnd && isEventResizable(event)) {
			html +=
				"<div class='ui-resizable-handle ui-resizable-s'>=</div>";
		}
		html +=
			"</" + (url ? "a" : "div") + ">";
		return html;
	}
	
	
	function bindSlotSeg(event, eventElement, seg) {
		var timeElement = eventElement.find('div.fc-event-time');
		if (isEventDraggable(event)) {
			draggableSlotEvent(event, eventElement, timeElement);
		}
		if (seg.isEnd && isEventResizable(event)) {
			resizableSlotEvent(event, eventElement, timeElement);
		}
		eventElementHandlers(event, eventElement);
	}
	
	
	
	/* Dragging
	-----------------------------------------------------------------------------------*/
	
	
	// when event starts out FULL-DAY
	// overrides DayEventRenderer's version because it needs to account for dragging elements
	// to and from the slot area.
	
	function draggableDayEvent(event, eventElement, seg) {
		var isStart = seg.isStart;
		var origWidth;
		var revert;
		var allDay = true;
		var dayDelta;
		var hoverListener = getHoverListener();
		var colWidth = getColWidth();
		var snapHeight = getSnapHeight();
		var snapMinutes = getSnapMinutes();
		var minMinute = getMinMinute();
		eventElement.draggable({
			opacity: opt('dragOpacity', 'month'), // use whatever the month view was using
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				origWidth = eventElement.width();
				hoverListener.start(function(cell, origCell) {
					clearOverlays();
					if (cell) {
						revert = false;
						var origDate = cellToDate(0, origCell.col);
						var date = cellToDate(0, cell.col);
						dayDelta = dayDiff(date, origDate);
						if (!cell.row) {
							// on full-days
							renderDayOverlay(
								addDays(cloneDate(event.start), dayDelta),
								addDays(exclEndDay(event), dayDelta)
							);
							resetElement();
						}else{
							// mouse is over bottom slots
							if (isStart) {
								if (allDay) {
									// convert event to temporary slot-event
									eventElement.width(colWidth - 10); // don't use entire width
									setOuterHeight(
										eventElement,
										snapHeight * Math.round(
											(event.end ? ((event.end - event.start) / MINUTE_MS) : opt('defaultEventMinutes')) /
												snapMinutes
										)
									);
									eventElement.draggable('option', 'grid', [colWidth, 1]);
									allDay = false;
								}
							}else{
								revert = true;
							}
						}
						revert = revert || (allDay && !dayDelta);
					}else{
						resetElement();
						revert = true;
					}
					eventElement.draggable('option', 'revert', revert);
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (revert) {
					// hasn't moved or is out of bounds (draggable has already reverted)
					resetElement();
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}else{
					// changed!
					var minuteDelta = 0;
					if (!allDay) {
						minuteDelta = Math.round((eventElement.offset().top - getSlotContainer().offset().top) / snapHeight)
							* snapMinutes
							+ minMinute
							- (event.start.getHours() * 60 + event.start.getMinutes());
					}
					eventDrop(this, event, dayDelta, minuteDelta, allDay, ev, ui);
				}
			}
		});
		function resetElement() {
			if (!allDay) {
				eventElement
					.width(origWidth)
					.height('')
					.draggable('option', 'grid', null);
				allDay = true;
			}
		}
	}
	
	
	// when event starts out IN TIMESLOTS
	
	function draggableSlotEvent(event, eventElement, timeElement) {
		var coordinateGrid = t.getCoordinateGrid();
		var colCnt = getColCnt();
		var colWidth = getColWidth();
		var snapHeight = getSnapHeight();
		var snapMinutes = getSnapMinutes();

		// states
		var origPosition; // original position of the element, not the mouse
		var origCell;
		var isInBounds, prevIsInBounds;
		var isAllDay, prevIsAllDay;
		var colDelta, prevColDelta;
		var dayDelta; // derived from colDelta
		var minuteDelta, prevMinuteDelta;

		eventElement.draggable({
			scroll: false,
			grid: [ colWidth, snapHeight ],
			axis: colCnt==1 ? 'y' : false,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {

				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);

				coordinateGrid.build();

				// initialize states
				origPosition = eventElement.position();
				origCell = coordinateGrid.cell(ev.pageX, ev.pageY);
				isInBounds = prevIsInBounds = true;
				isAllDay = prevIsAllDay = getIsCellAllDay(origCell);
				colDelta = prevColDelta = 0;
				dayDelta = 0;
				minuteDelta = prevMinuteDelta = 0;

			},
			drag: function(ev, ui) {

				// NOTE: this `cell` value is only useful for determining in-bounds and all-day.
				// Bad for anything else due to the discrepancy between the mouse position and the
				// element position while snapping. (problem revealed in PR #55)
				//
				// PS- the problem exists for draggableDayEvent() when dragging an all-day event to a slot event.
				// We should overhaul the dragging system and stop relying on jQuery UI.
				var cell = coordinateGrid.cell(ev.pageX, ev.pageY);

				// update states
				isInBounds = !!cell;
				if (isInBounds) {
					isAllDay = getIsCellAllDay(cell);

					// calculate column delta
					colDelta = Math.round((ui.position.left - origPosition.left) / colWidth);
					if (colDelta != prevColDelta) {
						// calculate the day delta based off of the original clicked column and the column delta
						var origDate = cellToDate(0, origCell.col);
						var col = origCell.col + colDelta;
						col = Math.max(0, col);
						col = Math.min(colCnt-1, col);
						var date = cellToDate(0, col);
						dayDelta = dayDiff(date, origDate);
					}

					// calculate minute delta (only if over slots)
					if (!isAllDay) {
						minuteDelta = Math.round((ui.position.top - origPosition.top) / snapHeight) * snapMinutes;
					}
				}

				// any state changes?
				if (
					isInBounds != prevIsInBounds ||
					isAllDay != prevIsAllDay ||
					colDelta != prevColDelta ||
					minuteDelta != prevMinuteDelta
				) {

					updateUI();

					// update previous states for next time
					prevIsInBounds = isInBounds;
					prevIsAllDay = isAllDay;
					prevColDelta = colDelta;
					prevMinuteDelta = minuteDelta;
				}

				// if out-of-bounds, revert when done, and vice versa.
				eventElement.draggable('option', 'revert', !isInBounds);

			},
			stop: function(ev, ui) {

				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);

				if (isInBounds && (isAllDay || dayDelta || minuteDelta)) { // changed!
					eventDrop(this, event, dayDelta, isAllDay ? 0 : minuteDelta, isAllDay, ev, ui);
				}
				else { // either no change or out-of-bounds (draggable has already reverted)

					// reset states for next time, and for updateUI()
					isInBounds = true;
					isAllDay = false;
					colDelta = 0;
					dayDelta = 0;
					minuteDelta = 0;

					updateUI();
					eventElement.css('filter', ''); // clear IE opacity side-effects

					// sometimes fast drags make event revert to wrong position, so reset.
					// also, if we dragged the element out of the area because of snapping,
					// but the *mouse* is still in bounds, we need to reset the position.
					eventElement.css(origPosition);

					showEvents(event, eventElement);
				}
			}
		});

		function updateUI() {
			clearOverlays();
			if (isInBounds) {
				if (isAllDay) {
					timeElement.hide();
					eventElement.draggable('option', 'grid', null); // disable grid snapping
					renderDayOverlay(
						addDays(cloneDate(event.start), dayDelta),
						addDays(exclEndDay(event), dayDelta)
					);
				}
				else {
					updateTimeText(minuteDelta);
					timeElement.css('display', ''); // show() was causing display=inline
					eventElement.draggable('option', 'grid', [colWidth, snapHeight]); // re-enable grid snapping
				}
			}
		}

		function updateTimeText(minuteDelta) {
			var newStart = addMinutes(cloneDate(event.start), minuteDelta);
			var newEnd;
			if (event.end) {
				newEnd = addMinutes(cloneDate(event.end), minuteDelta);
			}
			timeElement.text(formatDates(newStart, newEnd, opt('timeFormat')));
		}

	}
	
	
	
	/* Resizing
	--------------------------------------------------------------------------------------*/
	
	
	function resizableSlotEvent(event, eventElement, timeElement) {
		var snapDelta, prevSnapDelta;
		var snapHeight = getSnapHeight();
		var snapMinutes = getSnapMinutes();
		eventElement.resizable({
			handles: {
				s: '.ui-resizable-handle'
			},
			grid: snapHeight,
			start: function(ev, ui) {
				snapDelta = prevSnapDelta = 0;
				hideEvents(event, eventElement);
				trigger('eventResizeStart', this, event, ev, ui);
			},
			resize: function(ev, ui) {
				// don't rely on ui.size.height, doesn't take grid into account
				snapDelta = Math.round((Math.max(snapHeight, eventElement.height()) - ui.originalSize.height) / snapHeight);
				if (snapDelta != prevSnapDelta) {
					timeElement.text(
						formatDates(
							event.start,
							(!snapDelta && !event.end) ? null : // no change, so don't display time range
								addMinutes(eventEnd(event), snapMinutes*snapDelta),
							opt('timeFormat')
						)
					);
					prevSnapDelta = snapDelta;
				}
			},
			stop: function(ev, ui) {
				trigger('eventResizeStop', this, event, ev, ui);
				if (snapDelta) {
					eventResize(this, event, 0, snapMinutes*snapDelta, ev, ui);
				}else{
					showEvents(event, eventElement);
					// BUG: if event was really short, need to put title back in span
				}
			}
		});
	}
	

}



/* Agenda Event Segment Utilities
-----------------------------------------------------------------------------*/


// Sets the seg.backwardCoord and seg.forwardCoord on each segment and returns a new
// list in the order they should be placed into the DOM (an implicit z-index).
function placeSlotSegs(segs) {
	var levels = buildSlotSegLevels(segs);
	var level0 = levels[0];
	var i;

	computeForwardSlotSegs(levels);

	if (level0) {

		for (i=0; i<level0.length; i++) {
			computeSlotSegPressures(level0[i]);
		}

		for (i=0; i<level0.length; i++) {
			computeSlotSegCoords(level0[i], 0, 0);
		}
	}

	return flattenSlotSegLevels(levels);
}


// Builds an array of segments "levels". The first level will be the leftmost tier of segments
// if the calendar is left-to-right, or the rightmost if the calendar is right-to-left.
function buildSlotSegLevels(segs) {
	var levels = [];
	var i, seg;
	var j;

	for (i=0; i<segs.length; i++) {
		seg = segs[i];

		// go through all the levels and stop on the first level where there are no collisions
		for (j=0; j<levels.length; j++) {
			if (!computeSlotSegCollisions(seg, levels[j]).length) {
				break;
			}
		}

		(levels[j] || (levels[j] = [])).push(seg);
	}

	return levels;
}


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
	var i, level;
	var j, seg;
	var k;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			seg = level[j];

			seg.forwardSegs = [];
			for (k=i+1; k<levels.length; k++) {
				computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
			}
		}
	}
}


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
	var forwardSegs = seg.forwardSegs;
	var forwardPressure = 0;
	var i, forwardSeg;

	if (seg.forwardPressure === undefined) { // not already computed

		for (i=0; i<forwardSegs.length; i++) {
			forwardSeg = forwardSegs[i];

			// figure out the child's maximum forward path
			computeSlotSegPressures(forwardSeg);

			// either use the existing maximum, or use the child's forward pressure
			// plus one (for the forwardSeg itself)
			forwardPressure = Math.max(
				forwardPressure,
				1 + forwardSeg.forwardPressure
			);
		}

		seg.forwardPressure = forwardPressure;
	}
}


// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
//
// The segment might be part of a "series", which means consecutive segments with the same pressure
// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
// coordinate of the first segment in the series.
function computeSlotSegCoords(seg, seriesBackwardPressure, seriesBackwardCoord) {
	var forwardSegs = seg.forwardSegs;
	var i;

	if (seg.forwardCoord === undefined) { // not already computed

		if (!forwardSegs.length) {

			// if there are no forward segments, this segment should butt up against the edge
			seg.forwardCoord = 1;
		}
		else {

			// sort highest pressure first
			forwardSegs.sort(compareForwardSlotSegs);

			// this segment's forwardCoord will be calculated from the backwardCoord of the
			// highest-pressure forward segment.
			computeSlotSegCoords(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
			seg.forwardCoord = forwardSegs[0].backwardCoord;
		}

		// calculate the backwardCoord from the forwardCoord. consider the series
		seg.backwardCoord = seg.forwardCoord -
			(seg.forwardCoord - seriesBackwardCoord) / // available width for series
			(seriesBackwardPressure + 1); // # of segments in the series

		// use this segment's coordinates to computed the coordinates of the less-pressurized
		// forward segments
		for (i=0; i<forwardSegs.length; i++) {
			computeSlotSegCoords(forwardSegs[i], 0, seg.forwardCoord);
		}
	}
}


// Outputs a flat array of segments, from lowest to highest level
function flattenSlotSegLevels(levels) {
	var segs = [];
	var i, level;
	var j;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			segs.push(level[j]);
		}
	}

	return segs;
}


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
	results = results || [];

	for (var i=0; i<otherSegs.length; i++) {
		if (isSlotSegCollision(seg, otherSegs[i])) {
			results.push(otherSegs[i]);
		}
	}

	return results;
}


// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
	return seg1.end > seg2.start && seg1.start < seg2.end;
}


// A cmp function for determining which forward segment to rely on more when computing coordinates.
function compareForwardSlotSegs(seg1, seg2) {
	// put higher-pressure first
	return seg2.forwardPressure - seg1.forwardPressure ||
		// put segments that are closer to initial edge first (and favor ones with no coords yet)
		(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
		// do normal sorting...
		compareSlotSegs(seg1, seg2);
}


// A cmp function for determining which segment should be closer to the initial edge
// (the left edge on a left-to-right calendar).
function compareSlotSegs(seg1, seg2) {
	return seg1.start - seg2.start || // earlier start time goes first
		(seg2.end - seg2.start) - (seg1.end - seg1.start) || // tie? longer-duration goes first
		(seg1.event.title || '').localeCompare(seg2.event.title); // tie? alphabetically by title
}


;;


function View(element, calendar, viewName) {
	var t = this;
	
	
	// exports
	t.element = element;
	t.calendar = calendar;
	t.name = viewName;
	t.opt = opt;
	t.trigger = trigger;
	t.isEventDraggable = isEventDraggable;
	t.isEventResizable = isEventResizable;
	t.setEventData = setEventData;
	t.clearEventData = clearEventData;
	t.eventEnd = eventEnd;
	t.reportEventElement = reportEventElement;
	t.triggerEventDestroy = triggerEventDestroy;
	t.eventElementHandlers = eventElementHandlers;
	t.showEvents = showEvents;
	t.hideEvents = hideEvents;
	t.eventDrop = eventDrop;
	t.eventResize = eventResize;
	// t.title
	// t.start, t.end
	// t.visStart, t.visEnd
	
	
	// imports
	var defaultEventEnd = t.defaultEventEnd;
	var normalizeEvent = calendar.normalizeEvent; // in EventManager
	var reportEventChange = calendar.reportEventChange;
	
	
	// locals
	var eventsByID = {}; // eventID mapped to array of events (there can be multiple b/c of repeating events)
	var eventElementsByID = {}; // eventID mapped to array of jQuery elements
	var eventElementCouples = []; // array of objects, { event, element } // TODO: unify with segment system
	var options = calendar.options;
	
	
	
	function opt(name, viewNameOverride) {
		var v = options[name];
		if ($.isPlainObject(v)) {
			return smartProperty(v, viewNameOverride || viewName);
		}
		return v;
	}

	
	function trigger(name, thisObj) {
		return calendar.trigger.apply(
			calendar,
			[name, thisObj || t].concat(Array.prototype.slice.call(arguments, 2), [t])
		);
	}
	


	/* Event Editable Boolean Calculations
	------------------------------------------------------------------------------*/

	
	function isEventDraggable(event) {
		var source = event.source || {};
		return firstDefined(
				event.startEditable,
				source.startEditable,
				opt('eventStartEditable'),
				event.editable,
				source.editable,
				opt('editable')
			)
			&& !opt('disableDragging'); // deprecated
	}
	
	
	function isEventResizable(event) { // but also need to make sure the seg.isEnd == true
		var source = event.source || {};
		return firstDefined(
				event.durationEditable,
				source.durationEditable,
				opt('eventDurationEditable'),
				event.editable,
				source.editable,
				opt('editable')
			)
			&& !opt('disableResizing'); // deprecated
	}
	
	
	
	/* Event Data
	------------------------------------------------------------------------------*/
	
	
	function setEventData(events) { // events are already normalized at this point
		eventsByID = {};
		var i, len=events.length, event;
		for (i=0; i<len; i++) {
			event = events[i];
			if (eventsByID[event._id]) {
				eventsByID[event._id].push(event);
			}else{
				eventsByID[event._id] = [event];
			}
		}
	}


	function clearEventData() {
		eventsByID = {};
		eventElementsByID = {};
		eventElementCouples = [];
	}
	
	
	// returns a Date object for an event's end
	function eventEnd(event) {
		return event.end ? cloneDate(event.end) : defaultEventEnd(event);
	}
	
	
	
	/* Event Elements
	------------------------------------------------------------------------------*/
	
	
	// report when view creates an element for an event
	function reportEventElement(event, element) {
		eventElementCouples.push({ event: event, element: element });
		if (eventElementsByID[event._id]) {
			eventElementsByID[event._id].push(element);
		}else{
			eventElementsByID[event._id] = [element];
		}
	}


	function triggerEventDestroy() {
		$.each(eventElementCouples, function(i, couple) {
			t.trigger('eventDestroy', couple.event, couple.event, couple.element);
		});
	}
	
	
	// attaches eventClick, eventMouseover, eventMouseout
	function eventElementHandlers(event, eventElement) {
		eventElement
			.click(function(ev) {
				if (!eventElement.hasClass('ui-draggable-dragging') &&
                                    !eventElement.hasClass('ui-resizable-resizing')) {
                                    if (calendar.options.passThroughEventClicks) {                                        
                                        return trigger('dayClick', this, event.start, false, ev);
                                    } else {
                                        return trigger('eventClick', this, event, ev);
                                    }
                                }
			})
			.hover(
				function(ev) {
					trigger('eventMouseover', this, event, ev);
				},
				function(ev) {
					trigger('eventMouseout', this, event, ev);
				}
			)
                        .on(Helix.contextEvent, function(ev) {
                                return trigger('contextClick', this, event, ev);
                        });
		// TODO: don't fire eventMouseover/eventMouseout *while* dragging is occuring (on subject element)
		// TODO: same for resizing
	}
	
	
	function showEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'show');
	}
	
	
	function hideEvents(event, exceptElement) {
		eachEventElement(event, exceptElement, 'hide');
	}
	
	
	function eachEventElement(event, exceptElement, funcName) {
		// NOTE: there may be multiple events per ID (repeating events)
		// and multiple segments per event
		var elements = eventElementsByID[event._id],
			i, len = elements.length;
		for (i=0; i<len; i++) {
			if (!exceptElement || elements[i][0] != exceptElement[0]) {
				elements[i][funcName]();
			}
		}
	}
	
	
	
	/* Event Modification Reporting
	---------------------------------------------------------------------------------*/
	
	
	function eventDrop(e, event, dayDelta, minuteDelta, allDay, ev, ui) {
		var oldAllDay = event.allDay;
		var eventId = event._id;
		moveEvents(eventsByID[eventId], dayDelta, minuteDelta, allDay);
		trigger(
			'eventDrop',
			e,
			event,
			dayDelta,
			minuteDelta,
			allDay,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				moveEvents(eventsByID[eventId], -dayDelta, -minuteDelta, oldAllDay);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}
	
	
	function eventResize(e, event, dayDelta, minuteDelta, ev, ui) {
		var eventId = event._id;
		elongateEvents(eventsByID[eventId], dayDelta, minuteDelta);
		trigger(
			'eventResize',
			e,
			event,
			dayDelta,
			minuteDelta,
			function() {
				// TODO: investigate cases where this inverse technique might not work
				elongateEvents(eventsByID[eventId], -dayDelta, -minuteDelta);
				reportEventChange(eventId);
			},
			ev,
			ui
		);
		reportEventChange(eventId);
	}
	
	
	
	/* Event Modification Math
	---------------------------------------------------------------------------------*/
	
	
	function moveEvents(events, dayDelta, minuteDelta, allDay) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			if (allDay !== undefined) {
				e.allDay = allDay;
			}
			addMinutes(addDays(e.start, dayDelta, true), minuteDelta);
			if (e.end) {
				e.end = addMinutes(addDays(e.end, dayDelta, true), minuteDelta);
			}
			normalizeEvent(e, options);
		}
	}
	
	
	function elongateEvents(events, dayDelta, minuteDelta) {
		minuteDelta = minuteDelta || 0;
		for (var e, len=events.length, i=0; i<len; i++) {
			e = events[i];
			e.end = addMinutes(addDays(eventEnd(e), dayDelta, true), minuteDelta);
			normalizeEvent(e, options);
		}
	}



	// ====================================================================================================
	// Utilities for day "cells"
	// ====================================================================================================
	// The "basic" views are completely made up of day cells.
	// The "agenda" views have day cells at the top "all day" slot.
	// This was the obvious common place to put these utilities, but they should be abstracted out into
	// a more meaningful class (like DayEventRenderer).
	// ====================================================================================================


	// For determining how a given "cell" translates into a "date":
	//
	// 1. Convert the "cell" (row and column) into a "cell offset" (the # of the cell, cronologically from the first).
	//    Keep in mind that column indices are inverted with isRTL. This is taken into account.
	//
	// 2. Convert the "cell offset" to a "day offset" (the # of days since the first visible day in the view).
	//
	// 3. Convert the "day offset" into a "date" (a JavaScript Date object).
	//
	// The reverse transformation happens when transforming a date into a cell.


	// exports
	t.isHiddenDay = isHiddenDay;
	t.skipHiddenDays = skipHiddenDays;
	t.getCellsPerWeek = getCellsPerWeek;
	t.dateToCell = dateToCell;
	t.dateToDayOffset = dateToDayOffset;
	t.dayOffsetToCellOffset = dayOffsetToCellOffset;
	t.cellOffsetToCell = cellOffsetToCell;
	t.cellToDate = cellToDate;
	t.cellToCellOffset = cellToCellOffset;
	t.cellOffsetToDayOffset = cellOffsetToDayOffset;
	t.dayOffsetToDate = dayOffsetToDate;
	t.rangeToSegments = rangeToSegments;


	// internals
	var hiddenDays = opt('hiddenDays') || []; // array of day-of-week indices that are hidden
	var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
	var cellsPerWeek;
	var dayToCellMap = []; // hash from dayIndex -> cellIndex, for one week
	var cellToDayMap = []; // hash from cellIndex -> dayIndex, for one week
	var isRTL = opt('isRTL');


	// initialize important internal variables
	(function() {

		if (opt('weekends') === false) {
			hiddenDays.push(0, 6); // 0=sunday, 6=saturday
		}

		// Loop through a hypothetical week and determine which
		// days-of-week are hidden. Record in both hashes (one is the reverse of the other).
		for (var dayIndex=0, cellIndex=0; dayIndex<7; dayIndex++) {
			dayToCellMap[dayIndex] = cellIndex;
			isHiddenDayHash[dayIndex] = $.inArray(dayIndex, hiddenDays) != -1;
			if (!isHiddenDayHash[dayIndex]) {
				cellToDayMap[cellIndex] = dayIndex;
				cellIndex++;
			}
		}

		cellsPerWeek = cellIndex;
		if (!cellsPerWeek) {
			throw 'invalid hiddenDays'; // all days were hidden? bad.
		}

	})();


	// Is the current day hidden?
	// `day` is a day-of-week index (0-6), or a Date object
	function isHiddenDay(day) {
		if (typeof day == 'object') {
			day = day.getDay();
		}
		return isHiddenDayHash[day];
	}


	function getCellsPerWeek() {
		return cellsPerWeek;
	}


	// Keep incrementing the current day until it is no longer a hidden day.
	// If the initial value of `date` is not a hidden day, don't do anything.
	// Pass `isExclusive` as `true` if you are dealing with an end date.
	// `inc` defaults to `1` (increment one day forward each time)
	function skipHiddenDays(date, inc, isExclusive) {
		inc = inc || 1;
		while (
			isHiddenDayHash[ ( date.getDay() + (isExclusive ? inc : 0) + 7 ) % 7 ]
		) {
			addDays(date, inc);
		}
	}


	//
	// TRANSFORMATIONS: cell -> cell offset -> day offset -> date
	//

	// cell -> date (combines all transformations)
	// Possible arguments:
	// - row, col
	// - { row:#, col: # }
	function cellToDate() {
		var cellOffset = cellToCellOffset.apply(null, arguments);
		var dayOffset = cellOffsetToDayOffset(cellOffset);
		var date = dayOffsetToDate(dayOffset);
                clearTime(date);
		return date;
	}

	// cell -> cell offset
	// Possible arguments:
	// - row, col
	// - { row:#, col:# }
	function cellToCellOffset(row, col) {
		var colCnt = t.getColCnt();

		// rtl variables. wish we could pre-populate these. but where?
		var dis = isRTL ? -1 : 1;
		var dit = isRTL ? colCnt - 1 : 0;

		if (typeof row == 'object') {
			col = row.col;
			row = row.row;
		}
		var cellOffset = row * colCnt + (col * dis + dit); // column, adjusted for RTL (dis & dit)

		return cellOffset;
	}

	// cell offset -> day offset
	function cellOffsetToDayOffset(cellOffset) {
		var day0 = t.visStart.getUTCDay(); // first date's day of week. SAH - switch to use UTC day.
		cellOffset += dayToCellMap[day0]; // normlize cellOffset to beginning-of-week
		return Math.floor(cellOffset / cellsPerWeek) * 7 // # of days from full weeks
			+ cellToDayMap[ // # of days from partial last week
				(cellOffset % cellsPerWeek + cellsPerWeek) % cellsPerWeek // crazy math to handle negative cellOffsets
			]
			- day0; // adjustment for beginning-of-week normalization
	}

	// day offset -> date (JavaScript Date object)
	function dayOffsetToDate(dayOffset) {
		var date = cloneDate(t.visStart);
		addDays(date, dayOffset);
		return date;
	}


	//
	// TRANSFORMATIONS: date -> day offset -> cell offset -> cell
	//

	// date -> cell (combines all transformations)
	function dateToCell(date) {
		var dayOffset = dateToDayOffset(date);
		var cellOffset = dayOffsetToCellOffset(dayOffset);
		var cell = cellOffsetToCell(cellOffset);
		return cell;
	}

	// date -> day offset
	function dateToDayOffset(date) {
		return dayDiff(date, t.visStart);
	}

	// day offset -> cell offset
	function dayOffsetToCellOffset(dayOffset) {
		var day0 = t.visStart.getDay(); // first date's day of week
		dayOffset += day0; // normalize dayOffset to beginning-of-week
		return Math.floor(dayOffset / 7) * cellsPerWeek // # of cells from full weeks
			+ dayToCellMap[ // # of cells from partial last week
				(dayOffset % 7 + 7) % 7 // crazy math to handle negative dayOffsets
			]
			- dayToCellMap[day0]; // adjustment for beginning-of-week normalization
	}

	// cell offset -> cell (object with row & col keys)
	function cellOffsetToCell(cellOffset) {
		var colCnt = t.getColCnt();

		// rtl variables. wish we could pre-populate these. but where?
		var dis = isRTL ? -1 : 1;
		var dit = isRTL ? colCnt - 1 : 0;

		var row = Math.floor(cellOffset / colCnt);
		var col = ((cellOffset % colCnt + colCnt) % colCnt) * dis + dit; // column, adjusted for RTL (dis & dit)
		return {
			row: row,
			col: col
		};
	}


	//
	// Converts a date range into an array of segment objects.
	// "Segments" are horizontal stretches of time, sliced up by row.
	// A segment object has the following properties:
	// - row
	// - cols
	// - isStart
	// - isEnd
	//
	function rangeToSegments(startDate, endDate) {
		var rowCnt = t.getRowCnt();
		var colCnt = t.getColCnt();
		var segments = []; // array of segments to return

		// day offset for given date range
		var rangeDayOffsetStart = dateToDayOffset(startDate);
		var rangeDayOffsetEnd = dateToDayOffset(endDate); // exclusive

		// first and last cell offset for the given date range
		// "last" implies inclusivity
		var rangeCellOffsetFirst = dayOffsetToCellOffset(rangeDayOffsetStart);
		var rangeCellOffsetLast = dayOffsetToCellOffset(rangeDayOffsetEnd) - 1;

		// loop through all the rows in the view
		for (var row=0; row<rowCnt; row++) {

			// first and last cell offset for the row
			var rowCellOffsetFirst = row * colCnt;
			var rowCellOffsetLast = rowCellOffsetFirst + colCnt - 1;

			// get the segment's cell offsets by constraining the range's cell offsets to the bounds of the row
			var segmentCellOffsetFirst = Math.max(rangeCellOffsetFirst, rowCellOffsetFirst);
			var segmentCellOffsetLast = Math.min(rangeCellOffsetLast, rowCellOffsetLast);

			// make sure segment's offsets are valid and in view
			if (segmentCellOffsetFirst <= segmentCellOffsetLast) {

				// translate to cells
				var segmentCellFirst = cellOffsetToCell(segmentCellOffsetFirst);
				var segmentCellLast = cellOffsetToCell(segmentCellOffsetLast);

				// view might be RTL, so order by leftmost column
				var cols = [ segmentCellFirst.col, segmentCellLast.col ].sort();

				// Determine if segment's first/last cell is the beginning/end of the date range.
				// We need to compare "day offset" because "cell offsets" are often ambiguous and
				// can translate to multiple days, and an edge case reveals itself when we the
				// range's first cell is hidden (we don't want isStart to be true).
				var isStart = cellOffsetToDayOffset(segmentCellOffsetFirst) == rangeDayOffsetStart;
				var isEnd = cellOffsetToDayOffset(segmentCellOffsetLast) + 1 == rangeDayOffsetEnd; // +1 for comparing exclusively

				segments.push({
					row: row,
					leftCol: cols[0],
					rightCol: cols[1],
					isStart: isStart,
					isEnd: isEnd
				});
			}
		}

		return segments;
	}
	

}

;;

function DayEventRenderer() {
	var t = this;

	
	// exports
	t.renderDayEvents = renderDayEvents;
	t.draggableDayEvent = draggableDayEvent; // made public so that subclasses can override
	t.resizableDayEvent = resizableDayEvent; // "
	
	
	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var isEventDraggable = t.isEventDraggable;
	var isEventResizable = t.isEventResizable;
	var eventEnd = t.eventEnd;
	var reportEventElement = t.reportEventElement;
	var eventElementHandlers = t.eventElementHandlers;
	var showEvents = t.showEvents;
	var hideEvents = t.hideEvents;
	var eventDrop = t.eventDrop;
	var eventResize = t.eventResize;
	var getRowCnt = t.getRowCnt;
	var getColCnt = t.getColCnt;
	var getColWidth = t.getColWidth;
	var allDayRow = t.allDayRow; // TODO: rename
	var colLeft = t.colLeft;
	var colRight = t.colRight;
	var colContentLeft = t.colContentLeft;
	var colContentRight = t.colContentRight;
	var dateToCell = t.dateToCell;
	var getDaySegmentContainer = t.getDaySegmentContainer;
	var formatDates = t.calendar.formatDates;
	var renderDayOverlay = t.renderDayOverlay;
	var clearOverlays = t.clearOverlays;
	var clearSelection = t.clearSelection;
	var getHoverListener = t.getHoverListener;
	var rangeToSegments = t.rangeToSegments;
	var cellToDate = t.cellToDate;
	var cellToCellOffset = t.cellToCellOffset;
	var cellOffsetToDayOffset = t.cellOffsetToDayOffset;
	var dateToDayOffset = t.dateToDayOffset;
	var dayOffsetToCellOffset = t.dayOffsetToCellOffset;


	// Render `events` onto the calendar, attach mouse event handlers, and call the `eventAfterRender` callback for each.
	// Mouse event will be lazily applied, except if the event has an ID of `modifiedEventId`.
	// Can only be called when the event container is empty (because it wipes out all innerHTML).
	function renderDayEvents(events, modifiedEventId) {

		// do the actual rendering. Receive the intermediate "segment" data structures.
		var segments = _renderDayEvents(
			events,
			false, // don't append event elements
			true // set the heights of the rows
		);

		// report the elements to the View, for general drag/resize utilities
		segmentElementEach(segments, function(segment, element) {
			reportEventElement(segment.event, element);
		});

		// attach mouse handlers
		attachHandlers(segments, modifiedEventId);

		// call `eventAfterRender` callback for each event
		segmentElementEach(segments, function(segment, element) {
			trigger('eventAfterRender', segment.event, segment.event, element);
		});
	}


	// Render an event on the calendar, but don't report them anywhere, and don't attach mouse handlers.
	// Append this event element to the event container, which might already be populated with events.
	// If an event's segment will have row equal to `adjustRow`, then explicitly set its top coordinate to `adjustTop`.
	// This hack is used to maintain continuity when user is manually resizing an event.
	// Returns an array of DOM elements for the event.
	function renderTempDayEvent(event, adjustRow, adjustTop) {

		// actually render the event. `true` for appending element to container.
		// Recieve the intermediate "segment" data structures.
		var segments = _renderDayEvents(
			[ event ],
			true, // append event elements
			false // don't set the heights of the rows
		);

		var elements = [];

		// Adjust certain elements' top coordinates
		segmentElementEach(segments, function(segment, element) {
			if (segment.row === adjustRow) {
				element.css('top', adjustTop);
			}
			elements.push(element[0]); // accumulate DOM nodes
		});

		return elements;
	}


	// Render events onto the calendar. Only responsible for the VISUAL aspect.
	// Not responsible for attaching handlers or calling callbacks.
	// Set `doAppend` to `true` for rendering elements without clearing the existing container.
	// Set `doRowHeights` to allow setting the height of each row, to compensate for vertical event overflow.
	function _renderDayEvents(events, doAppend, doRowHeights) {

		// where the DOM nodes will eventually end up
		var finalContainer = getDaySegmentContainer();

		// the container where the initial HTML will be rendered.
		// If `doAppend`==true, uses a temporary container.
		var renderContainer = doAppend ? $("<div/>") : finalContainer;

		var segments = buildSegments(events);
		var html;
		var elements;

		// calculate the desired `left` and `width` properties on each segment object
		calculateHorizontals(segments);

		// build the HTML string. relies on `left` property
		html = buildHTML(segments);

		// render the HTML. innerHTML is considerably faster than jQuery's .html()
		renderContainer[0].innerHTML = html;

		// retrieve the individual elements
		elements = renderContainer.children();

		// if we were appending, and thus using a temporary container,
		// re-attach elements to the real container.
		if (doAppend) {
			finalContainer.append(elements);
		}

		// assigns each element to `segment.event`, after filtering them through user callbacks
		resolveElements(segments, elements);

		// Calculate the left and right padding+margin for each element.
		// We need this for setting each element's desired outer width, because of the W3C box model.
		// It's important we do this in a separate pass from acually setting the width on the DOM elements
		// because alternating reading/writing dimensions causes reflow for every iteration.
		segmentElementEach(segments, function(segment, element) {
			segment.hsides = hsides(element, true); // include margins = `true`
		});

		// Set the width of each element
		segmentElementEach(segments, function(segment, element) {
			element.width(
				Math.max(0, segment.outerWidth - segment.hsides)
			);
		});

		// Grab each element's outerHeight (setVerticals uses this).
		// To get an accurate reading, it's important to have each element's width explicitly set already.
		segmentElementEach(segments, function(segment, element) {
			segment.outerHeight = element.outerHeight(true); // include margins = `true`
		});

		// Set the top coordinate on each element (requires segment.outerHeight)
		setVerticals(segments, doRowHeights);

		return segments;
	}


	// Generate an array of "segments" for all events.
	function buildSegments(events) {
		var segments = [];
		for (var i=0; i<events.length; i++) {
			var eventSegments = buildSegmentsForEvent(events[i]);
			segments.push.apply(segments, eventSegments); // append an array to an array
		}
		return segments;
	}


	// Generate an array of segments for a single event.
	// A "segment" is the same data structure that View.rangeToSegments produces,
	// with the addition of the `event` property being set to reference the original event.
	function buildSegmentsForEvent(event) {
		var startDate = event.start;
		var endDate = exclEndDay(event);
		var segments = rangeToSegments(startDate, endDate);
		for (var i=0; i<segments.length; i++) {
			segments[i].event = event;
		}
		return segments;
	}


	// Sets the `left` and `outerWidth` property of each segment.
	// These values are the desired dimensions for the eventual DOM elements.
	function calculateHorizontals(segments) {
		var isRTL = opt('isRTL');
		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];

			// Determine functions used for calulating the elements left/right coordinates,
			// depending on whether the view is RTL or not.
			// NOTE:
			// colLeft/colRight returns the coordinate butting up the edge of the cell.
			// colContentLeft/colContentRight is indented a little bit from the edge.
			var leftFunc = (isRTL ? segment.isEnd : segment.isStart) ? colContentLeft : colLeft;
			var rightFunc = (isRTL ? segment.isStart : segment.isEnd) ? colContentRight : colRight;

			var left = leftFunc(segment.leftCol);
			var right = rightFunc(segment.rightCol);
			segment.left = left;
			segment.outerWidth = right - left;
		}
	}


	// Build a concatenated HTML string for an array of segments
	function buildHTML(segments) {
		var html = '';
		for (var i=0; i<segments.length; i++) {
			html += buildHTMLForSegment(segments[i]);
		}
		return html;
	}


	// Build an HTML string for a single segment.
	// Relies on the following properties:
	// - `segment.event` (from `buildSegmentsForEvent`)
	// - `segment.left` (from `calculateHorizontals`)
	function buildHTMLForSegment(segment) {
		var html = '';
		var isRTL = opt('isRTL');
		var event = segment.event;
		var url = event.url;

		// generate the list of CSS classNames
		var classNames = [ 'fc-event', 'fc-event-hori' ];
		if (isEventDraggable(event)) {
			classNames.push('fc-event-draggable');
		}
		if (segment.isStart) {
			classNames.push('fc-event-start');
		}
		if (segment.isEnd) {
			classNames.push('fc-event-end');
		}
		// use the event's configured classNames
		// guaranteed to be an array via `normalizeEvent`
		classNames = classNames.concat(event.className);
		if (event.source) {
			// use the event's source's classNames, if specified
			classNames = classNames.concat(event.source.className || []);
		}

		// generate a semicolon delimited CSS string for any of the "skin" properties
		// of the event object (`backgroundColor`, `borderColor` and such)
		var skinCss = getSkinCss(event, opt);

		if (url) {
			html += "<a href='" + htmlEscape(url) + "'";
		}else{
			html += "<div";
		}
		html +=
			" class='" + classNames.join(' ') + "'" +
			" style=" +
				"'" +
				"position:absolute;" +
				"left:" + segment.left + "px;" +
				skinCss +
				"'" +
			">" +
			"<div class='fc-event-inner'>";
		if (!event.allDay && segment.isStart) {
			html +=
				"<span class='fc-event-time'>" +
				htmlEscape(
					formatDates(event.start, event.end, opt('timeFormat'))
				) +
				"</span>";
		}
		html +=
			"<span class='fc-event-title'>" +
			htmlEscape(event.title || '') +
			"</span>" +
			"</div>";
		if (segment.isEnd && isEventResizable(event)) {
			html +=
				"<div class='ui-resizable-handle ui-resizable-" + (isRTL ? 'w' : 'e') + "'>" +
				"&nbsp;&nbsp;&nbsp;" + // makes hit area a lot better for IE6/7
				"</div>";
		}
		html += "</" + (url ? "a" : "div") + ">";

		// TODO:
		// When these elements are initially rendered, they will be briefly visibile on the screen,
		// even though their widths/heights are not set.
		// SOLUTION: initially set them as visibility:hidden ?

		return html;
	}


	// Associate each segment (an object) with an element (a jQuery object),
	// by setting each `segment.element`.
	// Run each element through the `eventRender` filter, which allows developers to
	// modify an existing element, supply a new one, or cancel rendering.
	function resolveElements(segments, elements) {
		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];
			var event = segment.event;
			var element = elements.eq(i);

			// call the trigger with the original element
			var triggerRes = trigger('eventRender', event, event, element);

			if (triggerRes === false) {
				// if `false`, remove the event from the DOM and don't assign it to `segment.event`
				element.remove();
			}
			else {
				if (triggerRes && triggerRes !== true) {
					// the trigger returned a new element, but not `true` (which means keep the existing element)

					// re-assign the important CSS dimension properties that were already assigned in `buildHTMLForSegment`
					triggerRes = $(triggerRes)
						.css({
							position: 'absolute',
							left: segment.left
						});

					element.replaceWith(triggerRes);
					element = triggerRes;
				}

				segment.element = element;
			}
		}
	}



	/* Top-coordinate Methods
	-------------------------------------------------------------------------------------------------*/


	// Sets the "top" CSS property for each element.
	// If `doRowHeights` is `true`, also sets each row's first cell to an explicit height,
	// so that if elements vertically overflow, the cell expands vertically to compensate.
	function setVerticals(segments, doRowHeights) {
		var rowContentHeights = calculateVerticals(segments); // also sets segment.top
		var rowContentElements = getRowContentElements(); // returns 1 inner div per row
		var rowContentTops = [];

		// Set each row's height by setting height of first inner div
		if (doRowHeights) {
			for (var i=0; i<rowContentElements.length; i++) {
				rowContentElements[i].height(rowContentHeights[i]);
			}
		}

		// Get each row's top, relative to the views's origin.
		// Important to do this after setting each row's height.
		for (var i=0; i<rowContentElements.length; i++) {
			rowContentTops.push(
				rowContentElements[i].position().top
			);
		}

		// Set each segment element's CSS "top" property.
		// Each segment object has a "top" property, which is relative to the row's top, but...
		segmentElementEach(segments, function(segment, element) {
			element.css(
				'top',
				rowContentTops[segment.row] + segment.top // ...now, relative to views's origin
			);
		});
	}


	// Calculate the "top" coordinate for each segment, relative to the "top" of the row.
	// Also, return an array that contains the "content" height for each row
	// (the height displaced by the vertically stacked events in the row).
	// Requires segments to have their `outerHeight` property already set.
	function calculateVerticals(segments) {
		var rowCnt = getRowCnt();
		var colCnt = getColCnt();
		var rowContentHeights = []; // content height for each row
		var segmentRows = buildSegmentRows(segments); // an array of segment arrays, one for each row

		for (var rowI=0; rowI<rowCnt; rowI++) {
			var segmentRow = segmentRows[rowI];

			// an array of running total heights for each column.
			// initialize with all zeros.
			var colHeights = [];
			for (var colI=0; colI<colCnt; colI++) {
				colHeights.push(0);
			}

			// loop through every segment
			for (var segmentI=0; segmentI<segmentRow.length; segmentI++) {
				var segment = segmentRow[segmentI];

				// find the segment's top coordinate by looking at the max height
				// of all the columns the segment will be in.
				segment.top = arrayMax(
					colHeights.slice(
						segment.leftCol,
						segment.rightCol + 1 // make exclusive for slice
					)
				);

				// adjust the columns to account for the segment's height
				for (var colI=segment.leftCol; colI<=segment.rightCol; colI++) {
					colHeights[colI] = segment.top + segment.outerHeight;
				}
			}

			// the tallest column in the row should be the "content height"
			rowContentHeights.push(arrayMax(colHeights));
		}

		return rowContentHeights;
	}


	// Build an array of segment arrays, each representing the segments that will
	// be in a row of the grid, sorted by which event should be closest to the top.
	function buildSegmentRows(segments) {
		var rowCnt = getRowCnt();
		var segmentRows = [];
		var segmentI;
		var segment;
		var rowI;

		// group segments by row
		for (segmentI=0; segmentI<segments.length; segmentI++) {
			segment = segments[segmentI];
			rowI = segment.row;
			if (segment.element) { // was rendered?
				if (segmentRows[rowI]) {
					// already other segments. append to array
					segmentRows[rowI].push(segment);
				}
				else {
					// first segment in row. create new array
					segmentRows[rowI] = [ segment ];
				}
			}
		}

		// sort each row
		for (rowI=0; rowI<rowCnt; rowI++) {
			segmentRows[rowI] = sortSegmentRow(
				segmentRows[rowI] || [] // guarantee an array, even if no segments
			);
		}

		return segmentRows;
	}


	// Sort an array of segments according to which segment should appear closest to the top
	function sortSegmentRow(segments) {
		var sortedSegments = [];

		// build the subrow array
		var subrows = buildSegmentSubrows(segments);

		// flatten it
		for (var i=0; i<subrows.length; i++) {
			sortedSegments.push.apply(sortedSegments, subrows[i]); // append an array to an array
		}

		return sortedSegments;
	}


	// Take an array of segments, which are all assumed to be in the same row,
	// and sort into subrows.
	function buildSegmentSubrows(segments) {

		// Give preference to elements with certain criteria, so they have
		// a chance to be closer to the top.
		segments.sort(compareDaySegments);

		var subrows = [];
		for (var i=0; i<segments.length; i++) {
			var segment = segments[i];

			// loop through subrows, starting with the topmost, until the segment
			// doesn't collide with other segments.
			for (var j=0; j<subrows.length; j++) {
				if (!isDaySegmentCollision(segment, subrows[j])) {
					break;
				}
			}
			// `j` now holds the desired subrow index
			if (subrows[j]) {
				subrows[j].push(segment);
			}
			else {
				subrows[j] = [ segment ];
			}
		}

		return subrows;
	}


	// Return an array of jQuery objects for the placeholder content containers of each row.
	// The content containers don't actually contain anything, but their dimensions should match
	// the events that are overlaid on top.
	function getRowContentElements() {
		var i;
		var rowCnt = getRowCnt();
		var rowDivs = [];
		for (i=0; i<rowCnt; i++) {
			rowDivs[i] = allDayRow(i)
				.find('div.fc-day-content > div');
		}
		return rowDivs;
	}



	/* Mouse Handlers
	---------------------------------------------------------------------------------------------------*/
	// TODO: better documentation!


	function attachHandlers(segments, modifiedEventId) {
		var segmentContainer = getDaySegmentContainer();

		segmentElementEach(segments, function(segment, element, i) {
			var event = segment.event;
			if (event._id === modifiedEventId) {
				bindDaySeg(event, element, segment);
			}else{
				element[0]._fci = i; // for lazySegBind
			}
		});

		lazySegBind(segmentContainer, segments, bindDaySeg);
	}


	function bindDaySeg(event, eventElement, segment) {

		if (isEventDraggable(event)) {
			t.draggableDayEvent(event, eventElement, segment); // use `t` so subclasses can override
		}

		if (
			segment.isEnd && // only allow resizing on the final segment for an event
			isEventResizable(event)
		) {
			t.resizableDayEvent(event, eventElement, segment); // use `t` so subclasses can override
		}

		// attach all other handlers.
		// needs to be after, because resizableDayEvent might stopImmediatePropagation on click
		eventElementHandlers(event, eventElement);
	}

	
	function draggableDayEvent(event, eventElement) {
		var hoverListener = getHoverListener();
		var dayDelta;
		eventElement.draggable({
			delay: 50,
			opacity: opt('dragOpacity'),
			revertDuration: opt('dragRevertDuration'),
			start: function(ev, ui) {
				trigger('eventDragStart', eventElement, event, ev, ui);
				hideEvents(event, eventElement);
				hoverListener.start(function(cell, origCell, rowDelta, colDelta) {
					eventElement.draggable('option', 'revert', !cell || !rowDelta && !colDelta);
					clearOverlays();
					if (cell) {
						var origDate = cellToDate(origCell);
						var date = cellToDate(cell);
						dayDelta = dayDiff(date, origDate);
						renderDayOverlay(
							addDays(cloneDate(event.start), dayDelta),
							addDays(exclEndDay(event), dayDelta)
						);
					}else{
						dayDelta = 0;
					}
				}, ev, 'drag');
			},
			stop: function(ev, ui) {
				hoverListener.stop();
				clearOverlays();
				trigger('eventDragStop', eventElement, event, ev, ui);
				if (dayDelta) {
					eventDrop(this, event, dayDelta, 0, event.allDay, ev, ui);
				}else{
					eventElement.css('filter', ''); // clear IE opacity side-effects
					showEvents(event, eventElement);
				}
			}
		});
	}

	
	function resizableDayEvent(event, element, segment) {
		var isRTL = opt('isRTL');
		var direction = isRTL ? 'w' : 'e';
		var handle = element.find('.ui-resizable-' + direction); // TODO: stop using this class because we aren't using jqui for this
		var isResizing = false;
		
		// TODO: look into using jquery-ui mouse widget for this stuff
		disableTextSelection(element); // prevent native <a> selection for IE
		element
			.mousedown(function(ev) { // prevent native <a> selection for others
				ev.preventDefault();
			})
			.click(function(ev) {
				if (isResizing) {
					ev.preventDefault(); // prevent link from being visited (only method that worked in IE6)
					ev.stopImmediatePropagation(); // prevent fullcalendar eventClick handler from being called
					                               // (eventElementHandlers needs to be bound after resizableDayEvent)
				}
			});
		
		handle.mousedown(function(ev) {
			if (ev.which != 1) {
				return; // needs to be left mouse button
			}
			isResizing = true;
			var hoverListener = getHoverListener();
			var rowCnt = getRowCnt();
			var colCnt = getColCnt();
			var elementTop = element.css('top');
			var dayDelta;
			var helpers;
			var eventCopy = $.extend({}, event);
			var minCellOffset = dayOffsetToCellOffset( dateToDayOffset(event.start) );
			clearSelection();
			$('body')
				.css('cursor', direction + '-resize')
				.one('mouseup', mouseup);
			trigger('eventResizeStart', this, event, ev);
			hoverListener.start(function(cell, origCell) {
				if (cell) {

					var origCellOffset = cellToCellOffset(origCell);
					var cellOffset = cellToCellOffset(cell);

					// don't let resizing move earlier than start date cell
					cellOffset = Math.max(cellOffset, minCellOffset);

					dayDelta =
						cellOffsetToDayOffset(cellOffset) -
						cellOffsetToDayOffset(origCellOffset);

					if (dayDelta) {
						eventCopy.end = addDays(eventEnd(event), dayDelta, true);
						var oldHelpers = helpers;

						helpers = renderTempDayEvent(eventCopy, segment.row, elementTop);
						helpers = $(helpers); // turn array into a jQuery object

						helpers.find('*').css('cursor', direction + '-resize');
						if (oldHelpers) {
							oldHelpers.remove();
						}

						hideEvents(event);
					}
					else {
						if (helpers) {
							showEvents(event);
							helpers.remove();
							helpers = null;
						}
					}
					clearOverlays();
					renderDayOverlay( // coordinate grid already rebuilt with hoverListener.start()
						event.start,
						addDays( exclEndDay(event), dayDelta )
						// TODO: instead of calling renderDayOverlay() with dates,
						// call _renderDayOverlay (or whatever) with cell offsets.
					);
				}
			}, ev);
			
			function mouseup(ev) {
				trigger('eventResizeStop', this, event, ev);
				$('body').css('cursor', '');
				hoverListener.stop();
				clearOverlays();
				if (dayDelta) {
					eventResize(this, event, dayDelta, 0, ev);
					// event redraw will clear helpers
				}
				// otherwise, the drag handler already restored the old events
				
				setTimeout(function() { // make this happen after the element's click event
					isResizing = false;
				},0);
			}
		});
	}
	

}



/* Generalized Segment Utilities
-------------------------------------------------------------------------------------------------*/


function isDaySegmentCollision(segment, otherSegments) {
	for (var i=0; i<otherSegments.length; i++) {
		var otherSegment = otherSegments[i];
		if (
			otherSegment.leftCol <= segment.rightCol &&
			otherSegment.rightCol >= segment.leftCol
		) {
			return true;
		}
	}
	return false;
}


function segmentElementEach(segments, callback) { // TODO: use in AgendaView?
	for (var i=0; i<segments.length; i++) {
		var segment = segments[i];
		var element = segment.element;
		if (element) {
			callback(segment, element, i);
		}
	}
}


// A cmp function for determining which segments should appear higher up
function compareDaySegments(a, b) {
	return (b.rightCol - b.leftCol) - (a.rightCol - a.leftCol) || // put wider events first
		b.event.allDay - a.event.allDay || // if tie, put all-day events first (booleans cast to 0/1)
		a.event.start - b.event.start || // if a tie, sort by event start date
		(a.event.title || '').localeCompare(b.event.title) // if a tie, sort by event title
}


;;

//BUG: unselect needs to be triggered when events are dragged+dropped

function SelectionManager() {
	var t = this;
	
	
	// exports
	t.select = select;
	t.unselect = unselect;
	t.reportSelection = reportSelection;
	t.daySelectionMousedown = daySelectionMousedown;
	
	
	// imports
	var opt = t.opt;
	var trigger = t.trigger;
	var defaultSelectionEnd = t.defaultSelectionEnd;
	var renderSelection = t.renderSelection;
	var clearSelection = t.clearSelection;
	
	
	// locals
	var selected = false;



	// unselectAuto
	if (opt('selectable') && opt('unselectAuto')) {
		$(document).mousedown(function(ev) {
			var ignore = opt('unselectCancel');
			if (ignore) {
				if ($(ev.target).parents(ignore).length) { // could be optimized to stop after first match
					return;
				}
			}
			unselect(ev);
		});
	}
	

	function select(startDate, endDate, allDay) {
		unselect();
		if (!endDate) {
			endDate = defaultSelectionEnd(startDate, allDay);
		}
		renderSelection(startDate, endDate, allDay);
		reportSelection(startDate, endDate, allDay);
	}
	
	
	function unselect(ev) {
		if (selected) {
			selected = false;
			clearSelection();
			trigger('unselect', null, ev);
		}
	}
	
	
	function reportSelection(startDate, endDate, allDay, ev) {
		selected = true;
		trigger('select', null, startDate, endDate, allDay, ev);
	}
	
	
	function daySelectionMousedown(ev) { // not really a generic manager method, oh well
		var cellToDate = t.cellToDate;
		var getIsCellAllDay = t.getIsCellAllDay;
		var hoverListener = t.getHoverListener();
		var reportDayClick = t.reportDayClick; // this is hacky and sort of weird
		if (ev.which == 1 && opt('selectable')) { // which==1 means left mouse button
			unselect(ev);
			var _mousedownElement = this;
			var dates;
			hoverListener.start(function(cell, origCell) { // TODO: maybe put cellToDate/getIsCellAllDay info in cell
				clearSelection();
				if (cell && getIsCellAllDay(cell)) {
					dates = [ cellToDate(origCell), cellToDate(cell) ].sort(dateCompare);
					renderSelection(dates[0], dates[1], true);
				}else{
					dates = null;
				}
			}, ev);
			$(document).one('mouseup', function(ev) {
				hoverListener.stop();
				if (dates) {
					if (+dates[0] == +dates[1]) {
						reportDayClick(dates[0], true, ev);
					}
					reportSelection(dates[0], dates[1], true, ev);
				}
			});
		}
	}


}

;;
 
function OverlayManager() {
	var t = this;
	
	
	// exports
	t.renderOverlay = renderOverlay;
	t.clearOverlays = clearOverlays;
	
	
	// locals
	var usedOverlays = [];
	var unusedOverlays = [];
	
	
	function renderOverlay(rect, parent) {
		var e = unusedOverlays.shift();
		if (!e) {
			e = $("<div class='fc-cell-overlay' style='position:absolute;z-index:3'/>");
		}
		if (e[0].parentNode != parent[0]) {
			e.appendTo(parent);
		}
		usedOverlays.push(e.css(rect).show());
		return e;
	}
	

	function clearOverlays() {
		var e;
		while (e = usedOverlays.shift()) {
			unusedOverlays.push(e.hide().unbind());
		}
	}


}

;;

function CoordinateGrid(buildFunc) {

	var t = this;
	var rows;
	var cols;
	
	
	t.build = function() {
		rows = [];
		cols = [];
		buildFunc(rows, cols);
	};
	
	
	t.cell = function(x, y) {
		var rowCnt = rows.length;
		var colCnt = cols.length;
		var i, r=-1, c=-1;
		for (i=0; i<rowCnt; i++) {
			if (y >= rows[i][0] && y < rows[i][1]) {
				r = i;
				break;
			}
		}
		for (i=0; i<colCnt; i++) {
			if (x >= cols[i][0] && x < cols[i][1]) {
				c = i;
				break;
			}
		}
		return (r>=0 && c>=0) ? { row:r, col:c } : null;
	};
	
	
	t.rect = function(row0, col0, row1, col1, originElement) { // row1,col1 is inclusive
		var origin = originElement.offset();
		return {
			top: rows[row0][0] - origin.top,
			left: cols[col0][0] - origin.left,
			width: cols[col1][1] - cols[col0][0],
			height: rows[row1][1] - rows[row0][0]
		};
	};

}

;;

function HoverListener(coordinateGrid) {


	var t = this;
	var bindType;
	var change;
	var firstCell;
	var cell;
	
	
	t.start = function(_change, ev, _bindType) {
		change = _change;
		firstCell = cell = null;
		coordinateGrid.build();
		mouse(ev);
		bindType = _bindType || 'mousemove';
		$(document).bind(bindType, mouse);
	};
	
	
	function mouse(ev) {
		_fixUIEvent(ev); // see below
		var newCell = coordinateGrid.cell(ev.pageX, ev.pageY);
		if (!newCell != !cell || newCell && (newCell.row != cell.row || newCell.col != cell.col)) {
			if (newCell) {
				if (!firstCell) {
					firstCell = newCell;
				}
				change(newCell, firstCell, newCell.row-firstCell.row, newCell.col-firstCell.col);
			}else{
				change(newCell, firstCell);
			}
			cell = newCell;
		}
	}
	
	
	t.stop = function() {
		$(document).unbind(bindType, mouse);
		return cell;
	};
	
	
}



// this fix was only necessary for jQuery UI 1.8.16 (and jQuery 1.7 or 1.7.1)
// upgrading to jQuery UI 1.8.17 (and using either jQuery 1.7 or 1.7.1) fixed the problem
// but keep this in here for 1.8.16 users
// and maybe remove it down the line

function _fixUIEvent(event) { // for issue 1168
	if (event.pageX === undefined) {
		event.pageX = event.originalEvent.pageX;
		event.pageY = event.originalEvent.pageY;
	}
}
;;

function HorizontalPositionCache(getElement) {

	var t = this,
		elements = {},
		lefts = {},
		rights = {};
		
	function e(i) {
		return elements[i] = elements[i] || getElement(i);
	}
	
	t.left = function(i) {
		return lefts[i] = lefts[i] === undefined ? e(i).position().left : lefts[i];
	};
	
	t.right = function(i) {
		return rights[i] = rights[i] === undefined ? t.left(i) + e(i).width() : rights[i];
	};
	
	t.clear = function() {
		elements = {};
		lefts = {};
		rights = {};
	};
	
}

;;

})(jQuery);;// Spectrum Colorpicker v1.1.1
// https://github.com/bgrins/spectrum
// Author: Brian Grinstead
// License: MIT

(function (window, $, undefined) {
    var defaultOpts = {

        // Callbacks
        beforeShow: noop,
        move: noop,
        change: noop,
        show: noop,
        hide: noop,

        // Options
        color: false,
        flat: false,
        showInput: false,
        showButtons: true,
        clickoutFiresChange: false,
        showInitial: false,
        showPalette: false,
        showPaletteOnly: false,
        showSelectionPalette: true,
        localStorageKey: false,
        appendTo: "body",
        maxSelectionSize: 7,
        cancelText: "cancel",
        chooseText: "choose",
        preferredFormat: false,
        className: "",
        showAlpha: false,
        theme: "sp-light",
        palette: ['fff', '000'],
        selectionPalette: [],
        disabled: false
    },
    spectrums = [],
    IE = !!/msie/i.exec( window.navigator.userAgent ),
    rgbaSupport = (function() {
        function contains( str, substr ) {
            return !!~('' + str).indexOf(substr);
        }

        var elem = document.createElement('div');
        var style = elem.style;
        style.cssText = 'background-color:rgba(0,0,0,.5)';
        return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
    })(),
    replaceInput = [
        "<div class='sp-replacer'>",
            "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
            "<div class='sp-dd'>&#9660;</div>",
        "</div>"
    ].join(''),
    markup = (function () {

        // IE does not support gradients with multiple stops, so we need to simulate
        //  that for the rainbow slider with 8 divs that each have a single gradient
        var gradientFix = "";
        if (IE) {
            for (var i = 1; i <= 6; i++) {
                gradientFix += "<div class='sp-" + i + "'></div>";
            }
        }

        return [
            "<div class='sp-container sp-hidden'>",
                "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                "</div>",
                "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                        "<div class='sp-fill'></div>",
                        "<div class='sp-top-inner'>",
                            "<div class='sp-color'>",
                                "<div class='sp-sat'>",
                                    "<div class='sp-val'>",
                                        "<div class='sp-dragger'></div>",
                                    "</div>",
                                "</div>",
                            "</div>",
                            "<div class='sp-hue'>",
                                "<div class='sp-slider'></div>",
                                gradientFix,
                            "</div>",
                        "</div>",
                        "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
                    "</div>",
                    "<div class='sp-input-container sp-cf'>",
                        "<input class='sp-input' type='text' spellcheck='false'  />",
                    "</div>",
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                    "<div class='sp-button-container sp-cf'>",
                        "<a class='sp-cancel' href='#'></a>",
                        "<button class='sp-choose'></button>",
                    "</div>",
                "</div>",
            "</div>"
        ].join("");
    })();

    function paletteTemplate (p, color, className) {
        var html = [];
        for (var i = 0; i < p.length; i++) {
            var tiny = tinycolor(p[i]);
            var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
            c += (tinycolor.equals(color, p[i])) ? " sp-thumb-active" : "";

            var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
            html.push('<span title="' + tiny.toRgbString() + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
        }
        return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
    }

    function hideAll() {
        for (var i = 0; i < spectrums.length; i++) {
            if (spectrums[i]) {
                spectrums[i].hide();
            }
        }
    }

    function instanceOptions(o, callbackContext) {
        var opts = $.extend({}, defaultOpts, o);
        opts.callbacks = {
            'move': bind(opts.move, callbackContext),
            'change': bind(opts.change, callbackContext),
            'show': bind(opts.show, callbackContext),
            'hide': bind(opts.hide, callbackContext),
            'beforeShow': bind(opts.beforeShow, callbackContext)
        };

        return opts;
    }

    function spectrum(element, o) {

        var opts = instanceOptions(o, element),
            flat = opts.flat,
            showSelectionPalette = opts.showSelectionPalette,
            localStorageKey = opts.localStorageKey,
            theme = opts.theme,
            callbacks = opts.callbacks,
            resize = throttle(reflow, 10),
            visible = false,
            dragWidth = 0,
            dragHeight = 0,
            dragHelperHeight = 0,
            slideHeight = 0,
            slideWidth = 0,
            alphaWidth = 0,
            alphaSlideHelperWidth = 0,
            slideHelperHeight = 0,
            currentHue = 0,
            currentSaturation = 0,
            currentValue = 0,
            currentAlpha = 1,
            palette = opts.palette.slice(0),
            paletteArray = $.isArray(palette[0]) ? palette : [palette],
            selectionPalette = opts.selectionPalette.slice(0),
            maxSelectionSize = opts.maxSelectionSize,
            draggingClass = "sp-dragging",
            shiftMovementDirection = null;

        var doc = element.ownerDocument,
            body = doc.body,
            boundElement = $(element),
            disabled = false,
            container = $(markup, doc).addClass(theme),
            dragger = container.find(".sp-color"),
            dragHelper = container.find(".sp-dragger"),
            slider = container.find(".sp-hue"),
            slideHelper = container.find(".sp-slider"),
            alphaSliderInner = container.find(".sp-alpha-inner"),
            alphaSlider = container.find(".sp-alpha"),
            alphaSlideHelper = container.find(".sp-alpha-handle"),
            textInput = container.find(".sp-input"),
            paletteContainer = container.find(".sp-palette"),
            initialColorContainer = container.find(".sp-initial"),
            cancelButton = container.find(".sp-cancel"),
            chooseButton = container.find(".sp-choose"),
            isInput = boundElement.is("input"),
            shouldReplace = isInput && !flat,
            replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className) : $([]),
            offsetElement = (shouldReplace) ? replacer : boundElement,
            previewElement = replacer.find(".sp-preview-inner"),
            initialColor = opts.color || (isInput && boundElement.val()),
            colorOnShow = false,
            preferredFormat = opts.preferredFormat,
            currentPreferredFormat = preferredFormat,
            clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange;


        function applyOptions() {

            container.toggleClass("sp-flat", flat);
            container.toggleClass("sp-input-disabled", !opts.showInput);
            container.toggleClass("sp-alpha-enabled", opts.showAlpha);
            container.toggleClass("sp-buttons-disabled", !opts.showButtons);
            container.toggleClass("sp-palette-disabled", !opts.showPalette);
            container.toggleClass("sp-palette-only", opts.showPaletteOnly);
            container.toggleClass("sp-initial-disabled", !opts.showInitial);
            container.addClass(opts.className);

            reflow();
        }

        function initialize() {

            if (IE) {
                container.find("*:not(input)").attr("unselectable", "on");
            }

            applyOptions();

            if (shouldReplace) {
                boundElement.after(replacer).hide();
            }

            if (flat) {
                boundElement.after(container).hide();
            }
            else {

                var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
                if (appendTo.length !== 1) {
                    appendTo = $("body");
                }

                appendTo.append(container);
            }

            if (localStorageKey && window.localStorage) {

                // Migrate old palettes over to new format.  May want to remove this eventually.
                try {
                    var oldPalette = window.localStorage[localStorageKey].split(",#");
                    if (oldPalette.length > 1) {
                        delete window.localStorage[localStorageKey];
                        $.each(oldPalette, function(i, c) {
                             addColorToSelectionPalette(c);
                        });
                    }
                }
                catch(e) { }

                try {
                    selectionPalette = window.localStorage[localStorageKey].split(";");
                }
                catch (e) { }
            }

            offsetElement.bind("click.spectrum touchstart.spectrum", function (e) {
                if (!disabled) {
                    toggle();
                }

                e.stopPropagation();

                if (!$(e.target).is("input")) {
                    e.preventDefault();
                }
            });

            if(boundElement.is(":disabled") || (opts.disabled === true)) {
                disable();
            }

            // Prevent clicks from bubbling up to document.  This would cause it to be hidden.
            container.click(stopPropagation);

            // Handle user typed input
            textInput.change(setFromTextInput);
            textInput.bind("paste", function () {
                setTimeout(setFromTextInput, 1);
            });
            textInput.keydown(function (e) { if (e.keyCode == 13) { setFromTextInput(); } });

            cancelButton.text(opts.cancelText);
            cancelButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();
                hide("cancel");
            });

            chooseButton.text(opts.chooseText);
            chooseButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();

                if (isValid()) {
                    updateOriginalInput(true);
                    hide();
                }
            });

            draggable(alphaSlider, function (dragX, dragY, e) {
                currentAlpha = (dragX / alphaWidth);
                if (e.shiftKey) {
                    currentAlpha = Math.round(currentAlpha * 10) / 10;
                }

                move();
            });

            draggable(slider, function (dragX, dragY) {
                currentHue = parseFloat(dragY / slideHeight);
                move();
            }, dragStart, dragStop);

            draggable(dragger, function (dragX, dragY, e) {

                // shift+drag should snap the movement to either the x or y axis.
                if (!e.shiftKey) {
                    shiftMovementDirection = null;
                }
                else if (!shiftMovementDirection) {
                    var oldDragX = currentSaturation * dragWidth;
                    var oldDragY = dragHeight - (currentValue * dragHeight);
                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);

                    shiftMovementDirection = furtherFromX ? "x" : "y";
                }

                var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
                var setValue = !shiftMovementDirection || shiftMovementDirection === "y";

                if (setSaturation) {
                    currentSaturation = parseFloat(dragX / dragWidth);
                }
                if (setValue) {
                    currentValue = parseFloat((dragHeight - dragY) / dragHeight);
                }

                move();

            }, dragStart, dragStop);

            if (!!initialColor) {
                set(initialColor);

                // In case color was black - update the preview UI and set the format
                // since the set function will not run (default color is black).
                updateUI();
                currentPreferredFormat = preferredFormat || tinycolor(initialColor).format;

                addColorToSelectionPalette(initialColor);
            }
            else {
                updateUI();
            }

            if (flat) {
                show();
            }

            function palletElementClick(e) {
                if (e.data && e.data.ignore) {
                    set($(this).data("color"));
                    move();
                }
                else {
                    set($(this).data("color"));
                    updateOriginalInput(true);
                    move();
                    hide();
                }

                return false;
            }

            var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
            paletteContainer.delegate(".sp-thumb-el", paletteEvent, palletElementClick);
            initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, { ignore: true }, palletElementClick);
        }

        function addColorToSelectionPalette(color) {
            if (showSelectionPalette) {
                var colorRgb = tinycolor(color).toRgbString();
                if ($.inArray(colorRgb, selectionPalette) === -1) {
                    selectionPalette.push(colorRgb);
                    while(selectionPalette.length > maxSelectionSize) {
                        selectionPalette.shift();
                    }
                }

                if (localStorageKey && window.localStorage) {
                    try {
                        window.localStorage[localStorageKey] = selectionPalette.join(";");
                    }
                    catch(e) { }
                }
            }
        }

        function getUniqueSelectionPalette() {
            var unique = [];
            var p = selectionPalette;
            var paletteLookup = {};
            var rgb;

            if (opts.showPalette) {

                for (var i = 0; i < paletteArray.length; i++) {
                    for (var j = 0; j < paletteArray[i].length; j++) {
                        rgb = tinycolor(paletteArray[i][j]).toRgbString();
                        paletteLookup[rgb] = true;
                    }
                }

                for (i = 0; i < p.length; i++) {
                    rgb = tinycolor(p[i]).toRgbString();

                    if (!paletteLookup.hasOwnProperty(rgb)) {
                        unique.push(p[i]);
                        paletteLookup[rgb] = true;
                    }
                }
            }

            return unique.reverse().slice(0, opts.maxSelectionSize);
        }

        function drawPalette() {

            var currentColor = get();

            var html = $.map(paletteArray, function (palette, i) {
                return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i);
            });

            if (selectionPalette) {
                html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection"));
            }

            paletteContainer.html(html.join(""));
        }

        function drawInitial() {
            if (opts.showInitial) {
                var initial = colorOnShow;
                var current = get();
                initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial"));
            }
        }

        function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
                reflow();
            }
            container.addClass(draggingClass);
            shiftMovementDirection = null;
        }

        function dragStop() {
            container.removeClass(draggingClass);
        }

        function setFromTextInput() {
            var tiny = tinycolor(textInput.val());
            if (tiny.ok) {
                set(tiny);
            }
            else {
                textInput.addClass("sp-validation-error");
            }
        }

        function toggle() {
            if (visible) {
                hide();
            }
            else {
                show();
            }
        }

        function show() {
            var event = $.Event('beforeShow.spectrum');

            if (visible) {
                reflow();
                return;
            }

            boundElement.trigger(event, [ get() ]);

            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
                return;
            }

            hideAll();
            visible = true;

            $(doc).bind("click.spectrum", hide);
            $(window).bind("resize.spectrum", resize);
            replacer.addClass("sp-active");
            container.removeClass("sp-hidden");

            if (opts.showPalette) {
                drawPalette();
            }
            reflow();
            updateUI();

            colorOnShow = get();

            drawInitial();
            callbacks.show(colorOnShow);
            boundElement.trigger('show.spectrum', [ colorOnShow ]);
        }

        function hide(e) {

            // Return on right click
            if (e && e.type == "click" && e.button == 2) { return; }

            // Return if hiding is unnecessary
            if (!visible || flat) { return; }
            visible = false;

            $(doc).unbind("click.spectrum", hide);
            $(window).unbind("resize.spectrum", resize);

            replacer.removeClass("sp-active");
            container.addClass("sp-hidden");

            var colorHasChanged = !tinycolor.equals(get(), colorOnShow);

            if (colorHasChanged) {
                if (clickoutFiresChange && e !== "cancel") {
                    updateOriginalInput(true);
                }
                else {
                    revert();
                }
            }

            callbacks.hide(get());
            boundElement.trigger('hide.spectrum', [ get() ]);
        }

        function revert() {
            set(colorOnShow, true);
        }

        function set(color, ignoreFormatChange) {
            if (tinycolor.equals(color, get())) {
                return;
            }

            var newColor = tinycolor(color);
            var newHsv = newColor.toHsv();

            currentHue = (newHsv.h % 360) / 360;
            currentSaturation = newHsv.s;
            currentValue = newHsv.v;
            currentAlpha = newHsv.a;

            updateUI();

            if (newColor.ok && !ignoreFormatChange) {
                currentPreferredFormat = preferredFormat || newColor.format;
            }
        }

        function get(opts) {
            opts = opts || { };
            return tinycolor.fromRatio({
                h: currentHue,
                s: currentSaturation,
                v: currentValue,
                a: Math.round(currentAlpha * 100) / 100
            }, { format: opts.format || currentPreferredFormat });
        }

        function isValid() {
            return !textInput.hasClass("sp-validation-error");
        }

        function move() {
            updateUI();

            callbacks.move(get());
            boundElement.trigger('move.spectrum', [ get() ]);
        }

        function updateUI() {

            textInput.removeClass("sp-validation-error");

            updateHelperLocations();

            // Update dragger background color (gradients take care of saturation and value).
            var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
            dragger.css("background-color", flatColor.toHexString());

            // Get a format that alpha will be included in (hex and names ignore alpha)
            var format = currentPreferredFormat;
            if (currentAlpha < 1) {
                if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
                    format = "rgb";
                }
            }

            var realColor = get({ format: format }),
                realHex = realColor.toHexString(),
                realRgb = realColor.toRgbString();

            // Update the replaced elements background color (with actual selected color)
            if (rgbaSupport || realColor.alpha === 1) {
                previewElement.css("background-color", realRgb);
            }
            else {
                previewElement.css("background-color", "transparent");
                previewElement.css("filter", realColor.toFilter());
            }

            if (opts.showAlpha) {
                var rgb = realColor.toRgb();
                rgb.a = 0;
                var realAlpha = tinycolor(rgb).toRgbString();
                var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";

                if (IE) {
                    alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
                }
                else {
                    alphaSliderInner.css("background", "-webkit-" + gradient);
                    alphaSliderInner.css("background", "-moz-" + gradient);
                    alphaSliderInner.css("background", "-ms-" + gradient);
                    alphaSliderInner.css("background", gradient);
                }
            }


            // Update the text entry input as it changes happen
            if (opts.showInput) {
                textInput.val(realColor.toString(format));
            }

            if (opts.showPalette) {
                drawPalette();
            }

            drawInitial();
        }

        function updateHelperLocations() {
            var s = currentSaturation;
            var v = currentValue;

            // Where to show the little circle in that displays your current selected color
            var dragX = s * dragWidth;
            var dragY = dragHeight - (v * dragHeight);
            dragX = Math.max(
                -dragHelperHeight,
                Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
            );
            dragY = Math.max(
                -dragHelperHeight,
                Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
            );
            dragHelper.css({
                "top": dragY,
                "left": dragX
            });

            var alphaX = currentAlpha * alphaWidth;
            alphaSlideHelper.css({
                "left": alphaX - (alphaSlideHelperWidth / 2)
            });

            // Where to show the bar that displays your current selected hue
            var slideY = (currentHue) * slideHeight;
            slideHelper.css({
                "top": slideY - slideHelperHeight
            });
        }

        function updateOriginalInput(fireCallback) {
            var color = get();

            if (isInput) {
                boundElement.val(color.toString(currentPreferredFormat)).change();
            }

            var hasChanged = !tinycolor.equals(color, colorOnShow);
            colorOnShow = color;

            // Update the selection palette with the current color
            addColorToSelectionPalette(color);
            if (fireCallback && hasChanged) {
                callbacks.change(color);
                boundElement.trigger('change.spectrum', [ color ]);
            }
        }

        function reflow() {
            dragWidth = dragger.width();
            dragHeight = dragger.height();
            dragHelperHeight = dragHelper.height();
            slideWidth = slider.width();
            slideHeight = slider.height();
            slideHelperHeight = slideHelper.height();
            alphaWidth = alphaSlider.width();
            alphaSlideHelperWidth = alphaSlideHelper.width();

            if (!flat) {
                container.css("position", "absolute");
                container.offset(getOffset(container, offsetElement));
            }

            updateHelperLocations();
        }

        function destroy() {
            boundElement.show();
            offsetElement.unbind("click.spectrum touchstart.spectrum");
            container.remove();
            replacer.remove();
            spectrums[spect.id] = null;
        }

        function option(optionName, optionValue) {
            if (optionName === undefined) {
                return $.extend({}, opts);
            }
            if (optionValue === undefined) {
                return opts[optionName];
            }

            opts[optionName] = optionValue;
            applyOptions();
        }

        function enable() {
            disabled = false;
            boundElement.attr("disabled", false);
            offsetElement.removeClass("sp-disabled");
        }

        function disable() {
            hide();
            disabled = true;
            boundElement.attr("disabled", true);
            offsetElement.addClass("sp-disabled");
        }

        initialize();

        var spect = {
            show: show,
            hide: hide,
            toggle: toggle,
            reflow: reflow,
            option: option,
            enable: enable,
            disable: disable,
            set: function (c) {
                set(c);
                updateOriginalInput();
            },
            get: get,
            destroy: destroy,
            container: container
        };

        spect.id = spectrums.push(spect) - 1;

        return spect;
    }

    /**
    * checkOffset - get the offset below/above and left/right element depending on screen position
    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
    */
    function getOffset(picker, input) {
        var extraY = 0;
        var dpWidth = picker.outerWidth();
        var dpHeight = picker.outerHeight();
        var inputHeight = input.outerHeight();
        var doc = picker[0].ownerDocument;
        var docElem = doc.documentElement;
        var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
        var viewHeight = docElem.clientHeight + $(doc).scrollTop();
        var offset = input.offset();
        offset.left += (input.outerWidth());
        //offset.top += inputHeight;
        offset.top -= (dpHeight / 2);
        if (offset.top < 0) {
            offset.top = 0;
        }
        if (offset.top < $(doc).scrollTop()) {
            offset.top = $(doc).scrollTop();
        }
        
        offset.left -=
            Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
            Math.abs(offset.left + dpWidth - viewWidth) : 0);

        offset.top -=
            Math.min(offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
            Math.abs(dpHeight + inputHeight - extraY) : extraY));

        return offset;
    }

    /**
    * noop - do nothing
    */
    function noop() {

    }

    /**
    * stopPropagation - makes the code only doing this a little easier to read in line
    */
    function stopPropagation(e) {
        e.stopPropagation();
    }

    /**
    * Create a function bound to a given object
    * Thanks to underscore.js
    */
    function bind(func, obj) {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments, 2);
        return function () {
            return func.apply(obj, args.concat(slice.call(arguments)));
        };
    }

    /**
    * Lightweight drag helper.  Handles containment within the element, so that
    * when dragging, the x is within [0,element.width] and y is within [0,element.height]
    */
    function draggable(element, onmove, onstart, onstop) {
        onmove = onmove || function () { };
        onstart = onstart || function () { };
        onstop = onstop || function () { };
        var doc = element.ownerDocument || document;
        var dragging = false;
        var offset = {};
        var maxHeight = 0;
        var maxWidth = 0;
        var hasTouch = ('ontouchstart' in window);

        var duringDragEvents = {};
        duringDragEvents["selectstart"] = prevent;
        duringDragEvents["dragstart"] = prevent;
        duringDragEvents["touchmove mousemove"] = move;
        duringDragEvents["touchend mouseup"] = stop;

        function prevent(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }

        function move(e) {
            if (dragging) {
                // Mouseup happened outside of window
                if (IE && document.documentMode < 9 && !e.button) {
                    return stop();
                }

                var touches = e.originalEvent.touches;
                var pageX = touches ? touches[0].pageX : e.pageX;
                var pageY = touches ? touches[0].pageY : e.pageY;

                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

                if (hasTouch) {
                    // Stop scrolling in iOS
                    prevent(e);
                }

                onmove.apply(element, [dragX, dragY, e]);
            }
        }
        function start(e) {
            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);
            var touches = e.originalEvent.touches;

            if (!rightclick && !dragging) {
                if (onstart.apply(element, arguments) !== false) {
                    dragging = true;
                    maxHeight = $(element).height();
                    maxWidth = $(element).width();
                    offset = $(element).offset();

                    $(doc).bind(duringDragEvents);
                    $(doc.body).addClass("sp-dragging");

                    if (!hasTouch) {
                        move(e);
                    }

                    prevent(e);
                }
            }
        }
        function stop() {
            if (dragging) {
                $(doc).unbind(duringDragEvents);
                $(doc.body).removeClass("sp-dragging");
                onstop.apply(element, arguments);
            }
            dragging = false;
        }

        $(element).bind("touchstart mousedown", start);
    }

    function throttle(func, wait, debounce) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var throttler = function () {
                timeout = null;
                func.apply(context, args);
            };
            if (debounce) clearTimeout(timeout);
            if (debounce || !timeout) timeout = setTimeout(throttler, wait);
        };
    }


    function log(){/* jshint -W021 */if(window.console){if(Function.prototype.bind)log=Function.prototype.bind.call(console.log,console);else log=function(){Function.prototype.apply.call(console.log,console,arguments);};log.apply(this,arguments);}}

    /**
    * Define a jQuery plugin
    */
    var dataID = "spectrum.id";
    $.fn.spectrum = function (opts, extra) {

        if (typeof opts == "string") {

            var returnValue = this;
            var args = Array.prototype.slice.call( arguments, 1 );

            this.each(function () {
                var spect = spectrums[$(this).data(dataID)];
                if (spect) {

                    var method = spect[opts];
                    if (!method) {
                        throw new Error( "Spectrum: no such method: '" + opts + "'" );
                    }

                    if (opts == "get") {
                        returnValue = spect.get();
                    }
                    else if (opts == "container") {
                        returnValue = spect.container;
                    }
                    else if (opts == "option") {
                        returnValue = spect.option.apply(spect, args);
                    }
                    else if (opts == "destroy") {
                        spect.destroy();
                        $(this).removeData(dataID);
                    }
                    else {
                        method.apply(spect, args);
                    }
                }
            });

            return returnValue;
        }

        // Initializing a new instance of spectrum
        return this.spectrum("destroy").each(function () {
            var spect = spectrum(this, opts);
            $(this).data(dataID, spect.id);
        });
    };

    $.fn.spectrum.load = true;
    $.fn.spectrum.loadOpts = {};
    $.fn.spectrum.draggable = draggable;
    $.fn.spectrum.defaults = defaultOpts;

    $.spectrum = { };
    $.spectrum.localization = { };
    $.spectrum.palettes = { };

    $.fn.spectrum.processNativeColorInputs = function () {
        var colorInput = $("<input type='color' value='!' />")[0];
        var supportsColor = colorInput.type === "color" && colorInput.value != "!";

        if (!supportsColor) {
            $("input[type=color]").spectrum({
                preferredFormat: "hex6"
            });
        }
    };
    // TinyColor v0.9.14
    // https://github.com/bgrins/TinyColor
    // 2013-02-24, Brian Grinstead, MIT License

    (function(root) {

        var trimLeft = /^[\s,#]+/,
            trimRight = /\s+$/,
            tinyCounter = 0,
            math = Math,
            mathRound = math.round,
            mathMin = math.min,
            mathMax = math.max,
            mathRandom = math.random;

        function tinycolor (color, opts) {

            color = (color) ? color : '';
            opts = opts || { };

            // If input is already a tinycolor, return itself
            if (typeof color == "object" && color.hasOwnProperty("_tc_id")) {
               return color;
            }
            var rgb = inputToRGB(color);
            var r = rgb.r,
                g = rgb.g,
                b = rgb.b,
                a = rgb.a,
                roundA = mathRound(100*a) / 100,
                format = opts.format || rgb.format;

            // Don't let the range of [0,255] come back in [0,1].
            // Potentially lose a little bit of precision here, but will fix issues where
            // .5 gets interpreted as half of the total, instead of half of 1
            // If it was supposed to be 128, this was already taken care of by `inputToRgb`
            if (r < 1) { r = mathRound(r); }
            if (g < 1) { g = mathRound(g); }
            if (b < 1) { b = mathRound(b); }

            return {
                ok: rgb.ok,
                format: format,
                _tc_id: tinyCounter++,
                alpha: a,
                toHsv: function() {
                    var hsv = rgbToHsv(r, g, b);
                    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: a };
                },
                toHsvString: function() {
                    var hsv = rgbToHsv(r, g, b);
                    var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
                    return (a == 1) ?
                      "hsv("  + h + ", " + s + "%, " + v + "%)" :
                      "hsva(" + h + ", " + s + "%, " + v + "%, "+ roundA + ")";
                },
                toHsl: function() {
                    var hsl = rgbToHsl(r, g, b);
                    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: a };
                },
                toHslString: function() {
                    var hsl = rgbToHsl(r, g, b);
                    var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
                    return (a == 1) ?
                      "hsl("  + h + ", " + s + "%, " + l + "%)" :
                      "hsla(" + h + ", " + s + "%, " + l + "%, "+ roundA + ")";
                },
                toHex: function(allow3Char) {
                    return rgbToHex(r, g, b, allow3Char);
                },
                toHexString: function(allow3Char) {
                    return '#' + rgbToHex(r, g, b, allow3Char);
                },
                toRgb: function() {
                    return { r: mathRound(r), g: mathRound(g), b: mathRound(b), a: a };
                },
                toRgbString: function() {
                    return (a == 1) ?
                      "rgb("  + mathRound(r) + ", " + mathRound(g) + ", " + mathRound(b) + ")" :
                      "rgba(" + mathRound(r) + ", " + mathRound(g) + ", " + mathRound(b) + ", " + roundA + ")";
                },
                toPercentageRgb: function() {
                    return { r: mathRound(bound01(r, 255) * 100) + "%", g: mathRound(bound01(g, 255) * 100) + "%", b: mathRound(bound01(b, 255) * 100) + "%", a: a };
                },
                toPercentageRgbString: function() {
                    return (a == 1) ?
                      "rgb("  + mathRound(bound01(r, 255) * 100) + "%, " + mathRound(bound01(g, 255) * 100) + "%, " + mathRound(bound01(b, 255) * 100) + "%)" :
                      "rgba(" + mathRound(bound01(r, 255) * 100) + "%, " + mathRound(bound01(g, 255) * 100) + "%, " + mathRound(bound01(b, 255) * 100) + "%, " + roundA + ")";
                },
                toName: function() {
                    return hexNames[rgbToHex(r, g, b, true)] || false;
                },
                toFilter: function(secondColor) {
                    var hex = rgbToHex(r, g, b);
                    var secondHex = hex;
                    var alphaHex = Math.round(parseFloat(a) * 255).toString(16);
                    var secondAlphaHex = alphaHex;
                    var gradientType = opts && opts.gradientType ? "GradientType = 1, " : "";

                    if (secondColor) {
                        var s = tinycolor(secondColor);
                        secondHex = s.toHex();
                        secondAlphaHex = Math.round(parseFloat(s.alpha) * 255).toString(16);
                    }

                    return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr=#" + pad2(alphaHex) + hex + ",endColorstr=#" + pad2(secondAlphaHex) + secondHex + ")";
                },
                toString: function(format) {
                    format = format || this.format;
                    var formattedString = false;
                    if (format === "rgb") {
                        formattedString = this.toRgbString();
                    }
                    if (format === "prgb") {
                        formattedString = this.toPercentageRgbString();
                    }
                    if (format === "hex" || format === "hex6") {
                        formattedString = this.toHexString();
                    }
                    if (format === "hex3") {
                        formattedString = this.toHexString(true);
                    }
                    if (format === "name") {
                        formattedString = this.toName();
                    }
                    if (format === "hsl") {
                        formattedString = this.toHslString();
                    }
                    if (format === "hsv") {
                        formattedString = this.toHsvString();
                    }

                    return formattedString || this.toHexString();
                }
            };
        }

        // If input is an object, force 1 into "1.0" to handle ratios properly
        // String input requires "1.0" as input, so 1 will be treated as 1
        tinycolor.fromRatio = function(color, opts) {
            if (typeof color == "object") {
                var newColor = {};
                for (var i in color) {
                    if (color.hasOwnProperty(i)) {
                        if (i === "a") {
                            newColor[i] = color[i];
                        }
                        else {
                            newColor[i] = convertToPercentage(color[i]);
                        }
                    }
                }
                color = newColor;
            }

            return tinycolor(color, opts);
        };

        // Given a string or object, convert that input to RGB
        // Possible string inputs:
        //
        //     "red"
        //     "#f00" or "f00"
        //     "#ff0000" or "ff0000"
        //     "rgb 255 0 0" or "rgb (255, 0, 0)"
        //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
        //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
        //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
        //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
        //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
        //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
        //
        function inputToRGB(color) {

            var rgb = { r: 0, g: 0, b: 0 };
            var a = 1;
            var ok = false;
            var format = false;

            if (typeof color == "string") {
                color = stringInputToObject(color);
            }

            if (typeof color == "object") {
                if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
                    rgb = rgbToRgb(color.r, color.g, color.b);
                    ok = true;
                    format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
                }
                else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
                    color.s = convertToPercentage(color.s);
                    color.v = convertToPercentage(color.v);
                    rgb = hsvToRgb(color.h, color.s, color.v);
                    ok = true;
                    format = "hsv";
                }
                else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
                    color.s = convertToPercentage(color.s);
                    color.l = convertToPercentage(color.l);
                    rgb = hslToRgb(color.h, color.s, color.l);
                    ok = true;
                    format = "hsl";
                }

                if (color.hasOwnProperty("a")) {
                    a = color.a;
                }
            }

            a = parseFloat(a);

            // Handle invalid alpha characters by setting to 1
            if (isNaN(a) || a < 0 || a > 1) {
                a = 1;
            }

            return {
                ok: ok,
                format: color.format || format,
                r: mathMin(255, mathMax(rgb.r, 0)),
                g: mathMin(255, mathMax(rgb.g, 0)),
                b: mathMin(255, mathMax(rgb.b, 0)),
                a: a
            };
        }



        // Conversion Functions
        // --------------------

        // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
        // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

        // `rgbToRgb`
        // Handle bounds / percentage checking to conform to CSS color spec
        // <http://www.w3.org/TR/css3-color/>
        // *Assumes:* r, g, b in [0, 255] or [0, 1]
        // *Returns:* { r, g, b } in [0, 255]
        function rgbToRgb(r, g, b){
            return {
                r: bound01(r, 255) * 255,
                g: bound01(g, 255) * 255,
                b: bound01(b, 255) * 255
            };
        }

        // `rgbToHsl`
        // Converts an RGB color value to HSL.
        // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
        // *Returns:* { h, s, l } in [0,1]
        function rgbToHsl(r, g, b) {

            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);

            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, l = (max + min) / 2;

            if(max == min) {
                h = s = 0; // achromatic
            }
            else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch(max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }

                h /= 6;
            }

            return { h: h, s: s, l: l };
        }

        // `hslToRgb`
        // Converts an HSL color value to RGB.
        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
        // *Returns:* { r, g, b } in the set [0, 255]
        function hslToRgb(h, s, l) {
            var r, g, b;

            h = bound01(h, 360);
            s = bound01(s, 100);
            l = bound01(l, 100);

            function hue2rgb(p, q, t) {
                if(t < 0) t += 1;
                if(t > 1) t -= 1;
                if(t < 1/6) return p + (q - p) * 6 * t;
                if(t < 1/2) return q;
                if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            if(s === 0) {
                r = g = b = l; // achromatic
            }
            else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return { r: r * 255, g: g * 255, b: b * 255 };
        }

        // `rgbToHsv`
        // Converts an RGB color value to HSV
        // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
        // *Returns:* { h, s, v } in [0,1]
        function rgbToHsv(r, g, b) {

            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);

            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, v = max;

            var d = max - min;
            s = max === 0 ? 0 : d / max;

            if(max == min) {
                h = 0; // achromatic
            }
            else {
                switch(max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h, s: s, v: v };
        }

        // `hsvToRgb`
        // Converts an HSV color value to RGB.
        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
        // *Returns:* { r, g, b } in the set [0, 255]
         function hsvToRgb(h, s, v) {

            h = bound01(h, 360) * 6;
            s = bound01(s, 100);
            v = bound01(v, 100);

            var i = math.floor(h),
                f = h - i,
                p = v * (1 - s),
                q = v * (1 - f * s),
                t = v * (1 - (1 - f) * s),
                mod = i % 6,
                r = [v, q, p, p, t, v][mod],
                g = [t, v, v, q, p, p][mod],
                b = [p, p, t, v, v, q][mod];

            return { r: r * 255, g: g * 255, b: b * 255 };
        }

        // `rgbToHex`
        // Converts an RGB color to hex
        // Assumes r, g, and b are contained in the set [0, 255]
        // Returns a 3 or 6 character hex
        function rgbToHex(r, g, b, allow3Char) {

            var hex = [
                pad2(mathRound(r).toString(16)),
                pad2(mathRound(g).toString(16)),
                pad2(mathRound(b).toString(16))
            ];

            // Return a 3 character hex if possible
            if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
                return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
            }

            return hex.join("");
        }

        // `equals`
        // Can be called with any tinycolor input
        tinycolor.equals = function (color1, color2) {
            if (!color1 || !color2) { return false; }
            return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function() {
            return tinycolor.fromRatio({
                r: mathRandom(),
                g: mathRandom(),
                b: mathRandom()
            });
        };


        // Modification Functions
        // ----------------------
        // Thanks to less.js for some of the basics here
        // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>


        tinycolor.desaturate = function (color, amount) {
            var hsl = tinycolor(color).toHsl();
            hsl.s -= ((amount || 10) / 100);
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
        };
        tinycolor.saturate = function (color, amount) {
            var hsl = tinycolor(color).toHsl();
            hsl.s += ((amount || 10) / 100);
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
        };
        tinycolor.greyscale = function(color) {
            return tinycolor.desaturate(color, 100);
        };
        tinycolor.lighten = function(color, amount) {
            var hsl = tinycolor(color).toHsl();
            hsl.l += ((amount || 10) / 100);
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
        };
        tinycolor.darken = function (color, amount) {
            var hsl = tinycolor(color).toHsl();
            hsl.l -= ((amount || 10) / 100);
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
        };
        tinycolor.complement = function(color) {
            var hsl = tinycolor(color).toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return tinycolor(hsl);
        };


        // Combination Functions
        // ---------------------
        // Thanks to jQuery xColor for some of the ideas behind these
        // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

        tinycolor.triad = function(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
                tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
            ];
        };
        tinycolor.tetrad = function(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
                tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
                tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
            ];
        };
        tinycolor.splitcomplement = function(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
                tinycolor(color),
                tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
                tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
            ];
        };
        tinycolor.analogous = function(color, results, slices) {
            results = results || 6;
            slices = slices || 30;

            var hsl = tinycolor(color).toHsl();
            var part = 360 / slices;
            var ret = [tinycolor(color)];

            for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
                hsl.h = (hsl.h + part) % 360;
                ret.push(tinycolor(hsl));
            }
            return ret;
        };
        tinycolor.monochromatic = function(color, results) {
            results = results || 6;
            var hsv = tinycolor(color).toHsv();
            var h = hsv.h, s = hsv.s, v = hsv.v;
            var ret = [];
            var modification = 1 / results;

            while (results--) {
                ret.push(tinycolor({ h: h, s: s, v: v}));
                v = (v + modification) % 1;
            }

            return ret;
        };

        // Readability Functions
        // ---------------------
        // <http://www.w3.org/TR/AERT#color-contrast>

        // `readability`
        // Analyze the 2 colors and returns an object with the following properties:
        //    `brightness`: difference in brightness between the two colors
        //    `color`: difference in color/hue between the two colors
        tinycolor.readability = function(color1, color2) {
            var a = tinycolor(color1).toRgb();
            var b = tinycolor(color2).toRgb();
            var brightnessA = (a.r * 299 + a.g * 587 + a.b * 114) / 1000;
            var brightnessB = (b.r * 299 + b.g * 587 + b.b * 114) / 1000;
            var colorDiff = (
                Math.max(a.r, b.r) - Math.min(a.r, b.r) +
                Math.max(a.g, b.g) - Math.min(a.g, b.g) +
                Math.max(a.b, b.b) - Math.min(a.b, b.b)
            );

            return {
                brightness: Math.abs(brightnessA - brightnessB),
                color: colorDiff
            };
        };

        // `readable`
        // http://www.w3.org/TR/AERT#color-contrast
        // Ensure that foreground and background color combinations provide sufficient contrast.
        // *Example*
        //    tinycolor.readable("#000", "#111") => false
        tinycolor.readable = function(color1, color2) {
            var readability = tinycolor.readability(color1, color2);
            return readability.brightness > 125 && readability.color > 500;
        };

        // `mostReadable`
        // Given a base color and a list of possible foreground or background
        // colors for that base, returns the most readable color.
        // *Example*
        //    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
        tinycolor.mostReadable = function(baseColor, colorList) {
            var bestColor = null;
            var bestScore = 0;
            var bestIsReadable = false;
            for (var i=0; i < colorList.length; i++) {

                // We normalize both around the "acceptable" breaking point,
                // but rank brightness constrast higher than hue.

                var readability = tinycolor.readability(baseColor, colorList[i]);
                var readable = readability.brightness > 125 && readability.color > 500;
                var score = 3 * (readability.brightness / 125) + (readability.color / 500);

                if ((readable && ! bestIsReadable) ||
                    (readable && bestIsReadable && score > bestScore) ||
                    ((! readable) && (! bestIsReadable) && score > bestScore)) {
                    bestIsReadable = readable;
                    bestScore = score;
                    bestColor = tinycolor(colorList[i]);
                }
            }
            return bestColor;
        };


        // Big List of Colors
        // ------------------
        // <http://www.w3.org/TR/css3-color/#svg-color>
        var names = tinycolor.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
        };

        // Make it easy to access colors via `hexNames[hex]`
        var hexNames = tinycolor.hexNames = flip(names);


        // Utilities
        // ---------

        // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
        function flip(o) {
            var flipped = { };
            for (var i in o) {
                if (o.hasOwnProperty(i)) {
                    flipped[o[i]] = i;
                }
            }
            return flipped;
        }

        // Take input from [0, n] and return it as [0, 1]
        function bound01(n, max) {
            if (isOnePointZero(n)) { n = "100%"; }

            var processPercent = isPercentage(n);
            n = mathMin(max, mathMax(0, parseFloat(n)));

            // Automatically convert percentage into number
            if (processPercent) {
                n = parseInt(n * max, 10) / 100;
            }

            // Handle floating point rounding errors
            if ((math.abs(n - max) < 0.000001)) {
                return 1;
            }

            // Convert into [0, 1] range if it isn't already
            return (n % max) / parseFloat(max);
        }

        // Force a number between 0 and 1
        function clamp01(val) {
            return mathMin(1, mathMax(0, val));
        }

        // Parse an integer into hex
        function parseHex(val) {
            return parseInt(val, 16);
        }

        // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
        // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
        function isOnePointZero(n) {
            return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
        }

        // Check to see if string passed in is a percentage
        function isPercentage(n) {
            return typeof n === "string" && n.indexOf('%') != -1;
        }

        // Force a hex value to have 2 characters
        function pad2(c) {
            return c.length == 1 ? '0' + c : '' + c;
        }

        // Replace a decimal with it's percentage value
        function convertToPercentage(n) {
            if (n <= 1) {
                n = (n * 100) + "%";
            }

            return n;
        }

        var matchers = (function() {

            // <http://www.w3.org/TR/css3-values/#integers>
            var CSS_INTEGER = "[-\\+]?\\d+%?";

            // <http://www.w3.org/TR/css3-values/#number-value>
            var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

            // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
            var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

            // Actual matching.
            // Parentheses and commas are optional, but not required.
            // Whitespace can take the place of commas or opening paren
            var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
            var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

            return {
                rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
                rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
                hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
                hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
                hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
                hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
        })();

        // `stringInputToObject`
        // Permissive string parsing.  Take in a number of formats, and output an object
        // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
        function stringInputToObject(color) {

            color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
            var named = false;
            if (names[color]) {
                color = names[color];
                named = true;
            }
            else if (color == 'transparent') {
                return { r: 0, g: 0, b: 0, a: 0 };
            }

            // Try to match string input using regular expressions.
            // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
            // Just return an object and let the conversion functions handle that.
            // This way the result will be the same whether the tinycolor is initialized with string or object.
            var match;
            if ((match = matchers.rgb.exec(color))) {
                return { r: match[1], g: match[2], b: match[3] };
            }
            if ((match = matchers.rgba.exec(color))) {
                return { r: match[1], g: match[2], b: match[3], a: match[4] };
            }
            if ((match = matchers.hsl.exec(color))) {
                return { h: match[1], s: match[2], l: match[3] };
            }
            if ((match = matchers.hsla.exec(color))) {
                return { h: match[1], s: match[2], l: match[3], a: match[4] };
            }
            if ((match = matchers.hsv.exec(color))) {
                return { h: match[1], s: match[2], v: match[3] };
            }
            if ((match = matchers.hex6.exec(color))) {
                return {
                    r: parseHex(match[1]),
                    g: parseHex(match[2]),
                    b: parseHex(match[3]),
                    format: named ? "name" : "hex"
                };
            }
            if ((match = matchers.hex3.exec(color))) {
                return {
                    r: parseHex(match[1] + '' + match[1]),
                    g: parseHex(match[2] + '' + match[2]),
                    b: parseHex(match[3] + '' + match[3]),
                    format: named ? "name" : "hex"
                };
            }

            return false;
        }

        root.tinycolor = tinycolor;

    })(this);

    $(function () {
        if ($.fn.spectrum.load) {
            $.fn.spectrum.processNativeColorInputs();
        }
    });

})(window, jQuery);
;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function($) {

    $.helixDialog = {
        // Define the defaults used for all new dialog instances
        defaultOptions: {
            hasForm: false,
            onConfirm: null,
            onDismiss: null,
            confirmTitle: "Confirm",
            dismissTitle: "Dismiss",
            positionTo: 'origin'
        }
    };
    
    // cleditor - creates a new editor for each of the matched textareas
    $.fn.helixDialog = function(options) {
      // Create a dialog on the element supplied.
      var elem = this[0];
      var data = $.data(elem, HXDIALOG);
      if (!data) {
          data = new helixDialog(elem, options);
          $(elem).data(HXDIALOG, data);
      }

      return data;

    };
    
    //==================
    // Private Variables
    //==================

    var
      HXDIALOG = "HXDIALOG";
  
  
    //============
    // Constructor
    //============

    // cleditor - creates a new editor for the passed in textarea element
    helixDialog = function(parent, options) {
        this.options = options = $.extend({}, $.helixDialog.defaultOptions, options);        
        this.$mainDiv = $(parent);
        this.name = options.name ? options.name : Helix.Utils.getUniqueID();

        this.refresh(true);
    }
    
    //===============
    // Public Methods
    //===============

    var fn = helixDialog.prototype,

    // Expose the following private functions as methods on the cleditor object.
    // The closure compiler will rename the private functions. However, the
    // exposed method names on the cleditor object will remain fixed.
    methods = [
      ["show", show],
      ["hide", hide],
      ["refresh", refresh],
      ["getForm", getForm]
    ];

    $.each(methods, function(idx, method) {
      fn[method[0]] = function() {
        var hxDialog = this, args = [hxDialog];
        // using each here would cast booleans into objects!
        for(var x = 0; x < arguments.length; x++) {args.push(arguments[x]);}
        var result = method[1].apply(hxDialog, args);
        if (method[2]) return result;
        return hxDialog;
      };
    });

    /**
     * Call this function to show the dialog.
     */
    function show(dialog,formElems) {
        if (dialog.options.hasForm && formElems) {
            /* Layout the form dynamically. */
            Helix.Utils.layoutForm($(dialog.form), formElems);
            $(dialog.form).find('input,textarea').on('tap', function(ev) {
                $(ev.target).focus();
                return false;
            });
        }
        $(dialog.$mainDiv).popup( "open", { 
            positionTo : dialog.options.positionTo
        });
    }
    
    function getForm(dialog) {
        return dialog.form;
    }
    
    function hide() {
        $(this.$mainDiv).popup( "close" );
    }
    
    function refresh(isCreate) {
        this.$mainDiv.empty();
            
        encodeHeader(this, this.$mainDiv);
        encodeContent(this, this.$mainDiv);
        
        if (!isCreate) {
            this.$mainDiv.popup('refresh');
        } else {
            if (this.options.hasForm) {
                this.$mainDiv.popup({
                    theme: 'a',
                    corners: true
                });
                this.$mainDiv.append($('<div/>').attr({
                    'style' : 'padding: 10px 20px;'
                }));
            } else {
                this.$mainDiv.popup({
                    theme: 'a',
                    overlayTheme: 'c',
                    corners: true
                });
            }
        }
    }

    function encodeHeader(dialog,$mainDiv) {
        
        if (dialog.options.hasForm) {
            $mainDiv.append($('<h3/>').append(dialog.options.title));
        } else {
            // Apply classes manually because jQM enhancement of headers/footers only happens
            // on page create
            $mainDiv.append($('<div/>').attr({
                'class' : (dialog.titleStyleClass ? dialog.titleStyleClass : '') + ' ui-corner-top ui-header ui-bar-a'
            }).append($('<h1/>').attr({
                'class' : 'ui-title'
            }).append(dialog.options.title)));            
        }
    }
    
    function encodeContent(dialog,$mainDiv) {
        var dialogContentClass = dialog.options.contentStyleClass;
        if (dialog.options.hasForm) {
            dialogContentClass = dialogContentClass + " ui-corner-bottom ui-content";
        } else {
            dialogContentClass = dialogContentClass + " ui-corner-bottom ui-content ui-body-d";
        }
        var $contentDiv = $('<div/>').attr({
            'class' : (dialogContentClass ? dialogContentClass : ''),
            'id' : dialog.options.id + "_content"
        });
        
        if (!dialog.options.hasForm) {
            $contentDiv.attr('data-role', 'content');
            $contentDiv.attr('data-theme', 'd');
        
            if (dialog.options.bodyHeader) {
                $contentDiv.append($('<h3/>').attr({
                    'class' : 'ui-title'
                }).append(dialog.options.bodyHeader));
            }
            if (dialog.options.bodyContent) {
                $contentDiv.append($('<p/>').append(dialog.options.bodyContent));
            }
        } else {
            dialog.form = $('<form/>').attr({
                'id' : dialog.name + "-form"
            });
            $contentDiv.append(dialog.form);
        }
        
        /* Cancel button. */
        $contentDiv.append($('<a/>').attr({
            'href' : 'javascript:void(0)',
            'data-role' : 'button',
            'data-inline' : 'true',
            'data-theme' : 'c',
            'id' : dialog.name + '-cancel'
        }).append(dialog.options.dismissTitle)
            .on(Helix.clickEvent, function(ev) {
                ev.stopImmediatePropagation();
                if (dialog.options.onDismiss) {
                    dialog.options.onDismiss.call(dialog);
                }
                $(dialog.$mainDiv).popup( "close" );
                return false;
            }).button()
        );
        
        /* Confirm button. */
        $contentDiv.append($('<a/>').attr({
            'href' : 'javascript:void(0)',
            'data-role' : 'button',
            'data-inline' : 'true',
            'data-theme' : 'b',
            'data-transition' : 'flow',
            'id' : dialog.name + '-confirm'
        }).append(dialog.options.confirmTitle)
            .on(Helix.clickEvent, function(ev) {
                ev.preventDefault();
                if (dialog.options.hasForm && dialog.form) {
                    dialog.options.onConfirm.call(dialog, $(dialog.form).serialize());
                } else {
                    dialog.options.onConfirm.call(dialog);
                }
                $(dialog.$mainDiv).popup( "close" );
                return false;
            }).button()
        );

        $mainDiv.append($contentDiv);
    }
    
})(jQuery);;/**
 @preserve CLEditor WYSIWYG HTML Editor v1.3.0
 http://premiumsoftware.net/cleditor
 requires jQuery v1.4.2 or later

 Copyright 2010, Chris Landowski, Premium Software, LLC
 Dual licensed under the MIT or GPL Version 2 licenses.
*/

// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS
// @output_file_name jquery.cleditor.min.js
// ==/ClosureCompiler==

(function($) {

    //==============
    // jQuery Plugin
    //==============

    $.cleditor = {

        // Define the defaults used for all new cleditor instances
        defaultOptions: {
            width:        500, // width not including margins, borders or padding
            height:       300, // height not including margins, borders or padding
            controls:     // controls to add to the toolbar
            {
                "default": {
                    styles: "bold italic underline strikethrough subscript superscript | sizexxsmall sizexsmall sizesmall sizenormal sizelarge sizexlarge sizexxlarge",
                    //font: "font size color highlight",
                    font: "font",
                    formats: "bullets numbering | outdent indent | alignleft center alignright justify" +
                    " | rule", /* image link unlink*/
                    actions : "undo redo" /* removeformat */,
                    color : "color highlight"
                },
                "phone" : {
                    styles: "bold italic underline strikethrough subscript superscript",
                    //font: "font size color highlight",
                    font: "font",
                    formats: "bullets numbering | outdent indent | alignleft center alignright justify",
                    actions : "undo redo" /* removeformat */,
                    color : "color highlight"
                }
            }
            ,
            font:        // font names in the font popup
            "Arial,Arial Black,Comic Sans MS,Courier New,Narrow,Garamond," +
            "Georgia,Impact,Sans Serif,Serif,Tahoma,Trebuchet MS,Verdana",
            styles:       // styles in the style popup
            [["Paragraph", "<p>"], ["Header 1", "<h1>"], ["Header 2", "<h2>"],
            ["Header 3", "<h3>"],  ["Header 4","<h4>"],  ["Header 5","<h5>"],
            ["Header 6","<h6>"]],
            useCSS:       true, // use CSS to style HTML when possible (not supported in ie)
            docType:      // Document type contained within the editor
            //'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
            '<!DOCTYPE html>',
            docCSSFile:   // CSS file used to style the document contained within the editor
            "",
            bodyStyle:    // style to assign to document body contained within the editor
            "font:10pt Arial,Verdana; cursor:text; overflow-y: scroll; overflow-x: hidden; word-wrap: break-word; margin: 0px;",
            // -webkit-transform: translate3d(0,0,0)
            tabIndex: -1
        },

        // Define all usable toolbar buttons - the init string property is
        //   expanded during initialization back into the buttons object and
        //   seperate object properties are created for each button.
        //   e.g. buttons.size.title = "Font Size"
        buttons: {
            // name,title,command,popupName (""=use name)
            init:
            "bold,,|" +
        "italic,,|" +
        "underline,,|" +
        "strikethrough,,|" +
        "subscript,,|" +
        "superscript,,|" +
        "font,,fontname,|" +
        "size,,fontsize,|" +
        "style,,formatblock,|" +
        "color,Font Color,forecolor|" +
        "highlight,Text Highlight,hilitecolor|" +
        "removeformat,Remove Formatting,|" +
        "bullets,,insertunorderedlist|" +
        "numbering,,insertorderedlist|" +
        "outdent,,|" +
        "indent,,|" +
        "alignleft,Align Text Left,justifyleft|" +
        "center,,justifycenter|" +
        "alignright,Align Text Right,justifyright|" +
        "justify,,justifyfull|" +
        "undo,,|" +
        "redo,,|" +
        "rule,Insert Horizontal Rule,inserthorizontalrule|" +
        "link,Insert Hyperlink,createlink|" +
        "unlink,Remove Hyperlink,|" +
        "cut,,|" +
        "copy,,|" +
        "paste,,|" +
        "pastetext,Paste as Text,inserthtml,|" +
        "print,,|" +
        "source,Show Source,|" +
        "sizexxsmall,XX-small Text,fontsize,1|" +
        "sizexsmall,X-small Text,fontsize,2|" +
        "sizesmall,Small Text,fontsize,3|" +
        "sizenormal,Normal Text,fontsize,4|" +
        "sizelarge,Large Text,fontsize,5|" +
        "sizexlarge,X-large Text,fontsize,6|" +
        "sizexxlarge,XX-large Text,fontsize,7|"
        },
        /*"image,Insert Image,insertimage,url|" +*/

        // imagesPath - returns the path to the images folder
        imagesPath: function() {
            return imagesPath();
        }

    };

    // cleditor - creates a new editor for each of the matched textareas
    $.fn.cleditor = function(options) {

        // Create a new jQuery object to hold the results
        var $result = $([]);

        // Loop through all matching textareas and create the editors
        this.each(function(idx, elem) {
            if (elem.tagName == "TEXTAREA") {
                var data = $.data(elem, CLEDITOR);
                if (!data) data = new cleditor(elem, options);
                $result = $result.add(data);
            }
        });

        // return the new jQuery object
        return $result;

    };

    //==================
    // Private Variables
    //==================

    var

    // Misc constants
    BUTTON           = "button",
    BUTTON_NAME      = "buttonName",
    BUTTON_VALUE      = "buttonValue",
    CHANGE           = "change",
    CLEDITOR         = "cleditor",
    DISABLED         = "disabled",
    DIV_TAG          = "<div>",
    H2_TAG           = "<h2 />",
    A_TAG            = "<a />",
    SPAN_TAG            = "<span />",
    LI_TAG           = "<li />",
    UL_TAG           = "<ul />",

    // Class name constants
    MAIN_CLASS       = "ui-editor ui-widget-content",    // main containing div
    TOOLBAR_CLASS    = "ui-editor-toolbar",            // Editor toolbar
    PROMPT_CLASS     = "ui-editor-prompt",  // prompt popup divs inside body

    // Test for iPhone/iTouch/iPad
    iOS = /(iphone|ipad|ipod)/i.test(navigator.userAgent),
  
    // Popups are created once as needed and shared by all editor instances
    popups = {},

    // Local copy of the buttons object
    buttons = $.cleditor.buttons;

    var CLICK            = "click";
    if (Helix.hasTouch) {
        CLICK = "vclick";
    }

    //===============
    // Initialization
    //===============

    // Expand the buttons.init string back into the buttons object
    //   and create seperate object properties for each button.
    //   e.g. buttons.size.title = "Font Size"
    $.each(buttons.init.split("|"), function(idx, button) {
        var items = button.split(","), name = items[0];
        buttons[name] = {
            stripIndex: idx,
            name: name,
            title: items[1] === "" ? name.charAt(0).toUpperCase() + name.substr(1) : items[1],
            command: items[2] === "" ? name : items[2],
            data: items[3] === "" ? "" : items[3]
        };
    });
    delete buttons.init;

    //============
    // Constructor
    //============

    // cleditor - creates a new editor for the passed in textarea element
    cleditor = function(area, options) {

        var editor = this;

        // Get the defaults and override with options
        editor.options = options = $.extend({}, $.cleditor.defaultOptions, options);

        // Determine the set of controls based on the device type.
        editor.controls = 
            (options.controls[Helix.deviceType] ? options.controls[Helix.deviceType] : options.controls["default"]);

        // Map whose keys are the current style.
        editor.currentStyles = {};

        // Hide the textarea and associate it with this editor
        var $area = editor.$area = $(area)
        .hide()
        .height(0)
        .width(0)
        .data(CLEDITOR, editor);
        
        editor.name = $(area).attr('name');

        // Capture the page for this item.
        if (!options.page) {
            options.page = $(area).closest('div[data-role="page"]');
            if (options.page.length == 0) {
                options.page = $.mobile.activePage;
            }
        }
        editor.page = options.page;

        // Create the main container and append the textarea
        var $parent = editor.$parent = $(DIV_TAG).insertAfter($area);
        //$area.wrap($parent);

        var $main = editor.$main = $(DIV_TAG)
        .addClass(MAIN_CLASS)
        .css('overflow-y', 'hidden') /* Add this to prevent long text corpuses from bleeding out of the iFrame. */
        .width(options.width)
        .appendTo($parent);
        $main.height(options.height);
        $parent.height(options.height);

        // Add the first group to the toolbar
        var $toolbar = editor.$toolbar = $(DIV_TAG)
        .attr('class', 'ui-body-a ' + TOOLBAR_CLASS)
        .attr('data-role','controlgroup')
        .attr('data-type','horizontal');
        //.attr('data-type','vertical');
        //.attr('style', 'float: right;');
        //.insertAfter($main);

        var doMini = 'false';
        if (Helix.deviceType !== "tablet") {
            doMini = 'true';
        }

        editor.menuPopups = {};
        editor.menuToolbar = {};
        editor.menus = {};

        if (editor.controls.styles) {
            createPopupMenu.call(editor, 'style', 'Style', $parent, $toolbar, editor.controls.styles, doMini)
            editor.$styleMenu = editor.menus['style'];
        }

        if (editor.controls.font) {
            // Add the font commands popup to the button bar
            createPopupMenu.call(editor, 'font', 'Font', $parent, $toolbar, editor.controls.font, doMini)
            editor.$fontMenu = editor.menus['font'];
        }

        if (editor.controls.formats) {
            // Add the format commands popup to the button bar
            createPopupMenu.call(editor, 'format', 'Format', $parent, $toolbar, editor.controls.formats, doMini)
            editor.$formatMenu = editor.menus['format'];
        }
        
        if (editor.controls.color) {
            /* The action menu is "nice-to-have". Skip it on smaller screens. */
            createPopupMenu.call(editor, 'color', 'Color', $parent, $toolbar, editor.controls.color, doMini)
            editor.$colorMenu = editor.menus['color'];
        }
        
        if (editor.controls.actions) {
            /* The action menu is "nice-to-have". Skip it on smaller screens. */
            createPopupMenu.call(editor, 'action', 'Action', $parent, $toolbar, editor.controls.actions, doMini)
            editor.$actionMenu = editor.menus['action'];
        }
        
        /* Attach the toolbar to the enclosing div. */
        $toolbar.appendTo($main);
        
        /* Instantiate the menus. */
        var popupOptions = {
            beforeposition: function() {
                //focus(editor);
                if (editor.$toolbarEnabled) {
                    editor.popupOpen = true;
                }
            },
            afterclose: function() {
                if (editor.nextAction) {
                    focus(editor, function() {                    
                        editor.nextAction();
                        editor.nextAction = null;
                    });
                } else {
                    if (editor.popupOpen && editor.$toolbarEnabled) {
                        focus(editor, function() {
                        });
                    }
                }
                editor.popupOpen = false;
            },
            history: false,
            theme: 'a'
        };
        
        for (var menuName in editor.menuPopups) {
            var $popup = editor.menuPopups[menuName];
            var $menu = editor.menus[menuName];
            var $button = editor.menuToolbar[menuName];
            if ($popup && $menu && $button) {
                $menu.listview();
                $button.button();
                $popup.popup(popupOptions);
                
                // Reduce text padding in the buttons to make them fit on smaller
                // screens.
                if (doMini) {
                    $button.find('.ui-btn-inner').css('padding-left', '10px');
                    $button.find('.ui-btn-inner').css('padding-right', '10px');                    
                }
            }
        }
        attachKeyboardHideEvent(editor);
    
        $toolbar.controlgroup();

        // If the page is visible, create the iframe and resize the controls. Otherwise
        // wait until the page becomes visible with pageshow above.
        if ($(editor.page).is(':visible')) {
            refresh(editor);
        }
        
        $(editor.page).on("hxLayoutDone." + editor.name, function() {
            refresh(editor);
            editor.$toolbar.find('a[data-role="button"]').addClass("ui-disabled");
        });
                
        var eventName = "orientationchange." + editor.name;
        $(document).off(eventName).on(eventName, function() {
            if (editor.$main.is(':visible')) {
                refresh(editor);
            }
        });

        $(editor.$parent).on("remove", function() {
            editor.destroy();
        });

        // Save this object int the widget var in the global scope, if one is supplied.
        if (options.widget) {
            window[options.widget] = editor;
        }
        
        editor.nextAction = null;
    };

    //===============
    // Public Methods
    //===============

    var fn = cleditor.prototype,

    // Expose the following private functions as methods on the cleditor object.
    // The closure compiler will rename the private functions. However, the
    // exposed method names on the cleditor object will remain fixed.
    methods = [
    ["clear", clear],
    ["disable", disable],
    ["execCommand", execCommand],
    ["focus", focus],
    ["hidePopups", hidePopups],
    ["sourceMode", sourceMode, true],
    ["refresh", refresh],
    ["select", select],
    ["selectedHTML", selectedHTML, true],
    ["selectedText", selectedText, true],
    ["updateFrame", updateFrame],
    ["updateTextArea", updateTextArea],
    ["update", update],
    ["getHTML", getHTML],
    ["destroy", destroy],
    ["adjustHeight", adjustHeight]
    ];

    $.each(methods, function(idx, method) {
        fn[method[0]] = function() {
            var editor = this, args = [editor];
            // using each here would cast booleans into objects!
            for(var x = 0; x < arguments.length; x++) {
                args.push(arguments[x]);
            }
            var result = method[1].apply(editor, args);
            if (method[2]) return result;
            return editor;
        };
    });

    // change - shortcut for .bind("change", handler) or .trigger("change")
    fn.change = function(handler) {
        var $this = $(this);
        return handler ? $this.bind(CHANGE, handler) : $this.trigger(CHANGE);
    };

    //===============
    // Event Handlers
    //===============

    // buttonClick - click event handler for toolbar buttons
    function buttonClick(e) {
        e.preventDefault();
        e.stopImmediatePropagation();

        // note that data is attached to the enclosing li in the context menu, not
        // to the inner a tag, which may be the event target depending on where the 
        // user taps.
        var editor = this,
        buttonDiv = $(e.target).closest("li"),
        buttonName = buttonDiv.data(BUTTON_NAME),
        button = buttons[buttonName],
        menu = button.menu,
        value = buttonDiv.data(BUTTON_VALUE);

        // Fire the buttonClick event
        var data = {
            editor: editor,
            button: buttonDiv,
            buttonName: buttonName,
            value: value,
            command: button.command,
            useCSS: editor.options.useCSS
        };

        editor.nextAction = function() {
            if (button.buttonClick && button.buttonClick(e, data) === false)
                return;

            // All other buttons
            if (!execCommand(editor, data.command, data.value, data.useCSS, button)) {
                return;
            }
        };

        menu.popup("close");
        return true;
    }

    // popupClick - click event handler for popup items
    function popupClick(e) {
        var editor = this,
        buttonName = e.data.buttonName,
        value = e.data.value,
        command = e.data.command;
        var menu = e.data.menu;


        // Get the button info
        var button = buttons[buttonName],
        useCSS = editor.options.useCSS;

        // Fire the popupClick event
        var data = {
            editor: editor,
            buttonName: buttonName,
            command: command,
            value: value,
            useCSS: useCSS
        };
        
        editor.nextAction = function() {
            if (button.popupClick && button.popupClick(e, data) === false)
                return;
    
            // Execute the command
            if (data.command && !execCommand(editor, data.command, data.value, data.useCSS, button))
                return;
        };
        $(menu).popup("close");
    }

    //==================
    // Private Functions
    //==================
    
    function attachKeyboardHideEvent(editor) {
        $(document).on('keyboardHide', function() {
            if (!editor.$main.is(':visible')) {
                // This handler catches all keyboard hide events - even those that occur on a completely
                // different jQM page.
                return;
            }
            
            clearTimeout(editor.changeTimeout);
            editor.changeTimeout = null;
            updateTextArea(editor, true);
            editor.$toolbarEnabled = false;
            editor.popupOpen = false;
            for (var menuName in editor.menuPopups) {
                var editorName = '#' + menuName + "_" + editor.name;
                $(editorName).popup("close");
            }
            editor.$toolbar.find('a[data-role="button"]').addClass("ui-disabled");
        });
    }
    
    function createPopupMenu(menuName, buttonText, $parent, $toolbar, menuOptions, doMini) {
        var editor = this;
        var $popup = this.menuPopups[menuName] = $(DIV_TAG)
            .attr({
                'id' : menuName + "_" + editor.name,
                'style' : 'max-height: 200px; overflow-y: scroll'
            }).appendTo($parent);
            
        var $menu = this.menus[menuName] = $(UL_TAG).attr({
            'data-role' : 'listview',
            'data-inset' : 'true',
            'style' : 'min-width:210px;',
            'data-theme' : 'b'
        }).appendTo($popup);
        $.each(menuOptions.split(" "), function(idx, buttonName) {
            addButtonToMenu(editor, $menu, $popup, buttonName, menuName);
        });
        
        var $button = this.menuToolbar[menuName] = $(A_TAG)
        .attr({
            'href' : 'javascript:void(0)',
            'data-role' : "button",
            'data-theme' : "a",
            'data-mini' : doMini,
            'class' : 'ui-disabled'
        }).append(buttonText)
        .appendTo($toolbar)
        .on(CLICK, function() {
            $popup.popup("open", { positionTo: $button });
            return false;
        });
    }
    
    // checksum - returns a checksum using the Adler-32 method
    function checksum(text)
    {
        var a = 1, b = 0;
        for (var index = 0; index < text.length; ++index) {
            a = (a + text.charCodeAt(index)) % 65521;
            b = (b + a) % 65521;
        }
        return (b << 16) | a;
    }

    // clear - clears the contents of the editor
    function clear(editor) {
        editor.$area.val("");
        updateFrame(editor);
    }
    
    function update(editor, val) {
        editor.$area.val(val);
        refresh(editor);
    }

    // disable - enables or disables the editor
    function disable(editor, disabled) {

        // Update the textarea and save the state
        if (disabled) {
            editor.$area.attr(DISABLED, DISABLED);
            editor.disabled = true;
        }
        else {
            editor.$area.removeAttr(DISABLED);
            delete editor.disabled;
        }

        // Switch the iframe into design mode.
        try {
            editor.doc.designMode = !disabled ? "on" : "off"; 
        }
        // Firefox 1.5 throws an exception that can be ignored
        // when toggling designMode from off to on.
        catch (err) {}
    }

    // execCommand - executes a designMode command
    function execCommand(editor, command, value, useCSS, button) {
        if (command === 'removeformat' && selectionIsEmpty(editor)) {
            Helix.Utils.statusMessage("Remove Format", "The remove format command removes formatting from selected text. You must select text to use this command.", "info");
            return true;
        }
        if (command === 'createlink' && selectionIsEmpty(editor)) {
            Helix.Utils.statusMessage("Create Link", "The create link command turns the selected text into a hyperlink. You must select text to use this command.", "info");
            return true;
        }
        
        editor.$frame[0].contentWindow.focus();
        
        // Set the styling method
        if (useCSS === undefined || useCSS === null)
            useCSS = editor.options.useCSS;
        editor.doc.execCommand("styleWithCSS", 0, useCSS.toString());

        // Execute the command and check for error
        var success = true, description;
        try {
            success = editor.doc.execCommand(command, 0, value || null);
            if (success && (button.type == "font" || button.type == "style" || button.type == 'color')) {
                if (button.type === "font") {
                    editor.currentFont = value;
                    editor.$formatFrame.css('font-family', value);
                    
                    // When we set the font we must restore all styles. Only on iOS.
                    /*if (Helix.browser === 'iOS') {
                        for (var styleKey in editor.currentStyles) {
                            editor.doc.execCommand(styleKey, 0, null);
                        }
                    }*/
                } else if (button.type === "style") {
                    var styleToToggle = 'ui-editor-' + command;
                    editor.$formatFrame.toggleClass(styleToToggle);
                    // iOS bug - if you change the style after you set the font, sometimes the font is
                    // lost.
                    if (editor.currentFont) {
                        editor.doc.execCommand("fontname", 0, editor.currentFont);
                    }
                    // Track the current style.
                    if (command in editor.currentStyles) {
                        delete editor.currentStyles[command];
                    } else {
                        editor.currentStyles[command] = true;
                    }
                } else {
                    if (command === "forecolor") {
                        editor.$formatFrame.css('color', value);
                    } else if (command === "hilitecolor") {
                        editor.$formatFrame.css('background-color', value);
                    }
                }
            }
        } catch (err) {
            description = err.description;
            success = false;
        }
        if (!success) {
            if (!description) {
                description = "browser error."
            }
            Helix.Utils.statusMessage("Error", "Error executing the " + command + " command: " + description, "error");
        }

        return success;
    }

    function selectionIsEmpty(editor) {
        var selection = getSelection(editor);
        if (selection.rangeCount == 0) {
            return true;
        }
        var range = selection.getRangeAt(0);
        if (range.collapsed) {
            return true;
        }
        
        return false;
    }

    function selectText(window,doc,textElement) {
        var range, selection
        ;    
        if (doc.body.createTextRange) { //ms
            range = doc.body.createTextRange();
            range.moveToElementText(textElement);
            range.select();
        } else if (window.getSelection) { //all others
            selection = window.getSelection();        
            range = doc.createRange();
            range.selectNodeContents(textElement);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }

    // focus - sets focus to either the textarea or iframe
    function focus(editor, oncomplete) {
        if (!$(editor.page).is(':visible')) {
            // When the page is invisible we do not put the focus in the editor ...
            return;
        }
        setTimeout(function() {
            if (sourceMode(editor)) {
                editor.$area.focus();
            } else {
                if (editor.$frame) {
                    setTimeout(function() {
                        editor.$frame[0].contentWindow.focus();
                        if (oncomplete) {
                            oncomplete();
                        }
                        //editor.doc.body.click();    
                    }, 70);
                }
            }
        }, 0);
    }

    // getRange - gets the current text range object
    function getRange(editor) {
        return getSelection(editor).getRangeAt(0);
    }

    // getSelection - gets the current text range object
    function getSelection(editor) {
        return editor.$frame[0].contentWindow.getSelection();
    }

    // Returns the hex value for the passed in string.
    //   hex("rgb(255, 0, 0)"); // #FF0000
    //   hex("#FF0000"); // #FF0000
    //   hex("#F00"); // #FF0000
    function hex(s) {
        var m = /rgba?\((\d+), (\d+), (\d+)/.exec(s),
        c = s.split("");
        if (m) {
            s = ( m[1] << 16 | m[2] << 8 | m[3] ).toString(16);
            while (s.length < 6)
                s = "0" + s;
        }
        return "#" + (s.length == 6 ? s : c[1] + c[1] + c[2] + c[2] + c[3] + c[3]);
    }

    // hidePopups - hides all popups
    function hidePopups() {
        $.each(popups, function(idx, popup) {
            $(popup)
            .hide()
            .unbind(CLICK)
            .removeData(BUTTON);
        });
    }

    // imagesPath - returns the path to the images folder
    function imagesPath() {
        var cssFile = "jquery.cleditor.css",
        href = $("link[href$='" + cssFile +"']").attr("href");
        return href.substr(0, href.length - cssFile.length) + "images/";
    }

    // imageUrl - Returns the css url string for a filemane
    function imageUrl(filename) {
        return "url(" + imagesPath() + filename + ")";
    }

    // adjustHeight - changes the height of the editor.
    function adjustHeight(editor, hgt) {
        editor.options.height = hgt;
        editor.$parent.height(hgt);
        editor.$main.height(hgt);
        
        // Update hgt to account for the toolbar and the format frame.
        hgt -= editor.$toolbar.outerHeight(true);        
        hgt -= 25;
        
        editor.$frameMaster.height(hgt);
    }

    // refresh - creates the iframe and resizes the controls
    function refresh(editor) {
        var $contentParent = $(editor.$main).closest(".hx-main-content");
        if (editor.options.isFullWidth) {
            // Figure out the width available to the enclosing page tag.
            editor.options.width = $contentParent[0].clientWidth;
        }
        if (editor.options.isFullHeight) {
            var fullHeight = $contentParent.height()- 
                ($(editor.$main).offset().top - 
                    $contentParent.offset().top);
            editor.options.height = fullHeight;
        }


        var $main = editor.$main,
        options = editor.options;

        var $formatFrame = null;
        if (editor.$formatFrame) {
            $formatFrame = editor.$formatFrame;
        } else {
            $formatFrame = editor.$formatFrame = 
                $('<div/>').append("Current Text Format").addClass("ui-editor-format").hide().appendTo($main);
        }

        var frameMasterID = Helix.Utils.getUniqueID();
        var $frameMaster = null;
        if (editor.$frameMaster) {
            $frameMaster = editor.$frameMaster;
        } else {
            $frameMaster = editor.$frameMaster = $('<div/>')
                .attr('id', frameMasterID)
                .css('overflow-y', 'scroll')
                .css('-webkit-overflow-scrolling', 'touch')
                .appendTo($main);
        }
            
        // Set the height/width of the frame master before we load the iFrame.
        var hgt = options.height;
        adjustHeight(editor, hgt);
        
        // Set the width;
        // Resize the main div (which includes the toolbar).
        $main.width(options.width);
        $frameMaster.width("100%");
        $formatFrame.width("100%");
        
        var $frame = null;
        if (editor.$frame) {
            $frame = editor.$frame;
        } else {
            var frameID = Helix.Utils.getUniqueID();
            var iframeMarkup =
                '<iframe style="margin-bottom: 5px;" src="javascript:true;"' +
                ' tabindex="' + options.tabIndex + '"' +
                ' id="' + frameID + '"' +
                ' onload="Helix.Utils.sizeIFrameToFit(\'' + frameID + '\', \'' + frameMasterID + '\')"' +
                '>';
            
            $frame = editor.$frame = $(iframeMarkup)
                .hide()
                .appendTo($frameMaster);
        }
                
        // Load the iframe document content
        var contentWindow = $frame[0].contentWindow,
        doc = editor.doc = contentWindow.document,
        $doc = $(doc);

        doc.open();
        doc.write(
            options.docType +
            '<html>' +
            '<head>' +
            '<style> div { width: 100%; } </style>' +
            '<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />' + 
            ((options.docCSSFile === '') ? '' : '<link rel="stylesheet" type="text/css" href="' + options.docCSSFile + '" />') +
            '</head>' +
            '<body style="' + options.bodyStyle + '"></body></html>'
            );
        doc.close();

        // Load the content
        updateFrame(editor);

        // Update the textarea when the iframe changes. But wait until the typist has stopped
        // before we do this update.
        $doc.find('body').on('keyup', function(e) {
            if (editor.changeTimeout) {
                clearTimeout(editor.changeTimeout);
                editor.changeTimeout = null;
            }
            editor.changeTimeout = setTimeout(function() {
                updateTextArea(editor, true);
            }, 500);
            e.preventDefault();
            e.stopImmediatePropagation();
        });
        // This code resolves the case where after the iOS select menu appears the iframe seems
        // to lose focus. Thereafter if the user tries to type nothing happens. This is very 
        // glitchy from the user's perspective. This helps. The only remaining glitchy behavior
        // is navigation when the user taps in the iframe. Tapping outside of any text seems to do
        // nothing of value.
        $doc.find('body').on('keydown', function(e) {
            setTimeout(function() {
                editor.$frame[0].contentWindow.focus();
            }, 100);
        });
        $doc.find('body').focus(function(e) {
            editor.$toolbar.find('a[data-role="button"]').removeClass("ui-disabled");
            editor.$toolbarEnabled = true;
            return false;
        });
        if (Helix.hasTouch) {
            $doc.find('body').blur(function(e) {
                editor.$toolbar.find('a[data-role="button"]').addClass("ui-disabled");
                editor.$toolbarEnabled = false;
            });
        }
        $doc.width("100%");
        
        // NOTE: we require that the browser supports iFrame design mode. Otherwise
        // this plugin will fail.
        $frame.show();
        $formatFrame.show();

        // Switch the iframe into design mode if enabled
        disable(editor, editor.disabled);
    
        // Put the focus on the editor. Otherwise when we try to tap it does not work.
        //focus(editor); 
        //editor.$toolbar.find('a[data-role="button"]').button("disable");
        editor.$toolbarEnabled = false;
    }

    // select - selects all the text in either the textarea or iframe
    function select(editor) {
        setTimeout(function() {
            if (sourceMode(editor)) editor.$area.select();
            else execCommand(editor, "selectall");
        }, 0);
    }

    // selectedHTML - returns the current HTML selection or and empty string
    function selectedHTML(editor) {
        var range = getRange(editor);
        var layer = $("<layer>")[0];
        layer.appendChild(range.cloneContents());
        var html = layer.innerHTML;
        layer = null;
        return html;
    }

    // selectedText - returns the current text selection or and empty string
    function selectedText(editor) {
        return getSelection(editor).toString();
    }

    function capitalizeFirstLetter(string)
    {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    // Add a button to a popup menu.
    function addButtonToMenu(editor, popupMenu, menu, buttonName, buttonType) {
        if (buttonName === "") return;

        // Divider
        if (buttonName == "|") {

            // Add a new divider to the group
            var $div = $(LI_TAG)
            .attr({
                'data-role' : 'divider',
                'data-theme' : 'a' 
            })
            .appendTo(popupMenu);
        }

        // Button
        else {
            // Get the button definition
            var button = buttons[buttonName];
            button.type = buttonType;
            button.menu = menu;

            if (editor.options[button.name]) {
                var list = null;
                var renderOption = null;
                list = editor.options[button.name];
                
                if (button.name === 'font') {
                    renderOption = function(buttonDiv, font) {
                        buttonDiv
                        .append($('<font />').attr({
                            'face' : font
                        })
                        .append(font));
                    }
                }
                
                $.each(list.split(","), function(idx, val) {
                    var $linkDiv = $(A_TAG)
                        .attr({
                            'href' : 'javascript:void(0);',
                            'data-button' : buttonName
                        });
                    var $buttonDiv = $(LI_TAG).append($linkDiv).appendTo(popupMenu);
                    renderOption($linkDiv, val);
                    $buttonDiv.on(CLICK, $.proxy(buttonClick, editor));
                    $buttonDiv.data(BUTTON_NAME, buttonName);
                    $buttonDiv.data(BUTTON_VALUE, val);
                }); 
            } else if (button.name === 'color' || button.name === 'highlight') {
                $(DIV_TAG).attr({
                    'class' : 'ui-color-picker',
                    'style' : 'width: 100%;'
                }).appendTo(popupMenu).append(button.title);
                var colorInput = $('<input/>').appendTo(popupMenu)
                .attr({
                    'data-command' : button.command
                })
                .spectrum({
                    color: 'black',
                    change: function(color) {
                        popupClick.call(editor, {
                            target: colorInput, 
                            data : { 
                                buttonName: button.name,
                                command: button.command,
                                value: color.toHexString(),
                                menu: menu
                            } 
                        });
                    }
                })
                
                $(document).on('keyboardHide', function() {
                    colorInput.spectrum("hide");
                });
                var restoreColor = '#000000';
                if (button.name === 'highlight') {
                    restoreColor = '#FFFFFF';
                }
                
                $(A_TAG).attr({
                    'href' : 'javascript:void(0);'
                })
                .append('Clear ' + capitalizeFirstLetter(button.name))
                .appendTo(popupMenu).buttonMarkup({
                    mini: true
                }).on(CLICK, function(ev) {
                    $('input[data-command="' + button.command + '"]').spectrum("set", restoreColor);
                    popupClick.call(editor, {
                        target: colorInput, 
                        data : { 
                            buttonName: button.name,
                            command: button.command,
                            value: restoreColor,
                            menu: menu
                        } 
                    });
                    return false;
                });
            } else {

        
                // Add a new button to the group
                var $buttonDiv = $(LI_TAG).append(
                    $(A_TAG)
                    .attr({
                        'href' : 'javascript:void(0);',
                        'data-button' : buttonName
                    }).append(button.title)
                    ).appendTo(popupMenu);
                $buttonDiv.on(CLICK, $.proxy(buttonClick, editor));
                $buttonDiv.data(BUTTON_NAME, buttonName);
                if (button.data) {
                    $buttonDiv.data(BUTTON_VALUE, button.data);
                }

                // Prepare the button image
                var map = {};
                if (button.css) map = button.css;
                else if (button.image) map.backgroundImage = imageUrl(button.image);
                if (button.stripIndex) map.backgroundPosition = button.stripIndex * -24;
                button.onCSS = map;
            }
        }
    }

    // sourceMode - returns true if the textarea is showing
    function sourceMode(editor) {
        return editor.$area.is(":visible");
    }

    // updateFrame - updates the iframe with the textarea contents
    function updateFrame(editor, checkForChange) {
        if (!editor.doc) {
            // Have not rendered the iframe yet ...
            return;
        }


        var code = editor.$area.val(),
        options = editor.options,
        updateFrameCallback = options.updateFrame,
        $body = $(editor.doc.body);

        // Check for textarea change to avoid unnecessary firing
        // of potentially heavy updateFrame callbacks.
        if (updateFrameCallback) {
            var sum = checksum(code);
            if (checkForChange && editor.areaChecksum == sum)
                return;
            editor.areaChecksum = sum;
        }

        // Convert the textarea source code into iframe html
        var html = updateFrameCallback ? updateFrameCallback(code) : code;
        if (!html) {
            html = "<br>";
        } else {
            // Prevent script injection attacks by html encoding script tags
            html = html.replace(/<(?=\/?script)/ig, "&lt;");
        }

        // Update the iframe checksum
        if (options.updateTextArea)
            editor.frameChecksum = checksum(html);

        // Update the iframe and trigger the change event
        if (html != $body.html()) {
            $body.html(html);
            $(editor).triggerHandler(CHANGE);
        }

    }

    // updateTextArea - updates the textarea with the iframe contents
    function updateTextArea(editor, checkForChange) {

        var html = $(editor.doc.documentElement).html(),
        options = editor.options,
        updateTextAreaCallback = options.updateTextArea,
        $area = editor.$area;

        // Check for iframe change to avoid unnecessary firing
        // of potentially heavy updateTextArea callbacks.
        if (updateTextAreaCallback) {
            var sum = checksum(html);
            if (checkForChange && editor.frameChecksum == sum)
                return;
            editor.frameChecksum = sum;
        }

        // Convert the iframe html into textarea source code
        var code = updateTextAreaCallback ? updateTextAreaCallback(html) : html;

        // Update the textarea checksum
        if (options.updateFrame)
            editor.areaChecksum = checksum(code);

        // Update the textarea and trigger the change event
        if (code != $area.val()) {
            $area.val(code);
            $(editor).triggerHandler(CHANGE);
        }

    }

    function selectAll() {
        this.select();
    }

    function getHTML() {
        return this.doc.body.innerHTML;
    }

    function destroy() {
        /* Remove the popup menus from the DOM. */
        $(this.$fontMenu).closest(".ui-popup-container").prev().remove();
        $(this.$fontMenu).closest(".ui-popup-container").remove();
        $(this.$styleMenu).closest(".ui-popup-container").prev().remove();
        $(this.$styleMenu).closest(".ui-popup-container").remove();
        $(this.$formatMenu).closest(".ui-popup-container").prev().remove();
        $(this.$formatMenu).closest(".ui-popup-container").remove();
        $(this.$actionMenu).closest(".ui-popup-container").prev().remove();
        $(this.$actionMenu).closest(".ui-popup-container").remove();
    
        /* Stop listening ... */
        $(this.page).off("hxLayoutDone." + this.name);
        $(document).off("orientationchange." + this.name);
    }
})(jQuery);;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: specific components licensed under different terms will be noted accordingly
 * in the comments immediately preceding those components.
 */

/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix)
 *   length - the desired number of characters
 *   radix  - the number of allowable values for each character.
 *
 * EXAMPLES:
 *   // No arguments  - returns RFC4122, version 4 ID
 *   >>> Math.uuid()
 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
 *
 *   // One argument - returns ID of the specified length
 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
 *   "VcydxgltxrVZSTV"
 *
 *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)
 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
 *   "01001010"
 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
 *   "47473046"
 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
 *   "098F4D35"
 */
(function() {
  // Private array of chars to use
  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

  Math.uuid = function (len, radix) {
    var chars = CHARS, uuid = [], i;
    radix = radix || chars.length;

    if (len) {
      // Compact form
      for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
    } else {
      // rfc4122, version 4 form
      var r;

      // rfc4122 requires these characters
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
      uuid[14] = '4';

      // Fill in random data.  At i==19 set the high bits of clock sequence as
      // per rfc4122, sec. 4.1.5
      for (i = 0; i < 36; i++) {
        if (!uuid[i]) {
          r = 0 | Math.random()*16;
          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
        }
      }
    }

    return uuid.join('');
  };

  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance
  // by minimizing calls to random()
  Math.uuidFast = function() {
    var chars = CHARS, uuid = new Array(36), rnd=0, r;
    for (var i = 0; i < 36; i++) {
      if (i==8 || i==13 ||  i==18 || i==23) {
        uuid[i] = '-';
      } else if (i==14) {
        uuid[i] = '4';
      } else {
        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
        r = rnd & 0xf;
        rnd = rnd >> 4;
        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
      }
    }
    return uuid.join('');
  };

  // A more compact, but less performant, RFC4122v4 solution:
  Math.uuidCompact = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    });
  };
})();
;/*
 * Purl (A JavaScript URL parser) v2.3.1
 * Developed and maintanined by Mark Perkins, mark@allmarkedup.com
 * Source repository: https://github.com/allmarkedup/jQuery-URL-Parser
 * Licensed under an MIT-style license. See https://github.com/allmarkedup/jQuery-URL-Parser/blob/master/LICENSE for details.
 */

;(function(factory) {
    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        window.purl = factory();
    }
})(function() {

    var tag2attr = {
            a       : 'href',
            img     : 'src',
            form    : 'action',
            base    : 'href',
            script  : 'src',
            iframe  : 'src',
            link    : 'href'
        },

        key = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'fragment'], // keys available to query

        aliases = { 'anchor' : 'fragment' }, // aliases for backwards compatability

        parser = {
            strict : /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,  //less intuitive, more accurate to the specs
            loose :  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ // more intuitive, fails on relative paths and deviates from specs
        },

        isint = /^[0-9]+$/;

    function parseUri( url, strictMode ) {
        var str = decodeURI( url ),
        res   = parser[ strictMode || false ? 'strict' : 'loose' ].exec( str ),
        uri = { attr : {}, param : {}, seg : {} },
        i   = 14;

        while ( i-- ) {
            uri.attr[ key[i] ] = res[i] || '';
        }

        // build query and fragment parameters
        uri.param['query'] = parseString(uri.attr['query']);
        uri.param['fragment'] = parseString(uri.attr['fragment']);

        // split path and fragement into segments
        uri.seg['path'] = uri.attr.path.replace(/^\/+|\/+$/g,'').split('/');
        uri.seg['fragment'] = uri.attr.fragment.replace(/^\/+|\/+$/g,'').split('/');

        // compile a 'base' domain attribute
        uri.attr['base'] = uri.attr.host ? (uri.attr.protocol ?  uri.attr.protocol+'://'+uri.attr.host : uri.attr.host) + (uri.attr.port ? ':'+uri.attr.port : '') : '';

        return uri;
    }

    function getAttrName( elm ) {
        var tn = elm.tagName;
        if ( typeof tn !== 'undefined' ) return tag2attr[tn.toLowerCase()];
        return tn;
    }

    function promote(parent, key) {
        if (parent[key].length === 0) return parent[key] = {};
        var t = {};
        for (var i in parent[key]) t[i] = parent[key][i];
        parent[key] = t;
        return t;
    }

    function parse(parts, parent, key, val) {
        var part = parts.shift();
        if (!part) {
            if (isArray(parent[key])) {
                parent[key].push(val);
            } else if ('object' == typeof parent[key]) {
                parent[key] = val;
            } else if ('undefined' == typeof parent[key]) {
                parent[key] = val;
            } else {
                parent[key] = [parent[key], val];
            }
        } else {
            var obj = parent[key] = parent[key] || [];
            if (']' == part) {
                if (isArray(obj)) {
                    if ('' !== val) obj.push(val);
                } else if ('object' == typeof obj) {
                    obj[keys(obj).length] = val;
                } else {
                    obj = parent[key] = [parent[key], val];
                }
            } else if (~part.indexOf(']')) {
                part = part.substr(0, part.length - 1);
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
                // key
            } else {
                if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
                parse(parts, obj, part, val);
            }
        }
    }

    function merge(parent, key, val) {
        if (~key.indexOf(']')) {
            var parts = key.split('[');
            parse(parts, parent, 'base', val);
        } else {
            if (!isint.test(key) && isArray(parent.base)) {
                var t = {};
                for (var k in parent.base) t[k] = parent.base[k];
                parent.base = t;
            }
            if (key !== '') {
                set(parent.base, key, val);
            }
        }
        return parent;
    }

    function parseString(str) {
        return reduce(String(str).split(/&|;/), function(ret, pair) {
            try {
                pair = decodeURIComponent(pair.replace(/\+/g, ' '));
            } catch(e) {
                // ignore
            }
            var eql = pair.indexOf('='),
                brace = lastBraceInKey(pair),
                key = pair.substr(0, brace || eql),
                val = pair.substr(brace || eql, pair.length);

            val = val.substr(val.indexOf('=') + 1, val.length);

            if (key === '') {
                key = pair;
                val = '';
            }

            return merge(ret, key, val);
        }, { base: {} }).base;
    }

    function set(obj, key, val) {
        var v = obj[key];
        if (typeof v === 'undefined') {
            obj[key] = val;
        } else if (isArray(v)) {
            v.push(val);
        } else {
            obj[key] = [v, val];
        }
    }

    function lastBraceInKey(str) {
        var len = str.length,
            brace,
            c;
        for (var i = 0; i < len; ++i) {
            c = str[i];
            if (']' == c) brace = false;
            if ('[' == c) brace = true;
            if ('=' == c && !brace) return i;
        }
    }

    function reduce(obj, accumulator){
        var i = 0,
            l = obj.length >> 0,
            curr = arguments[2];
        while (i < l) {
            if (i in obj) curr = accumulator.call(undefined, curr, obj[i], i, obj);
            ++i;
        }
        return curr;
    }

    function isArray(vArg) {
        return Object.prototype.toString.call(vArg) === "[object Array]";
    }

    function keys(obj) {
        var key_array = [];
        for ( var prop in obj ) {
            if ( obj.hasOwnProperty(prop) ) key_array.push(prop);
        }
        return key_array;
    }

    function purl( url, strictMode ) {
        if ( arguments.length === 1 && url === true ) {
            strictMode = true;
            url = undefined;
        }
        strictMode = strictMode || false;
        url = url || window.location.toString();

        return {

            data : parseUri(url, strictMode),

            // get various attributes from the URI
            attr : function( attr ) {
                attr = aliases[attr] || attr;
                return typeof attr !== 'undefined' ? this.data.attr[attr] : this.data.attr;
            },

            // return query string parameters
            param : function( param ) {
                return typeof param !== 'undefined' ? this.data.param.query[param] : this.data.param.query;
            },

            // return fragment parameters
            fparam : function( param ) {
                return typeof param !== 'undefined' ? this.data.param.fragment[param] : this.data.param.fragment;
            },

            // return path segments
            segment : function( seg ) {
                if ( typeof seg === 'undefined' ) {
                    return this.data.seg.path;
                } else {
                    seg = seg < 0 ? this.data.seg.path.length + seg : seg - 1; // negative segments count from the end
                    return this.data.seg.path[seg];
                }
            },

            // return fragment segments
            fsegment : function( seg ) {
                if ( typeof seg === 'undefined' ) {
                    return this.data.seg.fragment;
                } else {
                    seg = seg < 0 ? this.data.seg.fragment.length + seg : seg - 1; // negative segments count from the end
                    return this.data.seg.fragment[seg];
                }
            }

        };

    }
    
    purl.jQuery = function($){
        if ($ != null) {
            $.fn.url = function( strictMode ) {
                var url = '';
                if ( this.length ) {
                    url = $(this).attr( getAttrName(this[0]) ) || '';
                }
                return purl( url, strictMode );
            };

            $.url = purl;
        }
    };

    purl.jQuery(window.jQuery);

    return purl;

});
;/* 
 * Simple class for storing a list of hints that should be displayed for the user
 * exactly once. The actual hint messages need not be stored in the local DB. What
 * we are really tracking is whether or not the hint has been shown. This class cannot
 * be used until the Link DB is in a ready state.
 */

/**
 * Init the HelixHints infrastructure. The input params are a list of hint objects, each of which
 * has a unique ID and a message, and a completion function. This function is asynchronous b/c
 * it must determine from the DB if the hints have been shown or not.
 */
function HelixHints(hints, oncomplete) {
    this._hints = {};
    for (var i = 0; i < hints.length; ++i) {
        var nxt = hints[i];
        this._hints[nxt.id] = { msg: nxt.msg,
            isShown: false,
            dbObj : null
        };
    }
    
    // Sync to the DB.
    this._schema = persistence.define('HelixHints', {
        isShown: "INT",
        hintTag: "TEXT"
    });
    var _self = this;
    persistence.schemaSync(function(tx) {   
        _self._schema.all().newEach({
            eachFn: function(row) {
                var hintObj = _self._hints[row.hintTag];
                if (hintObj) {
                    hintObj.dbObj = row;
                    hintObj.isShown = (row.isShown ? true : false);
                } else {
                    persistence.remove(row);
                }
            },
            doneFn: function() {
                var didAdd = false;
                for (var hintKey in _self._hints) {
                    var hintObj = _self._hints[hintKey];
                    if (!hintObj.dbObj) {
                        hintObj.dbObj = new _self._schema({
                            isShown : 0,
                            hintTag: hintKey
                        });
                        persistence.add(hintObj.dbObj);
                        didAdd = true;
                    }
                }
                if (didAdd) {
                    persistence.flush(function() {
                        oncomplete();
                    });
                } else {
                    oncomplete();
                }
            }
        });
    });
}

HelixHints.prototype.showHint = function(hintID) {
    // Check to see if the hint ID exists and is present.
    var hint = this._hints[hintID];
    if (hint && !hint.isShown) {
        Helix.Utils.statusMessage("Hint", hint.msg, "info");
        hint.dbObj.isShown = 1;
        hint.isShown = true;
        persistence.flush();
    }
};;/**
 * @version: 1.0 Alpha-1
 * @author: Coolite Inc. http://www.coolite.com/
 * @date: 2008-05-13
 * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * @website: http://www.datejs.com/
 */
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,p=function(s,l){if(!l){l=2;}
return("000"+s).slice(l*-1);};$P.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};$P.setTimeToNow=function(){var n=new Date();this.setHours(n.getHours());this.setMinutes(n.getMinutes());this.setSeconds(n.getSeconds());this.setMilliseconds(n.getMilliseconds());return this;};$D.today=function(){return new Date().clearTime();};$D.compare=function(date1,date2){if(isNaN(date1)||isNaN(date2)){throw new Error(date1+" - "+date2);}else if(date1 instanceof Date&&date2 instanceof Date){return(date1<date2)?-1:(date1>date2)?1:0;}else{throw new TypeError(date1+" - "+date2);}};$D.equals=function(date1,date2){return(date1.compareTo(date2)===0);};$D.getDayNumberFromName=function(name){var n=$C.dayNames,m=$C.abbreviatedDayNames,o=$C.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s||o[i].toLowerCase()==s){return i;}}
return-1;};$D.getMonthNumberFromName=function(name){var n=$C.monthNames,m=$C.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};$D.isLeapYear=function(year){return((year%4===0&&year%100!==0)||year%400===0);};$D.getDaysInMonth=function(year,month){return[31,($D.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};$D.getTimezoneAbbreviation=function(offset){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].offset===offset){return z[i].name;}}
return null;};$D.getTimezoneOffset=function(name){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].name===name.toUpperCase()){return z[i].offset;}}
return null;};$P.clone=function(){return new Date(this.getTime());};$P.compareTo=function(date){return Date.compare(this,date);};$P.equals=function(date){return Date.equals(this,date||new Date());};$P.between=function(start,end){return this.getTime()>=start.getTime()&&this.getTime()<=end.getTime();};$P.isAfter=function(date){return this.compareTo(date||new Date())===1;};$P.isBefore=function(date){return(this.compareTo(date||new Date())===-1);};$P.isToday=function(){return this.isSameDay(new Date());};$P.isSameDay=function(date){return this.clone().clearTime().equals(date.clone().clearTime());};$P.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};$P.addSeconds=function(value){return this.addMilliseconds(value*1000);};$P.addMinutes=function(value){return this.addMilliseconds(value*60000);};$P.addHours=function(value){return this.addMilliseconds(value*3600000);};$P.addDays=function(value){this.setDate(this.getDate()+value);return this;};$P.addWeeks=function(value){return this.addDays(value*7);};$P.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,$D.getDaysInMonth(this.getFullYear(),this.getMonth())));return this;};$P.addYears=function(value){return this.addMonths(value*12);};$P.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
var x=config;if(x.milliseconds){this.addMilliseconds(x.milliseconds);}
if(x.seconds){this.addSeconds(x.seconds);}
if(x.minutes){this.addMinutes(x.minutes);}
if(x.hours){this.addHours(x.hours);}
if(x.weeks){this.addWeeks(x.weeks);}
if(x.months){this.addMonths(x.months);}
if(x.years){this.addYears(x.years);}
if(x.days){this.addDays(x.days);}
return this;};var $y,$m,$d;$P.getWeek=function(){var a,b,c,d,e,f,g,n,s,w;$y=(!$y)?this.getFullYear():$y;$m=(!$m)?this.getMonth()+1:$m;$d=(!$d)?this.getDate():$d;if($m<=2){a=$y-1;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=0;f=$d-1+(31*($m-1));}else{a=$y;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=s+1;f=$d+((153*($m-3)+2)/5)+58+s;}
g=(a+b)%7;d=(f+g-e)%7;n=(f+3-d)|0;if(n<0){w=53-((g-s)/5|0);}else if(n>364+s){w=1;}else{w=(n/7|0)+1;}
$y=$m=$d=null;return w;};$P.getISOWeek=function(){$y=this.getUTCFullYear();$m=this.getUTCMonth()+1;$d=this.getUTCDate();return p(this.getWeek());};$P.setWeek=function(n){return this.moveToDayOfWeek(1).addWeeks(n-this.getWeek());};$D._validate=function(n,min,max,name){if(typeof n=="undefined"){return false;}else if(typeof n!="number"){throw new TypeError(n+" is not a Number.");}else if(n<min||n>max){throw new RangeError(n+" is not a valid value for "+name+".");}
return true;};$D.validateMillisecond=function(value){return $D._validate(value,0,999,"millisecond");};$D.validateSecond=function(value){return $D._validate(value,0,59,"second");};$D.validateMinute=function(value){return $D._validate(value,0,59,"minute");};$D.validateHour=function(value){return $D._validate(value,0,23,"hour");};$D.validateDay=function(value,year,month){return $D._validate(value,1,$D.getDaysInMonth(year,month),"day");};$D.validateMonth=function(value){return $D._validate(value,0,11,"month");};$D.validateYear=function(value){return $D._validate(value,0,9999,"year");};$P.set=function(config){if($D.validateMillisecond(config.millisecond)){this.addMilliseconds(config.millisecond-this.getMilliseconds());}
if($D.validateSecond(config.second)){this.addSeconds(config.second-this.getSeconds());}
if($D.validateMinute(config.minute)){this.addMinutes(config.minute-this.getMinutes());}
if($D.validateHour(config.hour)){this.addHours(config.hour-this.getHours());}
if($D.validateMonth(config.month)){this.addMonths(config.month-this.getMonth());}
if($D.validateYear(config.year)){this.addYears(config.year-this.getFullYear());}
if($D.validateDay(config.day,this.getFullYear(),this.getMonth())){this.addDays(config.day-this.getDate());}
if(config.timezone){this.setTimezone(config.timezone);}
if(config.timezoneOffset){this.setTimezoneOffset(config.timezoneOffset);}
if(config.week&&$D._validate(config.week,0,53,"week")){this.setWeek(config.week);}
return this;};$P.moveToFirstDayOfMonth=function(){return this.set({day:1});};$P.moveToLastDayOfMonth=function(){return this.set({day:$D.getDaysInMonth(this.getFullYear(),this.getMonth())});};$P.moveToNthOccurrence=function(dayOfWeek,occurrence){var shift=0;if(occurrence>0){shift=occurrence-1;}
else if(occurrence===-1){this.moveToLastDayOfMonth();if(this.getDay()!==dayOfWeek){this.moveToDayOfWeek(dayOfWeek,-1);}
return this;}
return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek,+1).addWeeks(shift);};$P.moveToDayOfWeek=function(dayOfWeek,orient){var diff=(dayOfWeek-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};$P.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};$P.getOrdinalNumber=function(){return Math.ceil((this.clone().clearTime()-new Date(this.getFullYear(),0,1))/86400000)+1;};$P.getTimezone=function(){return $D.getTimezoneAbbreviation(this.getUTCOffset());};$P.setTimezoneOffset=function(offset){var here=this.getTimezoneOffset(),there=Number(offset)*-6/10;return this.addMinutes(there-here);};$P.setTimezone=function(offset){return this.setTimezoneOffset($D.getTimezoneOffset(offset));};$P.hasDaylightSavingTime=function(){return(Date.today().set({month:0,day:1}).getTimezoneOffset()!==Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.isDaylightSavingTime=function(){return(this.hasDaylightSavingTime()&&new Date().getTimezoneOffset()===Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r.charAt(0)+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};$P.getElapsed=function(date){return(date||new Date())-this;};if(!$P.toISOString){$P.toISOString=function(){function f(n){return n<10?'0'+n:n;}
return'"'+this.getUTCFullYear()+'-'+
f(this.getUTCMonth()+1)+'-'+
f(this.getUTCDate())+'T'+
f(this.getUTCHours())+':'+
f(this.getUTCMinutes())+':'+
f(this.getUTCSeconds())+'Z"';};}
$P._toString=$P.toString;$P.toString=function(format){var x=this;if(format&&format.length==1){var c=$C.formatPatterns;x.t=x.toString;switch(format){case"d":return x.t(c.shortDate);case"D":return x.t(c.longDate);case"F":return x.t(c.fullDateTime);case"m":return x.t(c.monthDay);case"r":return x.t(c.rfc1123);case"s":return x.t(c.sortableDateTime);case"t":return x.t(c.shortTime);case"T":return x.t(c.longTime);case"u":return x.t(c.universalSortableDateTime);case"y":return x.t(c.yearMonth);}}
var ord=function(n){switch(n*1){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};return format?format.replace(/(\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g,function(m){if(m.charAt(0)==="\\"){return m.replace("\\","");}
x.h=x.getHours;switch(m){case"hh":return p(x.h()<13?(x.h()===0?12:x.h()):(x.h()-12));case"h":return x.h()<13?(x.h()===0?12:x.h()):(x.h()-12);case"HH":return p(x.h());case"H":return x.h();case"mm":return p(x.getMinutes());case"m":return x.getMinutes();case"ss":return p(x.getSeconds());case"s":return x.getSeconds();case"yyyy":return p(x.getFullYear(),4);case"yy":return p(x.getFullYear());case"dddd":return $C.dayNames[x.getDay()];case"ddd":return $C.abbreviatedDayNames[x.getDay()];case"dd":return p(x.getDate());case"d":return x.getDate();case"MMMM":return $C.monthNames[x.getMonth()];case"MMM":return $C.abbreviatedMonthNames[x.getMonth()];case"MM":return p((x.getMonth()+1));case"M":return x.getMonth()+1;case"t":return x.h()<12?$C.amDesignator.substring(0,1):$C.pmDesignator.substring(0,1);case"tt":return x.h()<12?$C.amDesignator:$C.pmDesignator;case"S":return ord(x.getDate());default:return m;}}):this._toString();};}());

/* SAH */
Date.prototype.stdTimezoneOffset = function() {
    var jan = new Date(this.getFullYear(), 0, 1);
    var jul = new Date(this.getFullYear(), 6, 1);
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
}

Date.prototype.dst = function() {
    return this.getTimezoneOffset() < this.stdTimezoneOffset();
};/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Implementation of WebSQL that uses Apache Cordova to access native database
 * operations that are integrated with the Mobile Helix encryption infrastructure.
 */

var MobileHelixDatabase = function() {
};

MobileHelixDatabase.queryQueue = {};

MobileHelixDatabase.createUUID = function() {
    return Math.uuid(16);
};

/**
 * SQL result set object
 * PRIVATE METHOD
 * @constructor
 */
var MobileHelixDatabase_Rows = function() {
    this.resultSet = [];    // results array
    this.length = 0;        // number of rows
};

/**
 * Get item from SQL result set
 *
 * @param row           The row number to return
 * @return              The row object
 */
MobileHelixDatabase_Rows.prototype.item = function(row) {
    return this.resultSet[row];
};

/**
 * SQL result set that is returned to user.
 * PRIVATE METHOD
 * @constructor
 */
var MobileHelixDatabase_Result = function() {
    this.rows = new MobileHelixDatabase_Rows();
};

/**
 * Callback from native code when query is complete.
 * PRIVATE METHOD
 *
 * @param query   Query object that is completing.
 * @param data Rows returned by the query
 */
function completeQuery(query, data) {
    if (query) {
        try {
            delete MobileHelixDatabase.queryQueue[query.id];

            // Get transaction
            var tx = query.tx;

            // If transaction hasn't failed
            // Note: We ignore all query results if previous query
            //       in the same transaction failed.
            if (tx && tx.queryList[query.id]) {

                // Save query results
                var r = new MobileHelixDatabase_Result();
                r.rows.resultSet = data.items;
                r.rows.length = data.length;
                try {
                    if (typeof query.successCallback === 'function') {
                        query.successCallback(query.tx, r);
                    }
                } catch (ex) {
                    console.log("executeSql error calling user success callback: "+ex);
                    throw ex;
                }

                tx.queryComplete(query.id);
            }
        } catch (e) {
            console.log("executeSql error: "+e);
            throw e;
        }
    }
}

/**
 * Callback from native code when query fails
 * PRIVATE METHOD
 *
 * @param reason            Error message
 * @param query                Query object
 */
function failQuery(reason, query) {
    if (query) {
        try {
            delete MobileHelixDatabase.queryQueue[query.id];

            // Get transaction
            var tx = query.tx;

            // If transaction hasn't failed
            // Note: We ignore all query results if previous query
            //       in the same transaction failed.
            if (tx && tx.queryList[query.id]) {
                tx.queryList = {};

                try {
                    if (typeof query.errorCallback === 'function') {
                        if (!query.errorCallback(query.tx, reason)) {
                            /* If the callback returns false, per the standard, move on. */
                            return;
                        }
                    }
                } catch (ex) {
                    console.log("executeSql error calling user error callback: "+ex);
                }

                tx.queryFailed(query.id, reason);
            }

        } catch (e) {
            console.log("executeSql error: "+e);
        }
    }
}

/**
 * SQL query object
 * PRIVATE METHOD
 *
 * @constructor
 * @param tx                The transaction object that this query belongs to
 */
var MobileHelix_Query = function(tx) {

    // Set the id of the query
    this.id = MobileHelixDatabase.createUUID();

    // Add this query to the queue
    MobileHelixDatabase.queryQueue[this.id] = this;

    // Init result
    this.resultSet = [];

    // Set transaction that this query belongs to
    this.tx = tx;

    // Add this query to transaction list
    this.tx.queryList[this.id] = this;

    // Callbacks
    this.successCallback = null;
    this.errorCallback = null;

};

/**
 * Transaction object
 * PRIVATE METHOD
 * @constructor
 */
var MobileHelix_Tx = function() {

    // Set the id of the transaction
    this.id = MobileHelixDatabase.createUUID();

    // Callbacks
    this.successCallback = null;
    this.errorCallback = null;

    // Query list
    this.queryList = {};
};

/**
 * Mark query in transaction as complete.
 * If all queries are complete, call the user's transaction success callback.
 *
 * @param id                Query id
 */
MobileHelix_Tx.prototype.queryComplete = function(id) {
    delete this.queryList[id];

    // If no more outstanding queries, then fire transaction success
    if (this.successCallback) {
        var count = 0;
        var i;
        for (i in this.queryList) {
            if (this.queryList.hasOwnProperty(i)) {
                count++;
            }
        }
        if (count === 0) {
            try {
                this.successCallback();
            } catch(e) {
                console.log("Transaction error calling user success callback: " + e);
            }
        }
    }
};

/**
 * Mark query in transaction as failed.
 *
 * @param id                Query id
 * @param reason            Error message
 */
MobileHelix_Tx.prototype.queryFailed = function(id, reason) {

    // Rollback the transaction.
    cordova.exec(null, null, "MobileHelixStorage", "rollbackTX", [ this.db ]);
    
    // Prevent any more sql queries from being run
    this.queryList = {};

    if (this.errorCallback) {
        try {
            this.errorCallback(reason);
        } catch(e) {
            console.log("Transaction error calling user error callback: " + e);
        }
    }
};

/**
 * Execute SQL statement
 *
 * @param sql                   SQL statement to execute
 * @param params                Statement parameters
 * @param successCallback       Success callback
 * @param errorCallback         Error callback
 */
MobileHelix_Tx.prototype.executeSql = function(sql, params, successCallback, errorCallback) {
    // Init params array
    if (typeof params === 'undefined') {
        params = [];
    }

    // Create query and add to queue
    var query = new MobileHelix_Query(this);
    MobileHelixDatabase.queryQueue[query.id] = query;

    // Save callbacks
    query.successCallback = successCallback;
    query.errorCallback = errorCallback;

    // Call native code
    cordova.exec(function(successObj) {
        completeQuery(query, successObj.rows);
    }, 
    function(errMsg) {
        if (!errorCallback) {
            persistence.errorHandler(errMsg);
        }
        failQuery(errMsg, query);
    }, 
    "MobileHelixStorage", "executeSql", [this.db, sql, params, query.id]);
};

/**
 * Start a transaction.
 * Does not support rollback in event of failure.
 *
 * @param process {Function}            The transaction function
 * @param successCallback {Function}
 * @param errorCallback {Function}
 */
MobileHelixDatabase.prototype.transaction = function(process, errorCallback, successCallback) {
    var ntries = 0;
    var tx = new MobileHelix_Tx();
    tx.db = this.name;
    tx.successCallback = successCallback;
    tx.errorCallback = errorCallback;
    
    // Factored out createTx function so that it is easy to retry on failure.
    var __createTx = function() {
        cordova.exec(function() {
            // Txn is created - run the process function.
            process(tx);
            
            // Now commit the txn.
            cordova.exec(function() {
                
            }, function(errMsg) {
                console.log("Error committing a transaction: " + errMsg);
                //alert("Error committing a transaction: " + errMsg);
            }, "MobileHelixStorage", "commitTX", [ tx.db ]);
        }, 
        function(errMsg) {
            if (ntries == 0) {
                // Wait 1 second and retry; it is possible the DB is just not open yet.
                setTimeout(function() {
                    __createTx();
                }, 1000);
                ++ntries;
                return;
            }
            
            //alert("Error creating a transaction: " + errMsg);
            console.log("Error creating a transaction: " + errMsg);
        }, "MobileHelixStorage", "beginTX", [ tx.db ]);
    };
    
    try {
        __createTx();
    } catch (e) {
        console.log("Transaction error: "+e);
        if (tx.errorCallback) {
            try {
                tx.errorCallback(e);
            } catch (ex) {
                console.log("Transaction error calling user error callback: "+e);
            }
        }
    }
};

MobileHelixDatabase.install = function() {
    /**
     * Open database
     *
     * @param name              Database name
     * @param version           Database version
     * @param display_name      Database display name
     * @param size              Database size in bytes
     * @return                  Database object
     */
    window.openDatabase = function(name, version, display_name, size, callback) {
        var db = new MobileHelixDatabase();
        db.name = name;

        cordova.exec(function() {
            if (callback) {
                callback(db);            
            }
        }, function(err) {
            persistence.errorHandler(err);
        }, "MobileHelixStorage", "openDatabase", [name, version, display_name, size]);
        return db;
    };
};;/**
 * Copyright (c) 2010 Zef Hemel <zef@zef.me>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

if (typeof exports !== 'undefined') {
    exports.createPersistence = function() {
        return initPersistence({})
    }
    var singleton;
    if (typeof (exports.__defineGetter__) === 'function') {
        exports.__defineGetter__("persistence", function () {
            if (!singleton)
                singleton = exports.createPersistence();
            return singleton;
        });
    } else {
        Object.defineProperty(exports, "persistence", {
            get: function () {
                if (!singleton)
                    singleton = exports.createPersistence();
                return singleton;
            },
            enumerable: true,
            configurable: true
        });
    }

}
else {
    window = window || {};
    window.persistence = initPersistence(window.persistence || {});
}


function initPersistence(persistence) {
    if (persistence.isImmutable) // already initialized
        return persistence;

    /**
     * Check for immutable fields
     */
    persistence.isImmutable = function(fieldName) {
        return (fieldName == "id");
    };

    /**
     * Mobile Helix
     * Default global error handler.
     */
    persistence.errorHandler = function(errMsg, code) {
        alert((code ? (code + ": ") : "") + errMsg);
        return false;
    };

    /**
     * Default implementation for entity-property
    */
    persistence.defineProp = function(scope, field, setterCallback, getterCallback) {
        if (typeof (scope.__defineSetter__) === 'function' && typeof (scope.__defineGetter__) === 'function') {
            scope.__defineSetter__(field, function (value) {
                //setterCallback(value);
                setterCallback.apply(this, [ value ]);
            });
            scope.__defineGetter__(field, function () {
                //return getterCallback();
                return getterCallback.apply(this);
            });
        } else {
            var that = this;
            Object.defineProperty(scope, field, {
                get: function() {
                    getterCallback.apply(that);
                },
                set: function (value) {
                    setterCallback.apply(that, [ value ]);
                },
                enumerable: true,
                configurable: true
            });
        }
    };

    /**
     * Default implementation for entity-property setter
     */
    persistence.set = function(scope, fieldName, value) {
        if (persistence.isImmutable(fieldName)) throw new Error("immutable field: "+fieldName);
        scope[fieldName] = value;
    };

    /**
     * Default implementation for entity-property getter
     */
    persistence.get = function(arg1, arg2) {
        return (arguments.length == 1) ? arg1 : arg1[arg2];
    };


    (function () {
        var entityMeta = {};
        var entityClassCache = {};
        persistence.getEntityMeta = function() {
            return entityMeta;
        }

        // Per-session data
        persistence.trackedObjects = {};
        persistence.objectsToRemove = {};
        persistence.globalPropertyListeners = {}; // EntityType__prop -> QueryColleciton obj
        persistence.queryCollectionCache = {}; // entityName -> uniqueString -> QueryCollection

        persistence.getObjectsToRemove = function() {
            return this.objectsToRemove;
        };
        persistence.getTrackedObjects = function() {
            return this.trackedObjects;
        };

        // Public Extension hooks
        persistence.entityDecoratorHooks = [];
        persistence.flushHooks = [];
        persistence.schemaSyncHooks = [];
        persistence.nextSchemaSyncHooks = [];

        // Enable debugging (display queries using console.log etc)
        persistence.debug = false;

        persistence.subscribeToGlobalPropertyListener = function(coll, entityName, property) {
            var key = entityName + '__' + property;
            if(key in this.globalPropertyListeners) {
                var listeners = this.globalPropertyListeners[key];
                for(var i = 0; i < listeners.length; i++) {
                    if(listeners[i] === coll) {
                        return;
                    }
                }
                this.globalPropertyListeners[key].push(coll);
            } else {
                this.globalPropertyListeners[key] = [coll];
            }
        }

        persistence.unsubscribeFromGlobalPropertyListener = function(coll, entityName, property) {
            var key = entityName + '__' + property;
            var listeners = this.globalPropertyListeners[key];
            for(var i = 0; i < listeners.length; i++) {
                if(listeners[i] === coll) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        }

        persistence.propertyChanged = function(obj, property, oldValue, newValue) {
            if(!this.trackedObjects[obj.id]) return; // not yet added, ignore for now

            var entityName = obj._type;
            var key = entityName + '__' + property;
            if(key in this.globalPropertyListeners) {
                var listeners = this.globalPropertyListeners[key];
                for(var i = 0; i < listeners.length; i++) {
                    var coll = listeners[i];
                    var dummyObj = obj._data;
                    dummyObj[property] = oldValue;
                    var matchedBefore = coll._filter.match(dummyObj);
                    dummyObj[property] = newValue;
                    var matchedAfter = coll._filter.match(dummyObj);
                    if(matchedBefore != matchedAfter) {
                        coll.triggerEvent('change', coll, obj);
                    }
                }
            }
        }

        persistence.objectRemoved = function(obj) {
            var entityName = obj._type;
            if(this.queryCollectionCache[entityName]) {
                var colls = this.queryCollectionCache[entityName];
                for(var key in colls) {
                    if(colls.hasOwnProperty(key)) {
                        var coll = colls[key];
                        if(coll._filter.match(obj)) { // matched the filter -> was part of collection
                            coll.triggerEvent('change', coll, obj);
                        }
                    }
                }
            }
        }

        /**
         * To keep queries small we use single or multi-letter aliases.
         */
        var currentPrefix = 'a';
        function getNextLetter() {
            var ch = currentPrefix.charAt(currentPrefix.length - 1);
            if (ch == 'z') {
                currentPrefix = currentPrefix + 'a';
            } else {
                var nxtCh = String.fromCharCode(ch.charCodeAt(0) + 1);
                currentPrefix = currentPrefix.substring(0, currentPrefix.length - 2) + nxtCh;
            }
            return currentPrefix;
        }

        /**
         * Retrieves metadata about entity, mostly for internal use
         */
        function getMeta(entityName) {
            return entityMeta[entityName];
        }

        persistence.getMeta = getMeta;


        /**
         * A database session
         */
        function Session(conn) {
            this.trackedObjects = {};
            this.objectsToRemove = {};
            this.globalPropertyListeners = {}; // EntityType__prop -> QueryColleciton obj
            this.queryCollectionCache = {}; // entityName -> uniqueString -> QueryCollection
            this.conn = conn;
        }

        Session.prototype = persistence; // Inherit everything from the root persistence object

        persistence.Session = Session;

        /**
         * Define an entity
         *
         * @param entityName
         *            the name of the entity (also the table name in the database)
         * @param fields
         *            an object with property names as keys and SQLite types as
         *            values, e.g. {name: "TEXT", age: "INT"}
         * @param doForce
         *            forces the schema to be over-written rather than using a cached
         *            copy if the schema has been previously defined.
         * @return the entity's constructor
         */
        persistence.define = function (entityName, fields, doForce) {
            if (!doForce && entityMeta[entityName]) { // Already defined, ignore
                return getEntity(entityName, false);
            }
            var meta = {
                name: entityName,
                fields: fields,
                isMixin: false,
                indexes: [],
                hasMany: {},
                hasOne: {},
                alias: getNextLetter()
            };
            entityMeta[entityName] = meta;
            return getEntity(entityName, true);
        };

        /**
        * Checks whether an entity exists
        *
        * @param entityName
        *            the name of the entity (also the table name in the database)
        * @return `true` if the entity exists, otherwise `false`
        */
        persistence.isDefined = function (entityName) {
            return !!entityMeta[entityName];
        }

        /**
        * Define a mixin
        *
        * @param mixinName
        *            the name of the mixin
        * @param fields
        *            an object with property names as keys and SQLite types as
        *            values, e.g. {name: "TEXT", age: "INT"}
        * @return the entity's constructor
        */
        persistence.defineMixin = function (mixinName, fields) {
            var Entity = this.define(mixinName, fields);
            Entity.meta.isMixin = true;
            return Entity;
        };

        persistence.isTransaction = function(obj) {
            return !obj || (obj && obj.executeSql);
        };

        persistence.isSession = function(obj) {
            return !obj || (obj && obj.schemaSync);
        };

        /**
        * Adds the object to tracked entities to be persisted
        *
        * @param obj
        *            the object to be tracked
        */
        persistence.add = function (obj) {
            if(!obj) return null;
            if (!this.trackedObjects[obj.id]) {
                this.trackedObjects[obj.id] = obj;
                return obj;
            } else {
                return this.trackedObjects[obj.id];
            }
        };
        
        persistence.canonical = function(obj) {
            if(!obj) return null;
            if (!this.trackedObjects[obj.id]) {
                return obj;
            } else {
                return this.trackedObjects[obj.id];
            }
        };

        /**
         * Marks the object to be removed (on next flush)
         * @param obj object to be removed
         */
        persistence.remove = function(obj) {
            if (!this.objectsToRemove[obj.id]) {
                this.objectsToRemove[obj.id] = obj;
            }
            // SAH - turn off event triggering.
            // this.objectRemoved(obj);
            return this;
        };


        /**
     * Clean the persistence context of cached entities and such.
     */
        persistence.clean = function () {
            this.trackedObjects = {};
            this.objectsToRemove = {};
            this.globalPropertyListeners = {};
            this.queryCollectionCache = {};
        };

    /**
     * asynchronous sequential version of Array.prototype.forEach
     * @param array the array to iterate over
     * @param fn the function to apply to each item in the array, function
     *        has two argument, the first is the item value, the second a
     *        callback function
     * @param callback the function to call when the forEach has ended
     */
        persistence.asyncForEach = function(array, fn, callback) {
            array = array.slice(0); // Just to be sure
            function processOne() {
                var item = array.pop();
                fn(item, function(result, err) {
                    // stop if we hit an error.
                    if(!err & array.length > 0) {
                        processOne();
                    } else {
                        callback(result, err);
                    }
                });
            }
            if(array.length > 0) {
                processOne();
            } else {
                callback();
            }
        };

        /**
     * asynchronous parallel version of Array.prototype.forEach
     * @param array the array to iterate over
     * @param fn the function to apply to each item in the array, function
     *        has two argument, the first is the item value, the second a
     *        callback function
     * @param callback the function to call when the forEach has ended
     * @param opaque argument to pass to fn and callback
     */
        persistence.asyncParForEach = function(array, fn, callback, opaque) {
            var completed = 0;
            var arLength = array.length;
            if(arLength === 0) {
                callback(undefined, undefined, opaque);
            }
            for(var i = 0; i < arLength; i++) {
                fn(array[i], function(result, err) {
                    completed++;
                    if(completed === arLength) {
                        callback(result, err, opaque);
                    }
                }, opaque);
            }
        };

        /**
         * Retrieves or creates an entity constructor function for a given
         * entity name
         * @return the entity constructor function to be invoked with `new fn()`
         */
        function getEntity(entityName, doForce) {
            if (!doForce && entityClassCache[entityName]) {
                return entityClassCache[entityName];
            }
            var meta = entityMeta[entityName];

            /**
             * @constructor
             */
            function _addField(session, field) {
                var args = argspec.getArgs(arguments, [
                {
                    name: "session",
                    optional: true,
                    check: persistence.isSession,
                    defaultValue: persistence
                },
                {
                    name: "field",
                    optional: false,
                    check: argspec.hasType('string')
                }
                ]);
                session = args.session;
                field = args.field;

                var f = field; // Javascript scopes/closures SUCK
                persistence.defineProp(this, f, function(val) {
                    // setterCallback
                    // SAH - make sure we are tracking this object now that it is dirty.
                    var that = session.add(this);       
                    that._data[f] = val;
                    that._dirtyProperties[f] = true;
                    that._ignoreProperties[f] = false;
                }, function() {
                    // getterCallback
                    return persistence.canonical(this)._data[f];
                });
                this._data[field] = defaultValue(meta.fields[field]);
            };

            function Entity (session, obj, noEvents) {
                var args = argspec.getArgs(arguments, [
                {
                    name: "session",
                    optional: true,
                    check: persistence.isSession,
                    defaultValue: persistence
                },
                {
                    name: "obj",
                    optional: true,
                    check: function(obj) {
                        return obj;
                    },
                    defaultValue: {}
                }
                ]);
                if (meta.isMixin)
                    throw new Error("Cannot instantiate mixin");
                session = args.session;
                obj = args.obj;

                this.id = obj.id || persistence.createUUID();
                this._new = true;
                this._type = entityName;
                this._dirtyProperties = {};
                this._ignoreProperties = {};
                this._data = {};
                this._data_obj = {}; // references to objects
                this._session = session || persistence;
                this.subscribers = {}; // observable

                for ( var field in meta.fields) {
                    if (meta.fields.hasOwnProperty(field)) {
                        _addField.call(this, session, field);
                    }
                }

                for ( var it in meta.hasOne) {
                    if (meta.hasOne.hasOwnProperty(it)) {
                        (function (entity) {
                            var ref = it;
                            var mixinClass = meta.hasOne[it].type.meta.isMixin ? ref + '_class' : null;
                            persistence.defineProp(entity, ref, function(val) {
                                // setterCallback
                                var that = session.add(this);
                                if (val == null) {
                                    that._data[ref] = null;
                                    that._data_obj[ref] = undefined;
                                    if (mixinClass)
                                        that[mixinClass] = '';
                                } else if (val.id) {
                                    that._data[ref] = val.id;
                                    that._data_obj[ref] = val;
                                    if (mixinClass)
                                        that[mixinClass] = val._type;
                                } else { // let's assume it's an id
                                    that._data[ref] = val;
                                }
                                that._dirtyProperties[ref] = true;
                            }, function() {
                                // getterCallback
                                var that = persistence.canonical(this);
                                if (!that._data[ref]) {
                                    return null;
                                } else if(that._data_obj[ref] !== undefined) {
                                    return that._data_obj[ref];
                                } else if(that._data[ref] && session.trackedObjects[that._data[ref]]) {
                                    that._data_obj[ref] = session.trackedObjects[that._data[ref]];
                                    return that._data_obj[ref];
                                } else {
                                    throw new Error("Property '" + ref + "' of '" + meta.name + "' with id: " + this._data[ref] + " not fetched, either prefetch it or fetch it manually.");
                                }
                            });
                        }(this));
                    }
                }

                for ( var it in meta.hasMany) {
                    if (meta.hasMany.hasOwnProperty(it)) {
                        (function (entity) {
                            var coll = it;
                            if (meta.hasMany[coll].manyToMany) {
                                persistence.defineProp(entity, coll, function(val) {
                                    // setterCallback
                                    // SAH - setting the value of a query collection field directly
                                    // makes no semantic sense. Do not support it in any way ...
                                    throw new Error("A query collection field cannot be set. Manipulate the contents of the query collection through the collection API.");
                                }, function() {
                                    // getterCallback
                                    var that = persistence.canonical(this);
                                    if (that._data[coll]) {
                                        return that._data[coll];
                                    } else {
                                        var rel = meta.hasMany[coll];
                                        var inverseMeta = rel.type.meta;
                                        var inv = inverseMeta.hasMany[rel.inverseProperty];
                                        var direct = rel.mixin ? rel.mixin.meta.name : meta.name;
                                        var inverse = inv.mixin ? inv.mixin.meta.name : inverseMeta.name;

                                        var queryColl = new persistence.ManyToManyDbQueryCollection(session, inverseMeta.name);
                                        queryColl.initManyToMany(that, coll);
                                        queryColl._manyToManyFetch = {
                                            table: rel.tableName,
                                            prop: direct + '_' + coll,
                                            inverseProp: inverse + '_' + rel.inverseProperty,
                                            id: that.id
                                        };
                                        that._data[coll] = queryColl;
                                        return session.uniqueQueryCollection(queryColl);
                                    }
                                });
                            } else { // one to many
                                persistence.defineProp(entity, coll, function(val) {
                                    // setterCallback
                                    // SAH - setting the value of a query collection field directly
                                    // makes no semantic sense. Do not support it in any way ...
                                    throw new Error("A query collection field cannot be set. Manipulate the contents of the query collection through the collection API.");
                                }, function() {
                                    // getterCallback
                                    var that = persistence.canonical(this);
                                    if (that._data[coll]) {
                                        return that._data[coll];
                                    } else {
                                        var queryColl = 
                                            session.uniqueQueryCollection(new persistence.DbQueryCollection(session, meta.hasMany[coll].type.meta.name).filter(meta.hasMany[coll].inverseProperty, '=', that));
                                        that._data[coll] = queryColl;
                                        return queryColl;
                                    }
                                });
                            }
                        }(this));
                    }
                }

                if(this.initialize) {
                    this.initialize();
                }

                for ( var f in obj) {
                    if (obj.hasOwnProperty(f)) {
                        if(f !== 'id') {
                            persistence.set(this, f, obj[f]);
                        }
                    }
                }
            } // Entity

            Entity.prototype = new Observable();

            Entity.meta = meta;

            Entity.prototype.equals = function(other) {
                return this.id == other.id;
            };

            /* SAH - ignore a named field until its value is reset. */
            Entity.prototype.ignoreField = function(fld) {
                this._ignoreProperties[fld] = true;
            };

            /* SAH - mark an object as already in the DB. Used to enhance the sync speed. See updateOneObject in 
             * persistence.helix.js. Requires the DB id so that we can correlate this object against what we have
             * in the DB.
             */
            Entity.prototype.markPersistent = function(id) {
                this._new = false;
                this.id = id;
            };

            Entity.prototype.toJSON = function() {
                var json = {
                    id: this.id
                };
                for(var p in this._data) {
                    if(this._data.hasOwnProperty(p)) {
                        if (typeof this._data[p] == "object" && this._data[p] != null) {
                            if (this._data[p].toJSON != undefined) {
                                json[p] = this._data[p].toJSON();
                            }
                        } else {
                            json[p] = this._data[p];
                        }
                    }
                }
                return json;
            };


            /**
       * Select a subset of data as a JSON structure (Javascript object)
       *
       * A property specification is passed that selects the
       * properties to be part of the resulting JSON object. Examples:
       *    ['id', 'name'] -> Will return an object with the id and name property of this entity
       *    ['*'] -> Will return an object with all the properties of this entity, not recursive
       *    ['project.name'] -> will return an object with a project property which has a name
       *                        property containing the project name (hasOne relationship)
       *    ['project.[id, name]'] -> will return an object with a project property which has an
       *                              id and name property containing the project name
       *                              (hasOne relationship)
       *    ['tags.name'] -> will return an object with an array `tags` property containing
       *                     objects each with a single property: name
       *
       * @param tx database transaction to use, leave out to start a new one
       * @param props a property specification
       * @param callback(result)
       */
            Entity.prototype.selectJSON = function(tx, props, callback) {
                var that = this;
                var args = argspec.getArgs(arguments, [
                {
                    name: "tx",
                    optional: true,
                    check: persistence.isTransaction,
                    defaultValue: null
                },
                {
                    name: "props",
                    optional: false
                },
                {
                    name: "callback",
                    optional: false
                }
                ]);
                tx = args.tx;
                props = args.props;
                callback = args.callback;

                if(!tx) {
                    this._session.transaction(function(tx) {
                        that.selectJSON(tx, props, callback);
                    });
                    return;
                }
                var includeProperties = {};
                props.forEach(function(prop) {
                    var current = includeProperties;
                    var parts = prop.split('.');
                    for(var i = 0; i < parts.length; i++) {
                        var part = parts[i];
                        if(i === parts.length-1) {
                            if(part === '*') {
                                current.id = true;
                                for(var p in meta.fields) {
                                    if(meta.fields.hasOwnProperty(p)) {
                                        current[p] = true;
                                    }
                                }
                                for(var p in meta.hasOne) {
                                    if(meta.hasOne.hasOwnProperty(p)) {
                                        current[p] = true;
                                    }
                                }
                                for(var p in meta.hasMany) {
                                    if(meta.hasMany.hasOwnProperty(p)) {
                                        current[p] = true;
                                    }
                                }
                            } else if(part[0] === '[') {
                                part = part.substring(1, part.length-1);
                                var propList = part.split(/,\s*/);
                                propList.forEach(function(prop) {
                                    current[prop] = true;
                                });
                            } else {
                                current[part] = true;
                            }
                        } else {
                            current[part] = current[part] || {};
                            current = current[part];
                        }
                    }
                });
                buildJSON(this, tx, includeProperties, callback);
            };

            function buildJSON(that, tx, includeProperties, callback) {
                var session = that._session;
                var properties = [];
                var meta = getMeta(that._type);
                var fieldSpec = meta.fields;

                for(var p in includeProperties) {
                    if(includeProperties.hasOwnProperty(p)) {
                        properties.push(p);
                    }
                }

                var cheapProperties = [];
                var expensiveProperties = [];

                properties.forEach(function(p) {
                    if(includeProperties[p] === true && !meta.hasMany[p]) { // simple, loaded field
                        cheapProperties.push(p);
                    } else {
                        expensiveProperties.push(p);
                    }
                });

                var itemData = that._data;
                var item = {};

                cheapProperties.forEach(function(p) {
                    if(p === 'id') {
                        item.id = that.id;
                    } else if(meta.hasOne[p]) {
                        item[p] = itemData[p] ? {
                            id: itemData[p]
                        } : null;
                    } else {
                        item[p] = persistence.entityValToJson(itemData[p], fieldSpec[p]);
                    }
                });
                properties = expensiveProperties.slice();

                persistence.asyncForEach(properties, function(p, callback) {
                    if(meta.hasOne[p]) {
                        that.fetch(tx, p, function(obj) {
                            if(obj) {
                                buildJSON(obj, tx, includeProperties[p], function(result) {
                                    item[p] = result;
                                    callback();
                                });
                            } else {
                                item[p] = null;
                                callback();
                            }
                        });
                    } else if(meta.hasMany[p]) {
                        persistence.get(that, p).list(function(objs) {
                            item[p] = [];
                            persistence.asyncForEach(objs, function(obj, callback) {
                                var obj = objs.pop();
                                if(includeProperties[p] === true) {
                                    item[p].push({
                                        id: obj.id
                                    });
                                    callback();
                                } else {
                                    buildJSON(obj, tx, includeProperties[p], function(result) {
                                        item[p].push(result);
                                        callback();
                                    });
                                }
                            }, callback);
                        });
                    }
                }, function() {
                    callback(item);
                });
            }; // End of buildJson

            Entity.prototype.fetch = function(tx, rel, callback) {
                var args = argspec.getArgs(arguments, [
                {
                    name: 'tx',
                    optional: true,
                    check: persistence.isTransaction,
                    defaultValue: null
                },
                {
                    name: 'rel',
                    optional: false,
                    check: argspec.hasType('string')
                },
                {
                    name: 'callback',
                    optional: false,
                    check: argspec.isCallback()
                }
                ]);
                tx = args.tx;
                rel = args.rel;
                callback = args.callback;

                var that = this;
                var session = this._session;

                if(!tx) {
                    session.transaction(function(tx) {
                        that.fetch(tx, rel, callback);
                    });
                    return;
                }
                if(!this._data[rel]) { // null
                    if(callback) {
                        callback(null);
                    }
                } else if(this._data_obj[rel]) { // already loaded
                    if(callback) {
                        callback(this._data_obj[rel]);
                    }
                } else {
                    var type = meta.hasOne[rel].type;
                    if (type.meta.isMixin) {
                        type = getEntity(this._data[rel + '_class']);
                    }
                    type.load(session, tx, this._data[rel], function(obj) {
                        that._data_obj[rel] = obj;
                        if(callback) {
                            callback(obj);
                        }
                    });
                }
            };

            /**
       * Currently this is only required when changing JSON properties
       */
            Entity.prototype.markDirty = function(prop) {
                this._dirtyProperties[prop] = true;
            };

            Entity.addField = _addField;

            /**
       * Returns a QueryCollection implementation matching all instances
       * of this entity in the database
       */
            Entity.all = function(session) {
                var args = argspec.getArgs(arguments, [
                {
                    name: 'session',
                    optional: true,
                    check: persistence.isSession,
                    defaultValue: persistence
                }
                ]);
                session = args.session;
                return session.uniqueQueryCollection(new AllDbQueryCollection(session, entityName));
            };

            Entity.fromSelectJSON = function(session, tx, jsonObj, callback) {
                var args = argspec.getArgs(arguments, [
                {
                    name: 'session',
                    optional: true,
                    check: persistence.isSession,
                    defaultValue: persistence
                },
                {
                    name: 'tx',
                    optional: true,
                    check: persistence.isTransaction,
                    defaultValue: null
                },
                {
                    name: 'jsonObj',
                    optional: false
                },
                {
                    name: 'callback',
                    optional: false,
                    check: argspec.isCallback()
                }
                ]);
                session = args.session;
                tx = args.tx;
                jsonObj = args.jsonObj;
                callback = args.callback;

                if(!tx) {
                    session.transaction(function(tx) {
                        Entity.fromSelectJSON(session, tx, jsonObj, callback);
                    });
                    return;
                }

                if(typeof jsonObj === 'string') {
                    jsonObj = JSON.parse(jsonObj);
                }

                if(!jsonObj) {
                    callback(null)
                    ;
                    return;
                }

                function loadedObj(obj) {
                    if(!obj) {
                        obj = new Entity(session);
                        if(jsonObj.id) {
                            obj.id = jsonObj.id;
                        }
                    }
                    session.add(obj);
                    var expensiveProperties = [];
                    for(var p in jsonObj) {
                        if(jsonObj.hasOwnProperty(p)) {
                            if(p === 'id') {
                                continue;
                            } else if(meta.fields[p]) { // regular field
                                persistence.set(obj, p, persistence.jsonToEntityVal(jsonObj[p], meta.fields[p]));
                            } else if(meta.hasOne[p] || meta.hasMany[p]){
                                expensiveProperties.push(p);
                            }
                        }
                    }
                    persistence.asyncForEach(expensiveProperties, function(p, callback) {
                        if(meta.hasOne[p]) {
                            meta.hasOne[p].type.fromSelectJSON(session, tx, jsonObj[p], function(result) {
                                persistence.set(obj, p, result);
                                callback();
                            });
                        } else if(meta.hasMany[p]) {
                            var coll = persistence.get(obj, p);
                            var ar = jsonObj[p].slice(0);
                            var PropertyEntity = meta.hasMany[p].type;
                            // get all current items
                            coll.list(tx, function(currentItems) {
                                persistence.asyncForEach(ar, function(item, callback) {
                                    PropertyEntity.fromSelectJSON(session, tx, item, function(result) {
                                        // Check if not already in collection
                                        for(var i = 0; i < currentItems.length; i++) {
                                            if(currentItems[i].id === result.id) {
                                                callback();
                                                return;
                                            }
                                        }
                                        coll.add(result);
                                        callback();
                                    });
                                }, function() {
                                    callback();
                                });
                            });
                        }
                    }, function() {
                        callback(obj);
                    });
                }
                if(jsonObj.id) {
                    Entity.load(session, tx, jsonObj.id, loadedObj);
                } else {
                    loadedObj(new Entity(session));
                }
            };

            Entity.load = function(session, tx, id, callback) {
                var args = argspec.getArgs(arguments, [
                {
                    name: 'session',
                    optional: true,
                    check: persistence.isSession,
                    defaultValue: persistence
                },
                {
                    name: 'tx',
                    optional: true,
                    check: persistence.isTransaction,
                    defaultValue: null
                },
                {
                    name: 'id',
                    optional: false,
                    check: argspec.hasType('string')
                },
                {
                    name: 'callback',
                    optional: true,
                    check: argspec.isCallback(),
                    defaultValue: function(){}
                }
                ]);
                Entity.findBy(args.session, args.tx, "id", args.id, args.callback);
            };

            Entity.findBy = function(session, tx, property, value, callback) {
                var args = argspec.getArgs(arguments, [
                {
                    name: 'session',
                    optional: true,
                    check: persistence.isSession,
                    defaultValue: persistence
                },
                {
                    name: 'tx',
                    optional: true,
                    check: persistence.isTransaction,
                    defaultValue: null
                },
                {
                    name: 'property',
                    optional: false,
                    check: argspec.hasType('string')
                },
                {
                    name: 'value',
                    optional: false
                },
                {
                    name: 'callback',
                    optional: true,
                    check: argspec.isCallback(),
                    defaultValue: function(){}
                }
                ]);
                session = args.session;
                tx = args.tx;
                property = args.property;
                value = args.value;
                callback = args.callback;

                if(property === 'id' && value in session.trackedObjects) {
                    callback(session.trackedObjects[value]);
                    return;
                }
                if(!tx) {
                    session.transaction(function(tx) {
                        Entity.findBy(session, tx, property, value, callback);
                    }, function(err) {
                        alert(err.message);
                    });
                    return;
                }
                Entity.all(session).filter(property, "=", value).one(tx, function(obj) {
                    callback(obj);
                });
            }


            Entity.index = function(cols,options) {
                var opts = options || {};
                if (typeof cols=="string") {
                    cols = [cols];
                }
                opts.columns = cols;
                meta.indexes.push(opts);
            };

            /**
       * Declares a one-to-many or many-to-many relationship to another entity
       * Whether 1:N or N:M is chosed depends on the inverse declaration
       * @param collName the name of the collection (becomes a property of
         *   Entity instances
         * @param otherEntity the constructor function of the entity to define
         *   the relation to
         * @param inverseRel the name of the inverse property (to be) defined on otherEntity
         */
            Entity.hasMany = function (collName, otherEntity, invRel) {
                var otherMeta = otherEntity.meta;
                if (otherMeta.hasMany[invRel]) {
                    // other side has declared it as a one-to-many relation too -> it's in
                    // fact many-to-many
                    var tableName = meta.name + "_" + collName + "_" + otherMeta.name;
                    var inverseTableName = otherMeta.name + '_' + invRel + '_' + meta.name;

                    if (tableName > inverseTableName) {
                        // Some arbitrary way to deterministically decide which table to generate
                        tableName = inverseTableName;
                    }
                    meta.hasMany[collName] = {
                        type: otherEntity,
                        inverseProperty: invRel,
                        manyToMany: true,
                        tableName: tableName
                    };
                    otherMeta.hasMany[invRel] = {
                        type: Entity,
                        inverseProperty: collName,
                        manyToMany: true,
                        tableName: tableName
                    };
                    delete meta.hasOne[collName];
                    delete meta.fields[collName + "_class"]; // in case it existed
                } else {
                    meta.hasMany[collName] = {
                        type: otherEntity,
                        inverseProperty: invRel
                    };
                    otherMeta.hasOne[invRel] = {
                        type: Entity,
                        inverseProperty: collName
                    };
                    if (meta.isMixin)
                        otherMeta.fields[invRel + "_class"] = persistence.typeMapper ? persistence.typeMapper.classNameType : "TEXT";
                }
            }

            Entity.hasOne = function (refName, otherEntity, inverseProperty) {
                meta.hasOne[refName] = {
                    type: otherEntity,
                    inverseProperty: inverseProperty
                };
                if (otherEntity.meta.isMixin)
                    meta.fields[refName + "_class"] = persistence.typeMapper ? persistence.typeMapper.classNameType : "TEXT";
            };

            Entity.is = function(mixin){
                var mixinMeta = mixin.meta;
                if (!mixinMeta.isMixin)
                    throw new Error("not a mixin: " + mixin);

                mixin.meta.mixedIns = mixin.meta.mixedIns || [];
                mixin.meta.mixedIns.push(meta);

                for (var field in mixinMeta.fields) {
                    if (mixinMeta.fields.hasOwnProperty(field))
                        meta.fields[field] = mixinMeta.fields[field];
                }
                for (var it in mixinMeta.hasOne) {
                    if (mixinMeta.hasOne.hasOwnProperty(it))
                        meta.hasOne[it] = mixinMeta.hasOne[it];
                }
                for (var it in mixinMeta.hasMany) {
                    if (mixinMeta.hasMany.hasOwnProperty(it)) {
                        mixinMeta.hasMany[it].mixin = mixin;
                        meta.hasMany[it] = mixinMeta.hasMany[it];
                    }
                }
            }

            // Allow decorator functions to add more stuff
            var fns = persistence.entityDecoratorHooks;
            for(var i = 0; i < fns.length; i++) {
                fns[i](Entity);
            }

            entityClassCache[entityName] = Entity;
            return Entity;
        }

        persistence.jsonToEntityVal = function(value, type) {
            if(type) {
                switch(type) {
                    case 'DATE':
                        if(typeof value === 'number') {
                            if (value > 1000000000000) {
                                // it's in milliseconds
                                return new Date(value);
                            } else {
                                return new Date(value * 1000);
                            }
                        } else {
                            return null;
                        }
                        break;
                    default:
                        return value;
                }
            } else {
                return value;
            }
        };

        persistence.entityValToJson = function(value, type) {
            if(type) {
                switch(type) {
                    case 'DATE':
                        if(value) {
                            value = new Date(value);
                            return Math.round(value.getTime() / 1000);
                        } else {
                            return null;
                        }
                        break;
                    default:
                        return value;
                }
            } else {
                return value;
            }
        };

        /**
     * Dumps the entire database into an object (that can be serialized to JSON for instance)
     * @param tx transaction to use, use `null` to start a new one
     * @param entities a list of entity constructor functions to serialize, use `null` for all
     * @param callback (object) the callback function called with the results.
     */
        persistence.dump = function(tx, entities, callback) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'entities',
                optional: true,
                check: function(obj) {
                    return !obj || (obj && obj.length && !obj.apply);
                },
                defaultValue: null
            },
            {
                name: 'callback',
                optional: false,
                check: argspec.isCallback(),
                defaultValue: function(){}
            }
            ]);
            tx = args.tx;
            entities = args.entities;
            callback = args.callback;

            if(!entities) { // Default: all entity types
                entities = [];
                for(var e in entityClassCache) {
                    if(entityClassCache.hasOwnProperty(e)) {
                        entities.push(entityClassCache[e]);
                    }
                }
            }

            var result = {};
            persistence.asyncParForEach(entities, function(Entity, callback) {
                Entity.all().list(tx, function(all) {
                    var items = [];
                    persistence.asyncParForEach(all, function(e, callback) {
                        var rec = {};
                        var fields = Entity.meta.fields;
                        for(var f in fields) {
                            if(fields.hasOwnProperty(f)) {
                                rec[f] = persistence.entityValToJson(e._data[f], fields[f]);
                            }
                        }
                        var refs = Entity.meta.hasOne;
                        for(var r in refs) {
                            if(refs.hasOwnProperty(r)) {
                                rec[r] = e._data[r];
                            }
                        }
                        var colls = Entity.meta.hasMany;
                        var collArray = [];
                        for(var coll in colls) {
                            if(colls.hasOwnProperty(coll)) {
                                collArray.push(coll);
                            }
                        }
                        persistence.asyncParForEach(collArray, function(collP, callback) {
                            var coll = persistence.get(e, collP);
                            coll.list(tx, function(results) {
                                rec[collP] = results.map(function(r) {
                                    return r.id;
                                });
                                callback();
                            });
                        }, function() {
                            rec.id = e.id;
                            items.push(rec);
                            callback();
                        });
                    }, function() {
                        result[Entity.meta.name] = items;
                        callback();
                    });
                });
            }, function() {
                callback(result);
            });
        };

        /**
     * Loads a set of entities from a dump object
     * @param tx transaction to use, use `null` to start a new one
     * @param dump the dump object
     * @param callback the callback function called when done.
     */
        persistence.load = function(tx, dump, callback) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'dump',
                optional: false
            },
            {
                name: 'callback',
                optional: true,
                check: argspec.isCallback(),
                defaultValue: function(){}
            }
            ]);
            tx = args.tx;
            dump = args.dump;
            callback = args.callback;

            var finishedCount = 0;
            var collItemsToAdd = [];
            var session = this;
            for(var entityName in dump) {
                if(dump.hasOwnProperty(entityName)) {
                    var Entity = getEntity(entityName);
                    var fields = Entity.meta.fields;
                    var instances = dump[entityName];
                    for(var i = 0; i < instances.length; i++) {
                        var instance = instances[i];
                        var ent = new Entity();
                        ent.id = instance.id;
                        for(var p in instance) {
                            if(instance.hasOwnProperty(p)) {
                                if (persistence.isImmutable(p)) {
                                    ent[p] = instance[p];
                                } else if(Entity.meta.hasMany[p]) { // collection
                                    var many = Entity.meta.hasMany[p];
                                    if(many.manyToMany && Entity.meta.name < many.type.meta.name) { // Arbitrary way to avoid double adding
                                        continue;
                                    }
                                    var coll = persistence.get(ent, p);
                                    if(instance[p].length > 0) {
                                        instance[p].forEach(function(it) {
                                            collItemsToAdd.push({
                                                Entity: Entity,
                                                coll: coll,
                                                id: it
                                            });
                                        });
                                    }
                                } else {
                                    persistence.set(ent, p, persistence.jsonToEntityVal(instance[p], fields[p]));
                                }
                            }
                        }
                        this.add(ent);
                    }
                }
            }
            session.flush(tx, function() {
                persistence.asyncForEach(collItemsToAdd, function(collItem, callback) {
                    collItem.Entity.load(session, tx, collItem.id, function(obj) {
                        collItem.coll.add(obj);
                        callback();
                    });
                }, function() {
                    session.flush(tx, callback);
                });
            });
        };

        /**
     * Dumps the entire database to a JSON string
     * @param tx transaction to use, use `null` to start a new one
     * @param entities a list of entity constructor functions to serialize, use `null` for all
     * @param callback (jsonDump) the callback function called with the results.
     */
        persistence.dumpToJson = function(tx, entities, callback) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'entities',
                optional: true,
                check: function(obj) {
                    return obj && obj.length && !obj.apply;
                },
                defaultValue: null
            },
            {
                name: 'callback',
                optional: false,
                check: argspec.isCallback(),
                defaultValue: function(){}
            }
            ]);
            tx = args.tx;
            entities = args.entities;
            callback = args.callback;
            this.dump(tx, entities, function(obj) {
                callback(JSON.stringify(obj));
            });
        };

        /**
     * Loads data from a JSON string (as dumped by `dumpToJson`)
     * @param tx transaction to use, use `null` to start a new one
     * @param jsonDump JSON string
     * @param callback the callback function called when done.
     */
        persistence.loadFromJson = function(tx, jsonDump, callback) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'jsonDump',
                optional: false
            },
            {
                name: 'callback',
                optional: true,
                check: argspec.isCallback(),
                defaultValue: function(){}
            }
            ]);
            tx = args.tx;
            jsonDump = args.jsonDump;
            callback = args.callback;
            this.load(tx, JSON.parse(jsonDump), callback);
        };


        /**
     * Generates a UUID according to http://www.ietf.org/rfc/rfc4122.txt
     */
        function createUUID () {
            if(persistence.typeMapper && persistence.typeMapper.newUuid) {
                return persistence.typeMapper.newUuid();
            }
            var s = [];
            var hexDigits = "0123456789ABCDEF";
            for ( var i = 0; i < 32; i++) {
                s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
            }
            s[12] = "4";
            s[16] = hexDigits.substr((s[16] & 0x3) | 0x8, 1);

            var uuid = s.join("");
            return uuid;
        }

        persistence.createUUID = createUUID;


        function defaultValue(type) {
            if(persistence.typeMapper && persistence.typeMapper.defaultValue) {
                return persistence.typeMapper.defaultValue(type);
            }
            switch(type) {
                case "TEXT":
                    return "";
                case "BOOL":
                    return false;
                default:
                    if(type.indexOf("INT") !== -1) {
                        return 0;
                    } else if(type.indexOf("CHAR") !== -1) {
                        return "";
                    } else {
                        return null;
                    }
            }
        }

        function arrayContains(ar, item) {
            var l = ar.length;
            for(var i = 0; i < l; i++) {
                var el = ar[i];
                if(el.equals && el.equals(item)) {
                    return true;
                } else if(el === item) {
                    return true;
                }
            }
            return false;
        }

        function arrayRemove(ar, item) {
            var l = ar.length;
            for(var i = 0; i < l; i++) {
                var el = ar[i];
                if(el.equals && el.equals(item)) {
                    ar.splice(i, 1);
                    return;
                } else if(el === item) {
                    ar.splice(i, 1);
                    return;
                }
            }
        }

        ////////////////// QUERY COLLECTIONS \\\\\\\\\\\\\\\\\\\\\\\

        function Subscription(obj, eventType, fn) {
            this.obj = obj;
            this.eventType = eventType;
            this.fn = fn;
        }

        Subscription.prototype.unsubscribe = function() {
            this.obj.removeEventListener(this.eventType, this.fn);
        };

        /**
     * Simple observable function constructor
     * @constructor
     */
        function Observable() {
            this.subscribers = {};
        }

        Observable.prototype.addEventListener = function (eventType, fn) {
            if (!this.subscribers[eventType]) {
                this.subscribers[eventType] = [];
            }
            this.subscribers[eventType].push(fn);
            return new Subscription(this, eventType, fn);
        };

        Observable.prototype.removeEventListener = function(eventType, fn) {
            var subscribers = this.subscribers[eventType];
            for ( var i = 0; i < subscribers.length; i++) {
                if(subscribers[i] == fn) {
                    this.subscribers[eventType].splice(i, 1);
                    return true;
                }
            }
            return false;
        };

        Observable.prototype.triggerEvent = function (eventType) {
            if (!this.subscribers[eventType]) { // No subscribers to this event type
                return;
            }
            var subscribers = this.subscribers[eventType].slice(0);
            for(var i = 0; i < subscribers.length; i++) {
                subscribers[i].apply(null, arguments);
            }
        };

        /*
     * Each filter has 4 methods:
     * - sql(prefix, values) -- returns a SQL representation of this filter,
     *     possibly pushing additional query arguments to `values` if ?'s are used
     *     in the query
     * - match(o) -- returns whether the filter matches the object o.
     * - makeFit(o) -- attempts to adapt the object o in such a way that it matches
     *     this filter.
     * - makeNotFit(o) -- the oppositive of makeFit, makes the object o NOT match
     *     this filter
     */

        /**
     * Default filter that does not filter on anything
     * currently it generates a 1=1 SQL query, which is kind of ugly
     */
        function NullFilter () {
        }

        NullFilter.prototype.match = function (o) {
            return true;
        };

        NullFilter.prototype.makeFit = function(o) {
        };

        NullFilter.prototype.makeNotFit = function(o) {
        };

        NullFilter.prototype.toUniqueString = function() {
            return "NULL";
        };

        NullFilter.prototype.subscribeGlobally = function() { };

        NullFilter.prototype.unsubscribeGlobally = function() { };

        /**
     * Filter that makes sure that both its left and right filter match
     * @param left left-hand filter object
     * @param right right-hand filter object
     */
        function AndFilter (left, right) {
            this.left = left;
            this.right = right;
        }

        AndFilter.prototype.match = function (o) {
            return this.left.match(o) && this.right.match(o);
        };

        AndFilter.prototype.makeFit = function(o) {
            this.left.makeFit(o);
            this.right.makeFit(o);
        };

        AndFilter.prototype.makeNotFit = function(o) {
            this.left.makeNotFit(o);
            this.right.makeNotFit(o);
        };

        AndFilter.prototype.toUniqueString = function() {
            return this.left.toUniqueString() + " AND " + this.right.toUniqueString();
        };

        AndFilter.prototype.subscribeGlobally = function(coll, entityName) {
            this.left.subscribeGlobally(coll, entityName);
            this.right.subscribeGlobally(coll, entityName);
        };

        AndFilter.prototype.unsubscribeGlobally = function(coll, entityName) {
            this.left.unsubscribeGlobally(coll, entityName);
            this.right.unsubscribeGlobally(coll, entityName);
        };

        /**
     * Filter that makes sure that either its left and right filter match
     * @param left left-hand filter object
     * @param right right-hand filter object
     */
        function OrFilter (left, right) {
            this.left = left;
            this.right = right;
        }

        OrFilter.prototype.match = function (o) {
            return this.left.match(o) || this.right.match(o);
        };

        OrFilter.prototype.makeFit = function(o) {
            this.left.makeFit(o);
            this.right.makeFit(o);
        };

        OrFilter.prototype.makeNotFit = function(o) {
            this.left.makeNotFit(o);
            this.right.makeNotFit(o);
        };

        OrFilter.prototype.toUniqueString = function() {
            return this.left.toUniqueString() + " OR " + this.right.toUniqueString();
        };

        OrFilter.prototype.subscribeGlobally = function(coll, entityName) {
            this.left.subscribeGlobally(coll, entityName);
            this.right.subscribeGlobally(coll, entityName);
        };

        OrFilter.prototype.unsubscribeGlobally = function(coll, entityName) {
            this.left.unsubscribeGlobally(coll, entityName);
            this.right.unsubscribeGlobally(coll, entityName);
        };

        /**
     * Filter that checks whether a certain property matches some value, based on an
     * operator. Supported operators are '=', '!=', '<', '<=', '>' and '>='.
     * @param property the property name
     * @param operator the operator to compare with
     * @param value the literal value to compare to
     */
        function PropertyFilter (property, operator, value) {
            this.property = property;
            this.operator = operator.toLowerCase();
            this.value = value;
        }

        PropertyFilter.prototype.match = function (o) {
            var value = this.value;
            var propValue = persistence.get(o, this.property);
            if(value && value.getTime) { // DATE
                // TODO: Deal with arrays of dates for 'in' and 'not in'
                value = Math.round(value.getTime() / 1000) * 1000; // Deal with precision
                if(propValue && propValue.getTime) { // DATE
                    propValue = Math.round(propValue.getTime() / 1000) * 1000; // Deal with precision
                }
            }
            switch (this.operator) {
                case '=':
                    return propValue === value;
                    break;
                case '!=':
                    return propValue !== value;
                    break;
                case '<':
                    return propValue < value;
                    break;
                case '<=':
                    return propValue <= value;
                    break;
                case '>':
                    return propValue > value;
                    break;
                case '>=':
                    return propValue >= value;
                    break;
                case 'in':
                    return arrayContains(value, propValue);
                    break;
                case 'not in':
                    return !arrayContains(value, propValue);
                    break;
            }
        };

        PropertyFilter.prototype.makeFit = function(o) {
            if(this.operator === '=') {
                persistence.set(o, this.property, this.value);
            } else {
                throw new Error("Sorry, can't perform makeFit for other filters than =");
            }
        };

        PropertyFilter.prototype.makeNotFit = function(o) {
            if(this.operator === '=') {
                persistence.set(o, this.property, null);
            } else {
                throw new Error("Sorry, can't perform makeNotFit for other filters than =");
            }
        };

        PropertyFilter.prototype.subscribeGlobally = function(coll, entityName) {
            persistence.subscribeToGlobalPropertyListener(coll, entityName, this.property);
        };

        PropertyFilter.prototype.unsubscribeGlobally = function(coll, entityName) {
            persistence.unsubscribeFromGlobalPropertyListener(coll, entityName, this.property);
        };

        PropertyFilter.prototype.toUniqueString = function() {
            var val = this.value;
            if(val && val._type) {
                val = val.id;
            }
            return this.property + this.operator + val;
        };

        persistence.NullFilter = NullFilter;
        persistence.AndFilter = AndFilter;
        persistence.OrFilter = OrFilter;
        persistence.PropertyFilter = PropertyFilter;

        /**
     * Ensure global uniqueness of query collection object
     */
        persistence.uniqueQueryCollection = function(coll) {
            var entityName = coll._entityName;
            if(coll._items) { // LocalQueryCollection
                return coll;
            }
            if(!this.queryCollectionCache[entityName]) {
                this.queryCollectionCache[entityName] = {};
            }
            var uniqueString = coll.toUniqueString();
            if(!this.queryCollectionCache[entityName][uniqueString]) {
                this.queryCollectionCache[entityName][uniqueString] = coll;
            }
            return this.queryCollectionCache[entityName][uniqueString];
        }

        /**
     * The constructor function of the _abstract_ QueryCollection
     * DO NOT INSTANTIATE THIS
     * @constructor
     */
        function QueryCollection () {
        }

        QueryCollection.prototype = new Observable();

        QueryCollection.prototype.oldAddEventListener = QueryCollection.prototype.addEventListener;

        QueryCollection.prototype.setupSubscriptions = function() {
            this._filter.subscribeGlobally(this, this._entityName);
        };

        QueryCollection.prototype.teardownSubscriptions = function() {
            this._filter.unsubscribeGlobally(this, this._entityName);
        };

        QueryCollection.prototype.addEventListener = function(eventType, fn) {
            var that = this;
            var subscription = this.oldAddEventListener(eventType, fn);
            if(this.subscribers[eventType].length === 1) { // first subscriber
                this.setupSubscriptions();
            }
            subscription.oldUnsubscribe = subscription.unsubscribe;
            subscription.unsubscribe = function() {
                this.oldUnsubscribe();

                if(that.subscribers[eventType].length === 0) { // last subscriber
                    that.teardownSubscriptions();
                }
            };
            return subscription;
        };

        /**
     * Function called when session is flushed, returns list of SQL queries to execute
     * (as [query, arg] tuples)
     */
        QueryCollection.prototype.persistQueries = function() {
            return [];
        };

        /**
     * Invoked by sub-classes to initialize the query collection
     */
        QueryCollection.prototype.init = function (session, entityName, constructor) {
            this._filter = new NullFilter();
            this._orderColumns = []; // tuples of [column, ascending]
            this._prefetchFields = [];
            this._entityName = entityName;
            this._constructor = constructor;
            this._limit = -1;
            this._skip = 0;
            this._reverse = false;
            this._session = session || persistence;
            // For observable
            this.subscribers = {};
        }

        QueryCollection.prototype.toUniqueString = function() {
            var s = this._constructor.name + ": " + this._entityName;
            s += '|Filter:';
            var values = [];
            s += this._filter.toUniqueString();
            s += '|Values:';
            for(var i = 0; i < values.length; i++) {
                s += values + "|^|";
            }
            s += '|Order:';
            for(var i = 0; i < this._orderColumns.length; i++) {
                var col = this._orderColumns[i];
                s += col[0] + ", " + col[1] + ", " + col[2];
            }
            s += '|Prefetch:';
            for(var i = 0; i < this._prefetchFields.length; i++) {
                s += this._prefetchFields[i];
            }
            s += '|Includes:';
            if (this._includes) {
                for(var fld in this._includes) {
                    s += fld;
                }
            }
            s += '|Excludes:';
            if (this._excludes) {
                for(fld in this._excludes) {
                    s += fld;
                }
            }
            s += '|Limit:';
            s += this._limit;
            s += '|Skip:';
            s += this._skip;
            s += '|Reverse:';
            s += this._reverse;
            return s;
        };

        /**
     * Creates a clone of this query collection
     * @return a clone of the collection
     */
        QueryCollection.prototype.clone = function (cloneSubscribers) {
            var c = new (this._constructor)(this._session, this._entityName);
            c._filter = this._filter;
            c._prefetchFields = this._prefetchFields.slice(0); // clone
            c._orderColumns = this._orderColumns.slice(0);
            c._limit = this._limit;
            c._skip = this._skip;
            c._reverse = this._reverse;
            if(cloneSubscribers) {
                var subscribers = {};
                for(var eventType in this.subscribers) {
                    if(this.subscribers.hasOwnProperty(eventType)) {
                        subscribers[eventType] = this.subscribers[eventType].slice(0);
                    }
                }
                c.subscribers = subscribers; //this.subscribers;
            } else {
                c.subscribers = this.subscribers;
            }
            if (this._includes) {
                c._includes = this._includes;
            }
            if (this._excludes) {
                c._excludes = this._excludes;
            }
            return c;
        };

        /**
     * Returns a new query collection with a property filter condition added
     * @param property the property to filter on
     * @param operator the operator to use
     * @param value the literal value that the property should match
     * @return the query collection with the filter added
     */
        QueryCollection.prototype.filter = function (property, operator, value) {
            var c = this.clone(true);
            c._filter = new AndFilter(this._filter, new PropertyFilter(property,
                operator, value));
            // Add global listener (TODO: memory leak waiting to happen!)
            var session = this._session;
            c = session.uniqueQueryCollection(c);
            //session.subscribeToGlobalPropertyListener(c, this._entityName, property);
            return session.uniqueQueryCollection(c);
        };

        /**
     * Returns a new query collection with an OR condition between the
     * current filter and the filter specified as argument
     * @param filter the other filter
     * @return the new query collection
     */
        QueryCollection.prototype.or = function (filter) {
            var c = this.clone(true);
            c._filter = new OrFilter(this._filter, filter);
            return this._session.uniqueQueryCollection(c);
        };

        /**
     * Returns a new query collection with an AND condition between the
     * current filter and the filter specified as argument
     * @param filter the other filter
     * @return the new query collection
     */
        QueryCollection.prototype.and = function (filter) {
            var c = this.clone(true);
            c._filter = new AndFilter(this._filter, filter);
            return this._session.uniqueQueryCollection(c);
        };

        /**
     * Returns a new query collection with an ordering imposed on the collection
     * @param property the property to sort on
     * @param ascending should the order be ascending (= true) or descending (= false)
     * @param caseSensitive should the order be case sensitive (= true) or case insensitive (= false)
     *        note: using case insensitive ordering for anything other than TEXT fields yields
     *        undefinded behavior
     * @return the query collection with imposed ordering
     */
        QueryCollection.prototype.order = function (property, ascending, caseSensitive) {
            ascending = ascending === undefined ? true : ascending;
            caseSensitive = caseSensitive === undefined ? true : caseSensitive;
            var c = this.clone();
            c._orderColumns.push( [ property, ascending, caseSensitive ]);
            return this._session.uniqueQueryCollection(c);
        };

        /**
     * Returns a new query collection will limit its size to n items
     * @param n the number of items to limit it to
     * @return the limited query collection
     */
        QueryCollection.prototype.limit = function(n) {
            var c = this.clone();
            c._limit = n;
            return this._session.uniqueQueryCollection(c);
        };

        /**
     * Returns a new query collection which will skip the first n results
     * @param n the number of results to skip
     * @return the query collection that will skip n items
     */
        QueryCollection.prototype.skip = function(n) {
            var c = this.clone();
            c._skip = n;
            return this._session.uniqueQueryCollection(c);
        };

        /**
     * Returns a new query collection which reverse the order of the result set
     * @return the query collection that will reverse its items
     */
        QueryCollection.prototype.reverse = function() {
            var c = this.clone();
            c._reverse = true;
            return this._session.uniqueQueryCollection(c);
        };

        /**
     * Returns a new query collection which will prefetch a certain object relationship.
     * Only works with 1:1 and N:1 relations.
     * Relation must target an entity, not a mix-in.
     * @param rel the relation name of the relation to prefetch
     * @return the query collection prefetching `rel`
     */
        QueryCollection.prototype.prefetch = function (rel) {
            var c = this.clone();
            c._prefetchFields.push(rel);
            return this._session.uniqueQueryCollection(c);
        };


        /**
     * Select a subset of data, represented by this query collection as a JSON
     * structure (Javascript object)
     *
     * @param tx database transaction to use, leave out to start a new one
     * @param props a property specification
     * @param callback(result)
     */
        QueryCollection.prototype.selectJSON = function(tx, props, callback) {
            var args = argspec.getArgs(arguments, [
            {
                name: "tx",
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: "props",
                optional: false
            },
            {
                name: "callback",
                optional: false
            }
            ]);
            var session = this._session;
            var that = this;
            tx = args.tx;
            props = args.props;
            callback = args.callback;

            if(!tx) {
                session.transaction(function(tx) {
                    that.selectJSON(tx, props, callback);
                });
                return;
            }
            var Entity = getEntity(this._entityName);
            // TODO: This could do some clever prefetching to make it more efficient
            this.list(function(items) {
                var resultArray = [];
                persistence.asyncForEach(items, function(item, callback) {
                    item.selectJSON(tx, props, function(obj) {
                        resultArray.push(obj);
                        callback();
                    });
                }, function() {
                    callback(resultArray);
                });
            });
        };

        /**
     * Adds an object to a collection
     * @param obj the object to add
     */
        QueryCollection.prototype.add = function(obj) {
            if(!obj.id || !obj._type) {
                throw new Error("Cannot add object of non-entity type onto collection.");
            }
            this._session.add(obj);
            this._filter.makeFit(obj);
        }

        /**
     * Adds an an array of objects to a collection
     * @param obj the object to add
     */
        QueryCollection.prototype.addAll = function(objs) {
            for(var i = 0; i < objs.length; i++) {
                var obj = objs[i];
                this._session.add(obj);
                this._filter.makeFit(obj);
            }
        }

        /**
     * Removes an object from a collection
     * @param obj the object to remove from the collection
     */
        QueryCollection.prototype.remove = function(obj) {
            if(!obj.id || !obj._type) {
                throw new Error("Cannot remove object of non-entity type from collection.");
            }
            this._filter.makeNotFit(obj);
        }


        /**
     * A database implementation of the QueryCollection
     * @param entityName the name of the entity to create the collection for
     * @constructor
     */
        function DbQueryCollection (session, entityName) {
            this.init(session, entityName, DbQueryCollection);
        }

        /**
     * Execute a function for each item in the list. Replaces the callback below
     * which does not allow for much flexibility in argument specification.
     * @param tx the transaction to use (or null to open a new one)
     * @param callbacks Object containing up to 3 callbacks - one to execute on
     *   each element in the query collection (eachFn) one to execute at the start
     *   of the iteration (startFn, accepting the number of elements as an arg),
     *   and one to execute when the iteration is done (doneFn, also accepting the
     *   number of results as an argument).
     * @param opaque An optional parameter to supply to all callbacks.
     */
        QueryCollection.prototype.newEach = function (tx, callbacks, opaque) {
            if (tx.doneFn || tx.eachFn || tx.startFn) {
                opaque = callbacks;
                callbacks = tx;
                tx = null;
            }
            this.list(tx, function(results,error) {
                if (!results) {
                    if (error) {
                        alert(error);
                    }
                    return;
                }
                if (callbacks.startFn) {
                    callbacks.startFn(results.length, opaque);
                }
                if (callbacks.eachFn) {
                    for(var i = 0; i < results.length; i++) {
                        callbacks.eachFn(results[i], opaque);
                    }
                }
                if (callbacks.doneFn) {
                    callbacks.doneFn(i, opaque);
                }
            });
        }

        /**
     * Restrict the set of fields selected to *exclude* those provided.
     */
        QueryCollection.prototype.exclude = function(fieldList) {
            var c = this.clone();
            c._excludes = {};
            for (var i = 0; i < fieldList.length; ++i) {
                c._excludes[fieldList[i]] = true;
            }
            return c;
        },

        /**
     * Restrict the set of fields selected to *include* those provided.
     */
        QueryCollection.prototype.include = function(fieldList) {
            var c = this.clone();
            c._includes = {};
            for (var i = 0; i < fieldList.length; ++i) {
                c._includes[fieldList[i]] = true;
            }
            return c;
        },

        /**
     * Execute a function for each item in the list
     * @param tx the transaction to use (or null to open a new one)
     * @param eachFn (elem) the function to be executed for each item
     * @param doneFn (ct) called when the iteration is done, passing the number of items visited
     */
        QueryCollection.prototype.each = function (tx, eachFn, startFn, doneFn) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'eachFn',
                optional: true,
                check: argspec.isCallback()
            },
            {
                name: 'startFn',
                optional: true,
                check: argspec.isCallback()
            },
            {
                name: 'doneFn',
                optional: true,
                check: argspec.isCallback()
            }
            ]);
            tx = args.tx;
            eachFn = args.eachFn;
            startFn = args.startFn;
            doneFn = args.doneFn;

            this.list(tx, function(results,error) {
                if (!results) {
                    if (error) {
                        alert(error);
                    }
                    return;
                }
                if (startFn) {
                    startFn(results.length);
                }
                for(var i = 0; i < results.length; i++) {
                    eachFn(results[i]);
                }
                if (doneFn) {
                    doneFn(i);
                }
            });
        }

        // Alias
        QueryCollection.prototype.forEach = QueryCollection.prototype.each;

        QueryCollection.prototype.one = function (tx, oneFn) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'oneFn',
                optional: false,
                check: argspec.isCallback()
            }
            ]);
            tx = args.tx;
            oneFn = args.oneFn;

            var that = this;

            this.limit(1).list(tx, function(results) {
                if(!results || results.length === 0) {
                    oneFn(null);
                } else {
                    oneFn(results[0]);
                }
            });
        }

        DbQueryCollection.prototype = new QueryCollection();


        /**
     * An implementation of QueryCollection, that is used
     * to represent all instances of an entity type
     * @constructor
     */
        function AllDbQueryCollection (session, entityName) {
            this.init(session, entityName, AllDbQueryCollection);
        }

        AllDbQueryCollection.prototype = new DbQueryCollection();

        AllDbQueryCollection.prototype.add = function(obj) {
            this._session.add(obj);
        };

        AllDbQueryCollection.prototype.remove = function(obj) {
            this._session.remove(obj);
        };

        /**
     * A ManyToMany implementation of QueryCollection
     * @constructor
     */
        function ManyToManyDbQueryCollection (session, entityName) {
            this.init(session, entityName, persistence.ManyToManyDbQueryCollection);
            this._localAdded = [];
            this._localRemoved = [];
        }

        ManyToManyDbQueryCollection.prototype = new DbQueryCollection();

        ManyToManyDbQueryCollection.prototype.initManyToMany = function(obj, coll) {
            this._obj = obj;
            this._coll = coll;
        };

        ManyToManyDbQueryCollection.prototype.add = function(obj) {
            if(!arrayContains(this._localAdded, obj)) {
                this._session.add(obj);
                this._localAdded.push(obj);
            }
        };

        ManyToManyDbQueryCollection.prototype.addAll = function(objs) {
            for(var i = 0; i < objs.length; i++) {
                var obj = objs[i];
                if(!arrayContains(this._localAdded, obj)) {
                    this._session.add(obj);
                    this._localAdded.push(obj);
                }
            }
        }

        ManyToManyDbQueryCollection.prototype.clone = function() {
            var c = DbQueryCollection.prototype.clone.call(this);
            c._localAdded = this._localAdded;
            c._localRemoved = this._localRemoved;
            c._obj = this._obj;
            c._coll = this._coll;
            return c;
        };

        ManyToManyDbQueryCollection.prototype.remove = function(obj) {
            if(arrayContains(this._localAdded, obj)) { // added locally, can just remove it from there
                arrayRemove(this._localAdded, obj);
            } else if(!arrayContains(this._localRemoved, obj)) {
                this._localRemoved.push(obj);
            }
        };

        ////////// Local implementation of QueryCollection \\\\\\\\\\\\\\\\

        function LocalQueryCollection(initialArray) {
            this.init(persistence, null, LocalQueryCollection);
            this._items = initialArray || [];
        }

        LocalQueryCollection.prototype = new QueryCollection();

        LocalQueryCollection.prototype.clone = function() {
            var c = DbQueryCollection.prototype.clone.call(this);
            c._items = this._items;
            return c;
        };

        LocalQueryCollection.prototype.add = function(obj) {
            if(!arrayContains(this._items, obj)) {
                this._session.add(obj);
                this._items.push(obj);
            }
        };

        LocalQueryCollection.prototype.addAll = function(objs) {
            for(var i = 0; i < objs.length; i++) {
                var obj = objs[i];
                if(!arrayContains(this._items, obj)) {
                    this._session.add(obj);
                    this._items.push(obj);
                }
            }
        }

        LocalQueryCollection.prototype.remove = function(obj) {
            var items = this._items;
            for(var i = 0; i < items.length; i++) {
                if(items[i] === obj) {
                    this._items.splice(i, 1);
                }
            }
        };

        LocalQueryCollection.prototype.list = function(tx, callback) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'callback',
                optional: true,
                check: argspec.isCallback()
            }
            ]);
            callback = args.callback;

            if(!callback || callback.executeSql) { // first argument is transaction
                callback = arguments[1]; // set to second argument
            }
            var array = this._items.slice(0);
            var that = this;
            var results = [];
            for(var i = 0; i < array.length; i++) {
                if(this._filter.match(array[i])) {
                    results.push(array[i]);
                }
            }
            results.sort(function(a, b) {
                for(var i = 0; i < that._orderColumns.length; i++) {
                    var col = that._orderColumns[i][0];
                    var asc = that._orderColumns[i][1];
                    var sens = that._orderColumns[i][2];
                    var aVal = persistence.get(a, col);
                    var bVal = persistence.get(b, col);
                    if (!sens) {
                        if (Helix.Utils.isString(aVal)) {
                            aVal = aVal.toLowerCase();
                            bVal = bVal.toLowerCase();                            
                        }
                    }
                    if(aVal < bVal) {
                        return asc ? -1 : 1;
                    } else if(aVal > bVal) {
                        return asc ? 1 : -1;
                    }
                }
                return 0;
            });
            if(this._skip) {
                results.splice(0, this._skip);
            }
            if(this._limit > -1) {
                results = results.slice(0, this._limit);
            }
            if(this._reverse) {
                results.reverse();
            }
            if(callback) {
                callback(results);
            } else {
                return results;
            }
        };

        LocalQueryCollection.prototype.destroyAll = function(callback) {
            if(!callback || callback.executeSql) { // first argument is transaction
                callback = arguments[1]; // set to second argument
            }
            this._items = [];
            if(callback) callback();
        };

        LocalQueryCollection.prototype.count = function(tx, callback) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'tx',
                optional: true,
                check: persistence.isTransaction,
                defaultValue: null
            },
            {
                name: 'callback',
                optional: true,
                check: argspec.isCallback()
            }
            ]);
            tx = args.tx;
            callback = args.callback;

            var result = this.list();

            if(callback) {
                callback(result.length);
            } else {
                return result.length;
            }
        };

        persistence.QueryCollection             = QueryCollection;
        persistence.DbQueryCollection           = DbQueryCollection;
        persistence.ManyToManyDbQueryCollection = ManyToManyDbQueryCollection;
        persistence.LocalQueryCollection        = LocalQueryCollection;
        persistence.Observable                  = Observable;
        persistence.Subscription                = Subscription;
        persistence.AndFilter                   = AndFilter;
        persistence.OrFilter                    = OrFilter;
        persistence.PropertyFilter              = PropertyFilter;
    }());

    // ArgSpec.js library: http://github.com/zefhemel/argspecjs
    var argspec = {};

    (function() {
        argspec.getArgs = function(args, specs) {
            var argIdx = 0;
            var specIdx = 0;
            var argObj = {};
            while(specIdx < specs.length) {
                var s = specs[specIdx];
                var a = args[argIdx];
                if(s.optional) {
                    if(a !== undefined && s.check(a)) {
                        argObj[s.name] = a;
                        argIdx++;
                        specIdx++;
                    } else {
                        if(s.defaultValue !== undefined) {
                            argObj[s.name] = s.defaultValue;
                        }
                        specIdx++;
                    }
                } else {
                    if(s.check && !s.check(a)) {
                        throw new Error("Invalid value for argument: " + s.name + " Value: " + a);
                    }
                    argObj[s.name] = a;
                    specIdx++;
                    argIdx++;
                }
            }
            return argObj;
        }

        argspec.hasProperty = function(name) {
            return function(obj) {
                return obj && obj[name] !== undefined;
            };
        }

        argspec.hasType = function(type) {
            return function(obj) {
                return typeof obj === type;
            };
        }

        argspec.isCallback = function() {
            return function(obj) {
                return obj && obj.apply;
            };
        }
        
        argspec.isMap = function() {
            return function(obj) {
                return obj && Object.prototype.toString.call(obj) == "[object Object]";
            }
        }
    }());

    persistence.argspec = argspec;

    return persistence;
} // end of createPersistence



// JSON2 library, source: http://www.JSON.org/js.html
// Most modern browsers already support this natively, but mobile
// browsers often don't, hence this implementation
// Relevant APIs:
//    JSON.stringify(value, replacer, space)
//    JSON.parse(text, reviver)

if(typeof JSON === 'undefined') {
    JSON = {};
}
//var JSON = typeof JSON === 'undefined' ? window.JSON : {};
if (!JSON.stringify) {
    (function () {
        function f(n) {
            return n < 10 ? '0' + n : n;
        }
        if (typeof Date.prototype.toJSON !== 'function') {

            Date.prototype.toJSON = function (key) {

                return isFinite(this.valueOf()) ?
                this.getUTCFullYear()   + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
            };

            String.prototype.toJSON =
            Number.prototype.toJSON =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
        }

        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap, indent,
        meta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;

        function quote(string) {
            escapable.lastIndex = 0;
            return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
        }


        function str(key, holder) {
            var i, k, v, length, mind = gap, partial, value = holder[key];

            if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }

            if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
            }

            switch (typeof value) {
                case 'string':
                    return quote(value);
                case 'number':
                    return isFinite(value) ? String(value) : 'null';
                case 'boolean':
                case 'null':
                    return String(value);
                case 'object':
                    if (!value) {
                        return 'null';
                    }

                    gap += indent;
                    partial = [];

                    if (Object.prototype.toString.apply(value) === '[object Array]') {
                        length = value.length;
                        for (i = 0; i < length; i += 1) {
                            partial[i] = str(i, value) || 'null';
                        }

                        v = partial.length === 0 ? '[]' :
                        gap ? '[\n' + gap +
                        partial.join(',\n' + gap) + '\n' +
                        mind + ']' :
                        '[' + partial.join(',') + ']';
                        gap = mind;
                        return v;
                    }

                    if (rep && typeof rep === 'object') {
                        length = rep.length;
                        for (i = 0; i < length; i += 1) {
                            k = rep[i];
                            if (typeof k === 'string') {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    } else {
                        for (k in value) {
                            if (Object.hasOwnProperty.call(value, k)) {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    }

                    v = partial.length === 0 ? '{}' :
                    gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                    mind + '}' : '{' + partial.join(',') + '}';
                    gap = mind;
                    return v;
            }
        }

        if (typeof JSON.stringify !== 'function') {
            JSON.stringify = function (value, replacer, space) {
                var i;
                gap = '';
                indent = '';
                if (typeof space === 'number') {
                    for (i = 0; i < space; i += 1) {
                        indent += ' ';
                    }
                } else if (typeof space === 'string') {
                    indent = space;
                }

                rep = replacer;
                if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                        typeof replacer.length !== 'number')) {
                    throw new Error('JSON.stringify');
                }

                return str('', {
                    '': value
                });
            };
        }

        if (typeof JSON.parse !== 'function') {
            JSON.parse = function (text, reviver) {
                var j;
                function walk(holder, key) {
                    var k, v, value = holder[key];
                    if (value && typeof value === 'object') {
                        for (k in value) {
                            if (Object.hasOwnProperty.call(value, k)) {
                                v = walk(value, k);
                                if (v !== undefined) {
                                    value[k] = v;
                                } else {
                                    delete value[k];
                                }
                            }
                        }
                    }
                    return reviver.call(holder, key, value);
                }

                cx.lastIndex = 0;
                if (cx.test(text)) {
                    text = text.replace(cx, function (a) {
                        return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                    });
                }

                if (/^[\],:{}\s]*$/.
                    test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
                        replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
                        replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
                    j = eval('(' + text + ')');
                    return typeof reviver === 'function' ?
                    walk({
                        '': j
                    }, '') : j;
                }
                throw new SyntaxError('JSON.parse');
            };
        }
    }());
}

;/**
 * @license
 * Copyright (c) 2010 Fbio Rehm <fgrehm@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
function definePersistenceMigrations() {
  
    var Migrator = {
        migrations: [],
      
        version: function(t, callback) {
            if (!t) {
                persistence.transaction(function(tx){
                    Migrator.version(tx, callback);
                });
                return;
            }
          
            t.executeSql('SELECT current_version FROM schema_version', null, function(result){
                if (result.length == 0) {
                    t.executeSql('INSERT INTO schema_version VALUES (0)', null, function(){
                        callback(0);
                    });
                } else {
                    callback(result[0].current_version);
                }
            });
        },
      
        setVersion: function(allMigrations, v) {
            Migrator._version = v;
            allMigrations.unshift(['UPDATE schema_version SET current_version = ?', [v]]);
        },
      
        setup: function(t, callback) {
            if (!t) {
                persistence.transaction(function(tx){
                    Migrator.setup(tx, callback);
                });
                return;
            }
            t.executeSql('CREATE TABLE IF NOT EXISTS schema_version (current_version INTEGER)', null, function(){
                // Creates a dummy migration just to force setting schema version when cleaning DB
                Migrator.migration(0, {
                    up: function() { }, 
                    down: function() { }
                });
                if (callback) callback();
            });
        },
      
        // Method should only be used for testing
        reset: function() {
            // Creates a dummy migration just to force setting schema version when cleaning DB
            Migrator.migrations = [];
            Migrator.migration(0, {
                up: function() { }, 
                down: function() { }
            });
            Migrator.setVersion(allMigrations, 0);
        },
      
        migration: function(version, actions) {
            Migrator.migrations[version] = new Migration(version, actions);
            return Migrator.migrations[version];
        },
      
        migrateUpTo: function(allMigrations, curVersion, version) {
            var migrationsToRun = [];
            
            for (var v = curVersion + 1; v <= version; ++v) {
                migrationsToRun.push(Migrator.migrations[v]);
            }
                
            for (var i = 0; i < migrationsToRun.length; ++i) {
                var migration = migrationsToRun[i];
                migration.up(allMigrations);
            }
        },
      
        migrateDownTo: function(allMigrations, curVersion, version) {
            var migrationsToRun = [];
            
            for (var v = curVersion; v > version; v--) {
                migrationsToRun.push(Migrator.migrations[v]);
            }
                
            for (var i = 0; i < migrationsToRun.length; ++i) {
                var migration = migrationsToRun[i];
                migration.down(allMigrations);
            }
        },
      
        migrate: function(curVersion, newVersion) {
            var allMigrations = [];
            if (curVersion < newVersion)
                Migrator.migrateUpTo(allMigrations, curVersion, newVersion);
            else if (curVersion > newVersion)
                Migrator.migrateDownTo(allMigrations, curVersion, newVersion);
            else
                return;
            
            persistence.nextSchemaSyncHooks.push(function() {
                return allMigrations;
            });
        }
    }
    
    var Migration = function(version, body) {
        this.version = version;
        // TODO check if actions contains up and down methods
        this.body = body;
        this.actions = [];
    };
    
    Migration.prototype.executeActions = function(allMigrations, customVersion) {
        var actionsToRun = this.actions;
        var version = (customVersion!==undefined) ? customVersion : this.version;
      
        for (var i = 0; i < actionsToRun.length; ++i) {
            var action = actionsToRun[i];
            action(allMigrations);
        }
        Migrator.setVersion(allMigrations, version);
    }
    
    Migration.prototype.up = function(allMigrations) {
        if (this.body.up) {
            this.body.up.apply(this, allMigrations);
        }
        this.executeActions(allMigrations);
    }
    
    Migration.prototype.down = function(allMigrations) {
        if (this.body.down) {
            this.body.down.apply(this, allMigrations);
        }
        this.executeActions(allMigrations, this.version-1);
    }
    
    Migration.prototype.createTable = function(tableName, callback) {
        var table = new ColumnsHelper();
      
        if (callback) callback(table);
      
        var column;
        var sql = 'CREATE TABLE `' + tableName + '` (id VARCHAR(32) PRIMARY KEY';
        while (column = table.columns.pop()) {
            sql += ', ' + column;
        }
      
        this.executeSql(sql + ')');
    }
    
    Migration.prototype.dropTable = function(tableName) {
        var sql = 'DROP TABLE `' + tableName + '`';
        this.executeSql(sql);
    }
    
    Migration.prototype.updateColumns = function(allColumns, allOldColumns, tableName) {
        this.action(function(arr){
            var columnsSql = [];
            var selectColumns = [];
            for (var col in allColumns) {
                var colTarget = allColumns[col];
                if (Helix.Utils.isString(colTarget)) {
                    columnsSql.push(col + " " + colTarget);
                } else {
                    // This is a relationship column.
                    columnsSql.push(col + " VARCHAR(32)");
                }
                
                if (col in allOldColumns) {
                    selectColumns.push(col);
                } else {
                    selectColumns.push('NULL');
                }
            }
            // Add the 'id' column that exists on all tables managed by persistence JS.
            columnsSql.push('id VARCHAR(32) PRIMARY KEY');
            selectColumns.push('id');
            
            columnsSql = columnsSql.join(', ');
            selectColumns = selectColumns.join(', ');

            arr.unshift(["ALTER TABLE `" + tableName + "` RENAME TO `" + tableName + "_bkp`;", null]);
            arr.unshift(["CREATE TABLE `" + tableName + "` (" + columnsSql + ");", null]);
            arr.unshift(["INSERT INTO `" + tableName + "` SELECT " + selectColumns + " FROM `" + tableName + "_bkp`;", null]);
            arr.unshift(["DROP TABLE `" + tableName + "_bkp`;", null]);
        });
    }
    
    Migration.prototype.addIndex = function(tableName, columnName, unique) {
        var sql = 'CREATE ' + (unique === true ? 'UNIQUE' : '') + ' INDEX `' + tableName + '_' + columnName + '` ON `' + tableName + '` (' + columnName + ')';
        this.executeSql(sql);
    }
    
    Migration.prototype.removeIndex = function(tableName, columnName) {
        var sql = 'DROP INDEX `' + tableName + '_' + columnName + '`';
        this.executeSql(sql);
    }
    
    Migration.prototype.executeSql = function(sql, args) {
        this.action(function(arr){
            arr.unshift([sql, args]);
        });
    }
    
    Migration.prototype.action = function(callback) {
        this.actions.unshift(callback);
    }
    
    var ColumnsHelper = function() {
        this.columns = [];
    }
    
    ColumnsHelper.prototype.text = function(columnName) {
        this.columns.unshift(columnName + ' TEXT');
    }
    
    ColumnsHelper.prototype.integer = function(columnName) {
        this.columns.unshift(columnName + ' INT');
    }
    
    ColumnsHelper.prototype.real = function(columnName) {
        this.columns.unshift(columnName + ' REAL');
    }
    
    ColumnsHelper.prototype['boolean'] = function(columnName) {
        this.columns.unshift(columnName + ' BOOL');
    }
    
    ColumnsHelper.prototype.date = function(columnName) {
        this.columns.unshift(columnName + ' DATE');
    }
    
    ColumnsHelper.prototype.json = function(columnName) {
        this.columns.unshift(columnName + ' TEXT');
    }
    
    // Makes Migrator and Migration available to tests
    persistence.migrations = {};
    persistence.migrations.Migrator = Migrator;
    persistence.migrations.Migration = Migration;
    persistence.migrations.init = function() {
        Migrator.setup.apply(Migrator, Array.prototype.slice.call(arguments, 0))
    };
    
    persistence.migrate = function() {
        Migrator.migrate.apply(Migrator, Array.prototype.slice.call(arguments, 0))
    };
    persistence.defineMigration = function() {
        Migrator.migration.apply(Migrator, Array.prototype.slice.call(arguments, 0))
    };
    
}
;/**
 * Default type mapper. Override to support more types or type options.
 */
var defaultTypeMapper = {
    /**
   * SQL type for ids
   */
    idType: "VARCHAR(32)",

    /**
   * SQL type for class names (used by mixins)
   */
    classNameType: "TEXT",

    /**
   * Returns SQL type for column definition
   */
    columnType: function(type){
        switch(type) {
            case 'JSON':
                return 'TEXT';
            case 'BOOL':
                return 'INT';
            case 'DATE':
                return 'INT';
            default:
                return type;
        }
    },

    inVar: function(str, type){
        return str;
    },
    outVar: function(str, type){
        return str;
    },
    outId: function(str){
        return "'" + str + "'";
    },
    /**
   * Converts a value from the database to a value suitable for the entity
   * (also does type conversions, if necessary)
   */
    dbValToEntityVal: function(val, type){
        if (val === null || val === undefined) {
            return val;
        }
        switch (type) {
            case 'DATE':
                // SQL is in seconds and JS in miliseconds
                if (val > 1000000000000) {
                    // usually in seconds, but sometimes it's milliseconds
                    return new Date(parseInt(val, 10));
                } else {
                    return new Date(parseInt(val, 10) * 1000);
                }
            case 'BOOL':
                return val === 1 || val === '1';
                break;
            case 'INT':
                return +val;
                break;
            case 'BIGINT':
                return +val;
                break;
            case 'JSON':
                if (val) {
                    return JSON.parse(val);
                }
                else {
                    return val;
                }
                break;
            default:
                return val;
        }
    },

    /**
   * Converts an entity value to a database value, inverse of
   *   dbValToEntityVal
   */
    entityValToDbVal: function(val, type){
        if (val === undefined || val === null) {
            return null;
        }
        else if (type === 'JSON' && val) {
            return JSON.stringify(val);
        }
        else if (val.id) {
            return val.id;
        }
        else if (type === 'BOOL') {
            if (val === 'false' || val === 'f' || val === '0') {
                return false;
            } else if (val === 'true' || val === 't' || val === '1') {
                return true;
            }
        
            return (val ? 1 : 0);
        }
        else if (type === 'DATE' || val.getTime) {
            // In order to make SQLite Date/Time functions work we should store
            // values in seconds and not as miliseconds as JS Date.getTime()
            val = new Date(val);
            return Math.round(val.getTime() / 1000);
        }
        else if (type === 'INT' && Helix.Utils.isString(val)) {
            return parseInt(val);
        }
        else {
            return val;
        }
    },
    /**
   * Shortcut for inVar when type is id -- no need to override
   */
    inIdVar: function(str){
        return this.inVar(str, this.idType);
    },
    /**
   * Shortcut for outVar when type is id -- no need to override
   */
    outIdVar: function(str){
        return this.outVar(str, this.idType);
    },
    /**
   * Shortcut for entityValToDbVal when type is id -- no need to override
   */
    entityIdToDbId: function(id){
        return this.entityValToDbVal(id, this.idType);
    }
}

function config(persistence, dialect) {
    var argspec = persistence.argspec;

    persistence.typeMapper = dialect.typeMapper || defaultTypeMapper;

    persistence.generatedTables = {}; // set

    /**
   * Synchronize the data model with the database, creates table that had not
   * been defined before
   *
   * @param tx
   *            transaction object to use (optional)
   * @param callback
   *            function to be called when synchronization has completed,
   *            takes started transaction as argument
   */
    persistence.schemaSync = function (tx, callback, emulate) {
        var args = argspec.getArgs(arguments, [
        {
            name: "tx", 
            optional: true, 
            check: persistence.isTransaction, 
            defaultValue: null
        },
        {
            name: "callback", 
            optional: true, 
            check: argspec.isCallback(), 
            defaultValue: function(){}
        },

        {
            name: "emulate", 
            optional: true, 
            check: argspec.hasType('boolean')
        }
        ]);
        tx = args.tx;
        callback = args.callback;
        emulate = args.emulate;

        if(!tx) {
            var session = this;
            this.transaction(function(tx) {
                session.schemaSync(tx, callback, emulate);
            });
            return;
        }
        var queries = [], meta, colDefs, otherMeta, tableName;

        var tm = persistence.typeMapper;
        var entityMeta = persistence.getEntityMeta();
        for (var entityName in entityMeta) {
            if (entityMeta.hasOwnProperty(entityName)) {
                meta = entityMeta[entityName];
                if (!meta.isMixin) {
                    colDefs = [];
                    for (var prop in meta.fields) {
                        if (meta.fields.hasOwnProperty(prop)) {
                            colDefs.push([prop, meta.fields[prop]]);
                        }
                    }
                    for (var rel in meta.hasOne) {
                        if (meta.hasOne.hasOwnProperty(rel)) {
                            otherMeta = meta.hasOne[rel].type.meta;
                            colDefs.push([rel, tm.idType]);
                            if (!persistence.generatedTables[meta.name]) {
                                queries.push([dialect.createIndex(meta.name, [rel]), null]);
                            }
                        }
                    }
                    if (!persistence.generatedTables[meta.name]) {
                        for (var i = 0; i < meta.indexes.length; i++) {
                            queries.push([dialect.createIndex(meta.name, meta.indexes[i].columns, meta.indexes[i]), null]);
                        }
                    }
                }
                for (var rel in meta.hasMany) {
                    if (meta.hasMany.hasOwnProperty(rel) && meta.hasMany[rel].manyToMany) {
                        tableName = meta.hasMany[rel].tableName;
                        if (!persistence.generatedTables[tableName]) {
                            var otherMeta = meta.hasMany[rel].type.meta;
                            var inv = meta.hasMany[rel].inverseProperty;
                            // following test ensures that mixin mtm tables get created with the mixin itself
                            // it seems superfluous because mixin will be processed before entitites that use it
                            // but better be safe than sorry.
                            if (otherMeta.hasMany[inv].type.meta != meta)
                                continue;
                            var p1 = meta.name + "_" + rel;
                            var p2 = otherMeta.name + "_" + inv;
                            queries.push([dialect.createIndex(tableName, [p1]), null]);
                            queries.push([dialect.createIndex(tableName, [p2]), null]);
                            var columns = [[p1, tm.idType], [p2, tm.idType]];
                            if (meta.isMixin)
                                columns.push([p1 + "_class", tm.classNameType])
                            if (otherMeta.isMixin)
                                columns.push([p2 + "_class", tm.classNameType])
                            queries.push([dialect.createTable(tableName, columns), null]);
                            persistence.generatedTables[tableName] = true;
                        }
                    }
                }
                if (!meta.isMixin && !persistence.generatedTables[meta.name]) {
                    colDefs.push(["id", tm.idType, "PRIMARY KEY"]);
                    persistence.generatedTables[meta.name] = true;
                    queries.push([dialect.createTable(meta.name, colDefs), null]);
                }
            }
        }
        var fns = persistence.schemaSyncHooks;
        for(var i = 0; i < fns.length; i++) {
            var moreQueries = fns[i](tx);
            if (moreQueries) {
                queries = queries.concat(moreQueries);
            }
        }
        fns = persistence.nextSchemaSyncHooks;
        for(i = 0; i < fns.length; i++) {
            moreQueries = fns[i](tx);
            if (moreQueries) {
                queries = queries.concat(moreQueries);
            }
        }
        // Only run on 1 sync.
        persistence.nextSchemaSyncHooks = [];
        if(emulate) {
            // Done
            callback(tx);
        } else {
            executeQueriesSeq(tx, queries, function(_, err) {
                callback(tx, err);
            });
        }
    };

    /**
   * Persists all changes to the database transaction
   *
   * @param tx
   *            transaction to use
   * @param callback
   *            function to be called when done
   * @param stopTracking
   *            indicate that we want to stop tracking the objects we flush; default
   *            is true, unless false is specified explicitly
   */
    persistence.flush = function (tx, callback, stopTracking) {
        var args = argspec.getArgs(arguments, [
        {
            name: "tx", 
            optional: true, 
            check: persistence.isTransaction
        },
        {
            name: "callback", 
            optional: true, 
            check: argspec.isCallback(), 
            defaultValue: null
        }
        ]);
        tx = args.tx;
        callback = args.callback;

        var session = this;
        if(!tx) {
            this.transaction(function(tx) {
                session.flush(tx, callback);
            });
            return;
        }
        // SAH - eliminate flush hooks. We want to add as many statements into a single
        // txn as possible. Allowing asynchronous delays can cause a transaction to flush
        // before we add required statements to it. Users of this API need to find another
        // way to 
        var persistObjArray = [];
        for (var id in session.trackedObjects) {
            if (session.trackedObjects.hasOwnProperty(id)) {
                persistObjArray.push(session.trackedObjects[id]);
            }
        }
        var removeObjArray = [];
        for (var id in session.objectsToRemove) {
            if (session.objectsToRemove.hasOwnProperty(id)) {
                removeObjArray.push(session.objectsToRemove[id]);
                delete session.trackedObjects[id]; // Stop tracking
            }
        }
        session.objectsToRemove = {};
        if(callback) {
            persistence.asyncParForEach(removeObjArray, function(obj, callback) {
                remove(obj, tx, callback);
            }, function(result, err, _persistArr) {
                if (err) return callback(result, err);
                persistence.asyncParForEach(_persistArr, function(obj, callback) {
                    save(obj, tx, callback);
                }, function() {
                    if (stopTracking === true ||
                        stopTracking === undefined) {
                        for (i = 0; i < _persistArr.length; ++i) {
                            id = _persistArr[i].id;
                            delete session.trackedObjects[id];            
                        }         
                    }
                    
                    callback();
                });
                return true;
            }, persistObjArray);
        } else { // More efficient
            for(var i = 0; i < persistObjArray.length; i++) {
                save(persistObjArray[i], tx);
            }
            for(var i = 0; i < removeObjArray.length; i++) {
                remove(removeObjArray[i], tx);
            }
        
            // Stop tracking everything we flushed.
            if (stopTracking === true ||
                stopTracking === undefined) {
                for (i = 0; i < persistObjArray.length; ++i) {
                    id = persistObjArray[i].id;
                    delete session.trackedObjects[id];            
                }         
            }
        }
    };

    /**
   * Remove all tables in the database (as defined by the model)
   */
    persistence.reset = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
        {
            name: "tx", 
            optional: true, 
            check: persistence.isTransaction, 
            defaultValue: null
        },
        {
            name: "callback", 
            optional: true, 
            check: argspec.isCallback(), 
            defaultValue: function(){}
        }
        ]);
        tx = args.tx;
        callback = args.callback;

        var session = this;
        if(!tx) {
            session.transaction(function(tx) {
                session.reset(tx, callback);
            });
            return;
        }
        // First emulate syncing the schema (to know which tables were created)
        this.schemaSync(tx, function() {
            var tableArray = [];
            for (var p in persistence.generatedTables) {
                if (persistence.generatedTables.hasOwnProperty(p)) {
                    tableArray.push(p);
                }
            }
            function dropOneTable () {
                var tableName = tableArray.pop();
                tx.executeSql("DROP TABLE IF EXISTS `" + tableName + "`", null, function () {
                    if (tableArray.length > 0) {
                        dropOneTable();
                    } else {
                        cb();
                    }
                }, cb);
            }
            if(tableArray.length > 0) {
                dropOneTable();
            } else {
                cb();
            }

            function cb(result, err) {
                session.clean();
                persistence.generatedTables = {};
                if (callback) callback(result, err);
            }
        }, true);
    };

    /**
   * Converts a database row into an entity object
   */
    function rowToEntity(session, entityName, row, prefix) {
        prefix = prefix || '';
        var tm = persistence.typeMapper;
        var rowMeta = persistence.getMeta(entityName);
        var ent = persistence.define(entityName); // Get entity
        if(!row[prefix+'id']) { // null value, no entity found
            return null;
        }
        var o = null;
        if (session.trackedObjects[row[prefix + "id"]]) { // Cached version
            o = session.trackedObjects[row[prefix + "id"]];
        } else {
            o = new ent(session, undefined, true);
        }
        o.id = tm.dbValToEntityVal(row[prefix + 'id'], tm.idType);
        o._new = false;
        for ( var p in row) {
            if (row.hasOwnProperty(p)) {
                if (p.substring(0, prefix.length) === prefix) {
                    var prop = p.substring(prefix.length);
                    if (prop != 'id') {
                        o._data[prop] = tm.dbValToEntityVal(row[p], rowMeta.fields[prop] || tm.idType);
                    }
                }
            }
        }
        return o;
    }

    function saveObj(obj, tx, callback, properties, values, propertyPairs, qs) {
        var meta = persistence.getMeta(obj._type);
        var tm = persistence.typeMapper;
    
        obj._dirtyProperties = {};
        if (obj._new) {
            properties.push('id');
            values.push(tm.entityIdToDbId(obj.id));
            qs.push(tm.outIdVar('?'));
            var sql = "INSERT INTO `" + obj._type + "` (" + properties.join(", ") + ") VALUES (" + qs.join(', ') + ")";
            obj._new = false;
            tx.executeSql(sql, values, callback, function(t, e, badSQL, badArgs) {
                persistence.errorHandler(e.message, e.code);
                callback();                  
                return false;
            });
        } else if (propertyPairs.length > 0) {
            sql = "UPDATE `" + obj._type + "` SET " + propertyPairs.join(',') + " WHERE id = " + tm.outId(obj.id);
            tx.executeSql(sql, values, callback, callback);
        } else {
            // Nothing to do. Just call the callback.
            if (callback) {
                callback();
            }
        }
    }

    /**
   * Internal function to persist an object to the database
   * this function is invoked by persistence.flush()
   */
    function save(obj, tx, callback) {
        var meta = persistence.getMeta(obj._type);
        var tm = persistence.typeMapper;
        var properties = [];
        var values = [];
        var qs = [];
        var propertyPairs = [];
        if(obj._new) { // Mark all properties dirty
            for (var p in meta.fields) {
                if(meta.fields.hasOwnProperty(p)) {
                    obj._dirtyProperties[p] = true;
                }
            }
        }
        for ( var p in obj._dirtyProperties) {
            if (obj._dirtyProperties.hasOwnProperty(p) && !(obj._ignoreProperties[p])) {
                properties.push("`" + p + "`");
                var type = meta.fields[p] || tm.idType;
                values.push(tm.entityValToDbVal(obj._data[p], type));
                qs.push(tm.outVar("?", type));
                propertyPairs.push("`" + p + "` = " + tm.outVar("?", type));
            }
        }
        var additionalQueries = [];
        for(var p in meta.hasMany) {
            if(meta.hasMany.hasOwnProperty(p)) {
                additionalQueries = additionalQueries.concat(persistence.get(obj, p).persistQueries());
            }
        }
        /*executeQueriesSeq(tx, additionalQueries, function(obj, callback, properties, values, propertyPairs, qs) {
        if (!obj._new && properties.length === 0) { // Nothing changed and not new
          if(callback) callback();
          return;
        }
        saveObj(obj, tx, callback, properties, values, propertyPairs, qs);
      }, obj, callback, properties, values, propertyPairs, qs);*/

        // Note that everything we do here is in 1 txn. We don't need to ensure that an object's
        // one-to-many targets are inserted before the object is inserted. We just need to make
        // sure that we don't assume the insert is done and invoke the callback until all one-to-many
        // objects are in the DB.
        var nQueries = additionalQueries.length + 1; // 1 extra for the insert/update of this object.
        var nDone = 0;
        var __callback = function() {
            ++nDone;
            if (nQueries == nDone && callback) {
                callback();
            }
        };
    
        for (var i = 0; i < additionalQueries.length; ++i) {
            var queryTuple = additionalQueries[i];
            tx.executeSql(queryTuple[0], queryTuple[1], __callback, function(_, err) {
                persistence.errorHandler(err.message, err.code);
                __callback();
            });
        }
    
        saveObj(obj, tx, __callback, properties, values, propertyPairs, qs);
    }

    persistence.save = save;

    function remove (obj, tx, callback) {
        var meta = persistence.getMeta(obj._type);
        var tm = persistence.typeMapper;
        var queries = [["DELETE FROM `" + obj._type + "` WHERE id = " + tm.outId(obj.id), null]];
        for (var rel in meta.hasMany) {
            if (meta.hasMany.hasOwnProperty(rel) && meta.hasMany[rel].manyToMany) {
                var tableName = meta.hasMany[rel].tableName;
                //var inverseProperty = meta.hasMany[rel].inverseProperty;
                queries.push(["DELETE FROM `" + tableName + "` WHERE `" + meta.name + '_' + rel + "` = " + tm.outId(obj.id), null]);
            }
        }
        executeQueriesSeq(tx, queries, callback);
    }

    /**
   * Utility function to execute a series of queries in an asynchronous way
   * @param tx the transaction to execute the queries on
   * @param queries an array of [query, args] tuples
   * @param callback the function to call when all queries have been executed
   * @param delay Small delay to introduce in between statements; optional.
   */
    function executeQueriesSeq (tx, queries, callback, delay) {
        // queries.reverse();
        var callbackArgs = [];
        for ( var i = 4; i < arguments.length; i++) {
            callbackArgs.push(arguments[i]);
        }
        persistence.asyncForEach(queries, function(queryTuple, callback) {
            tx.executeSql(queryTuple[0], queryTuple[1], callback, function(_, err, query) {
                var msg = err.message + ' when executing query ' + query;
                console.log(msg);
                if(delay) {
                    setTimeout(function() {
                        callback(_, msg);
                    }, delay);
                } else {
                    callback(_, msg);
                }
            });
        }, function(result, err) {
            if (err && callback) {
                callback(result, err);
                return;
            }
            if(callback) callback.apply(null, callbackArgs);
        });
    }

    persistence.executeQueriesSeq = executeQueriesSeq;

    /////////////////////////// QueryCollection patches to work in SQL environment

    /**
   * Function called when session is flushed, returns list of SQL queries to execute
   * (as [query, arg] tuples)
   */
    persistence.QueryCollection.prototype.persistQueries = function() {
        return [];
    };

    var oldQCClone = persistence.QueryCollection.prototype.clone;

    persistence.QueryCollection.prototype.clone = function (cloneSubscribers) {
        var c = oldQCClone.call(this, cloneSubscribers);
        c._additionalJoinSqls = this._additionalJoinSqls.slice(0);
        c._additionalWhereSqls = this._additionalWhereSqls.slice(0);
        c._additionalGroupSqls = this._additionalGroupSqls.slice(0);
        c._manyToManyFetch = this._manyToManyFetch;
        return c;
    };

    var oldQCInit = persistence.QueryCollection.prototype.init;

    persistence.QueryCollection.prototype.init = function(session, entityName, constructor) {
        oldQCInit.call(this, session, entityName, constructor);
        this._manyToManyFetch = null;
        this._additionalJoinSqls = [];
        this._additionalWhereSqls = [];
        this._additionalGroupSqls = [];
    };

    var oldQCToUniqueString = persistence.QueryCollection.prototype.toUniqueString;

    persistence.QueryCollection.prototype.toUniqueString = function() {
        var s = oldQCToUniqueString.call(this);
        s += '|JoinSQLs:';
        for(var i = 0; i < this._additionalJoinSqls.length; i++) {
            s += this._additionalJoinSqls[i];
        }
        s += '|WhereSQLs:';
        for(var i = 0; i < this._additionalWhereSqls.length; i++) {
            s += this._additionalWhereSqls[i];
        }
        s += '|GroupSQLs:';
        for(var i = 0; i < this._additionalGroupSqls.length; i++) {
            s += this._additionalGroupSqls[i];
        }
        if(this._manyToManyFetch) {
            s += '|ManyToManyFetch:';
            s += JSON.stringify(this._manyToManyFetch); // TODO: Do something more efficient
        }
        return s;
    };

    persistence.NullFilter.prototype.sql = function (meta, alias, values) {
        return "1=1";
    };

    persistence.AndFilter.prototype.sql = function (meta, alias, values) {
        return "(" + this.left.sql(meta, alias, values) + " AND "
        + this.right.sql(meta, alias, values) + ")";
    };

    persistence.OrFilter.prototype.sql = function (meta, alias, values) {
        return "(" + this.left.sql(meta, alias, values) + " OR "
        + this.right.sql(meta, alias, values) + ")";
    };

    persistence.PropertyFilter.prototype.sql = function (meta, alias, values) {
        var tm = persistence.typeMapper;
        var aliasPrefix = alias ? "`" + alias + "`." : "";
        var sqlType = meta.fields[this.property] || tm.idType;
        if (this.operator === '=' && this.value === null) {
            return aliasPrefix + '`' + this.property + "` IS NULL";
        } else if (this.operator === '!=' && this.value === null) {
            return aliasPrefix + '`' + this.property + "` IS NOT NULL";
        } else if (this.operator === 'in') {
            var vals = this.value;
            var qs = [];
            for(var i = 0; i < vals.length; i++) {
                qs.push('?');
                values.push(tm.entityValToDbVal(vals[i], sqlType));
            }
            if(vals.length === 0) {
                // Optimize this a little
                return "1 = 0";
            } else {
                return aliasPrefix + '`' + this.property + "` IN (" + qs.join(', ') + ")";
            }
        } else if (this.operator === 'not in') {
            var vals = this.value;
            var qs = [];
            for(var i = 0; i < vals.length; i++) {
                qs.push('?');
                values.push(tm.entityValToDbVal(vals[i], sqlType));
            }

            if(vals.length === 0) {
                // Optimize this a little
                return "1 = 1";
            } else {
                return aliasPrefix + '`' + this.property + "` NOT IN (" + qs.join(', ') + ")";
            }
        } else {
            var value = this.value;
            if(value === true || value === false) {
                value = value ? 1 : 0;
            }
            values.push(tm.entityValToDbVal(value, sqlType));
            return aliasPrefix + '`' + this.property + "` " + this.operator + " " + tm.outVar("?", sqlType);
        }
    };

    // QueryColleciton's list

    /**
   * Asynchronous call to actually fetch the items in the collection
   * @param tx transaction to use
   * @param callback function to be called taking an array with
   *   result objects as argument
   */
    persistence.DbQueryCollection.prototype.list = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
        {
            name: 'tx', 
            optional: true, 
            check: persistence.isTransaction, 
            defaultValue: null
        },
        {
            name: 'callback', 
            optional: false, 
            check: argspec.isCallback()
        }
        ]);
        tx = args.tx;
        callback = args.callback;

        var that = this;
        var session = this._session;
        if(!tx) { // no transaction supplied
            session.transaction(function(tx) {
                that.list(tx, callback);
            });
            return;
        }
        var entityName = this._entityName;
        var meta = persistence.getMeta(entityName);
        var tm = persistence.typeMapper;

        // handles mixin case -- this logic is generic and could be in persistence.
        if (meta.isMixin) {
            var result = [];
            persistence.asyncForEach(meta.mixedIns, function(realMeta, next) {
                var query = that.clone();
                query._entityName = realMeta.name;
                query.list(tx, function(array) {
                    result = result.concat(array);
                    next();
                });
            }, function() {
                var query = new persistence.LocalQueryCollection(result);
                query._orderColumns = that._orderColumns;
                query._reverse = that._reverse;
                // TODO: handle skip and limit -- do we really want to do it?
                query.list(null, callback);
            });
            return;
        }

        function selectAll (meta, tableAlias, prefix, excludes, includes) {
            var selectFields = [ tm.inIdVar("`" + tableAlias + "`.id") + " AS `" + prefix + "id`" ];
            for ( var p in meta.fields) {
                if (excludes && (p in excludes)) {
                    continue;
                }
                if (includes && !(p in includes)) {
                    continue;
                }
          
                if (meta.fields.hasOwnProperty(p)) {
                    selectFields.push(tm.inVar("`" + tableAlias + "`.`" + p + "`", meta.fields[p]) + " AS `"
                        + prefix + p + "`");
                }
            }
            for ( var p in meta.hasOne) {
                if (meta.hasOne.hasOwnProperty(p)) {
                    selectFields.push(tm.inIdVar("`" + tableAlias + "`.`" + p + "`") + " AS `"
                        + prefix + p + "`");
                }
            }
            selectFields.push(tm.inVar("`" + tableAlias + "`.`rowid`", 'INT') + " AS `"
                + prefix + "rowid`");
            return selectFields;
        }
        var args = [];
        //var mainPrefix = entityName + "_";
        var mainPrefix = meta.alias + "_";

        var mainAlias = 'root';
        var selectFields = selectAll(meta, mainAlias, mainPrefix, this._excludes, this._includes);

        var joinSql = '';
        var additionalWhereSqls = this._additionalWhereSqls.slice(0);
        var mtm = this._manyToManyFetch;
        if(mtm) {
            joinSql += "LEFT JOIN `" + mtm.table + "` AS mtm ON mtm.`" + mtm.inverseProp + "` = `root`.`id` ";
            additionalWhereSqls.push("mtm.`" + mtm.prop + "` = " + tm.outId(mtm.id));
        }

        joinSql += this._additionalJoinSqls.join(' ');

        for ( var i = 0; i < this._prefetchFields.length; i++) {
            var prefetchField = this._prefetchFields[i];
            var thisMeta = meta.hasOne[prefetchField].type.meta;
            if (thisMeta.isMixin)
                throw new Error("cannot prefetch a mixin");
            var tableAlias = thisMeta.name + '_' + prefetchField + "_tbl";
            selectFields = selectFields.concat(selectAll(thisMeta, tableAlias,
                prefetchField + "_"));
            joinSql += "LEFT JOIN `" + thisMeta.name + "` AS `" + tableAlias
            + "` ON `" + tableAlias + "`.`id` = `" + mainAlias + '`.`' + prefetchField + "` ";

        }

        var whereSql = "WHERE "
        + [ this._filter.sql(meta, mainAlias, args) ].concat(additionalWhereSqls).join(' AND ');

        var sql = "SELECT " + selectFields.join(", ") + " FROM `" + entityName
        + "` AS `" + mainAlias + "` " + joinSql + " " + whereSql;

        if(this._additionalGroupSqls.length > 0) {
            sql += this._additionalGroupSqls.join(' ');
        }

        if(this._orderColumns.length > 0) {
            sql += " ORDER BY "
            + this._orderColumns.map(
                function (c) {
                    return (c[2] ? "`" : "LOWER(`") + mainPrefix + c[0] + (c[2] ? "` " : "`) ")
                    + (c[1] ? "ASC" : "DESC");
                }).join(", ");
        }
        if(this._limit >= 0) {
            sql += " LIMIT " + this._limit;
        }
        if(this._skip > 0) {
            sql += " OFFSET " + this._skip;
        }
        session.flush(tx, function () {
            tx.executeSql(sql, args, 
                function (rows) {
                    var results = [];
                    if(that._reverse) {
                        rows.reverse();
                    }
                    for ( var i = 0; i < rows.length; i++) {
                        var r = rows[i];
                        var e = rowToEntity(session, entityName, r, mainPrefix);
                        for ( var j = 0; j < that._prefetchFields.length; j++) {
                            var prefetchField = that._prefetchFields[j];
                            var thisMeta = meta.hasOne[prefetchField].type.meta;
                            e._data_obj[prefetchField] = rowToEntity(session, thisMeta.name, r, prefetchField + '_');
                            
                            // SAH - Do NOT track objects that we pull from the DB. We only start tracking them when
                            // they are modified.
                            //session.add(e._data_obj[prefetchField]);
                        }
                        results.push(e);
                            // SAH - Do NOT track objects that we pull from the DB. We only start tracking them when
                            // they are modified.
                            // session.add(e);
                    }
                    callback(results);
                }, function(tx, error) {
                    if (persistence.errorHandler(error.message)) {
                        return;
                    }
                    callback(null, error);
                }
                );
        });
    }

    /**
   * Asynchronous call to remove all the items in the collection.
   * Note: does not only remove the items from the collection, but
   * the items themselves. Also NOTE, this DOES NOT flush the current
   * session to the DB. The reason is that this can have unintended consequences (e.g.,
   * deleting data that is not truly stale). The users controls flushing ...
   * However, this does mean that the user cannot delete an unflushed object as we also
   * do not do the extra DB query to determine the 'id' of all objects that are slated
   * for deletion. Again, it is up to the user to simply be careful. Don't manipulate objects
   * in the session then call destroyAll with unflushed changes that are included in the
   * destroy.
   * 
   * @param tx transaction to use
   * @param callback function to be called when clearing has completed
   */
    persistence.DbQueryCollection.prototype.destroyAll = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
        {
            name: 'tx', 
            optional: true, 
            check: persistence.isTransaction, 
            defaultValue: null
        },
        {
            name: 'callback', 
            optional: true, 
            check: argspec.isCallback(), 
            defaultValue: function(){}
        }
        ]);
        tx = args.tx;
        callback = args.callback;

        var that = this;
        var session = this._session;
        if(!tx) { // no transaction supplied
            session.transaction(function(tx) {
                that.destroyAll(tx, callback);
            });
            return;
        }
        var entityName = this._entityName;
        var meta = persistence.getMeta(entityName);
        var tm = persistence.typeMapper;

        // handles mixin case -- this logic is generic and could be in persistence.
        if (meta.isMixin) {
            persistence.asyncForEach(meta.mixedIns, function(realMeta, next) {
                var query = that.clone();
                query._entityName = realMeta.name;
                query.destroyAll(tx, callback);
            }, callback);
            return;
        }

        var joinSql = '';
        var additionalWhereSqls = this._additionalWhereSqls.slice(0);
        var mtm = this._manyToManyFetch;
        if(mtm) {
            joinSql += "LEFT JOIN `" + mtm.table + "` AS mtm ON mtm.`" + mtm.inverseProp + "` = `root`.`id` ";
            additionalWhereSqls.push("mtm.`" + mtm.prop + "` = " + tm.outId(mtm.id));
        }

        joinSql += this._additionalJoinSqls.join(' ');

        var args = [];
        var whereSql = "WHERE "
        + [ this._filter.sql(meta, null, args) ].concat(additionalWhereSqls).join(' AND ');

        // var selectSql = "SELECT id FROM `" + entityName + "` " + joinSql + ' ' + whereSql;
        var deleteSql = "DELETE FROM `" + entityName + "` " + joinSql + ' ' + whereSql;
        var args2 = args.slice(0);

        tx.executeSql(deleteSql, args2, callback, callback);
        
        /* SAH: NOTE; we are not clearing out all removed objects from the session. This means
         * we could have a tracked object that is not in the DB. If that object were subsequently
         * updated and flushed, we would hit an error b/c the object is gone in the underlying DB.
         * However, next to the option of an extra query on each call to destroyAll, this choice gives
         * better control of performance to the library user.  
         */
/*
        tx.executeSql(selectSql, args, function(results) {
            for(var i = 0; i < results.length; i++) {
                delete session.trackedObjects[results[i].id];
                session.objectsRemoved.push({
                    id: results[i].id, 
                    entity: entityName
                });
            }
            tx.executeSql(deleteSql, args2, callback, callback);
        }, callback); */
    };

    /**
   * Asynchronous call to update all the items in the collection. NOTE: this does NOT
   * flush all items in the DB.
   * 
   * @param tx transaction to use
   * @param fieldMap map from field names to values to update
   * @param callback function to be called when updating has completed
   */
    persistence.DbQueryCollection.prototype.updateAll = function (tx, fieldMap, callback) {
        var args = argspec.getArgs(arguments, [
        {
            name: 'tx', 
            optional: true, 
            check: persistence.isTransaction, 
            defaultValue: null
        },
        {
            name: 'fieldMap',
            optional: false,
            check: argspec.isMap()
        },
        {
            name: 'callback', 
            optional: true, 
            check: argspec.isCallback(), 
            defaultValue: function(){}
        }
        ]);
        tx = args.tx;
        callback = args.callback;
        fieldMap = args.fieldMap;

        var that = this;
        var session = this._session;
        if(!tx) { // no transaction supplied
            session.transaction(function(tx) {
                that.updateAll(tx, fieldMap, callback);
            });
            return;
        }

        var entityName = this._entityName;
        var meta = persistence.getMeta(entityName);
        var tm = persistence.typeMapper;

        // handles mixin case -- this logic is generic and could be in persistence.
        if (meta.isMixin) {
            persistence.asyncForEach(meta.mixedIns, function(realMeta, next) {
                var query = that.clone();
                query._entityName = realMeta.name;
                query.updateAll(tx, callback);
            }, callback);
            return;
        }
        var joinSql = '';
        var mtm = this._manyToManyFetch;
        if(mtm) {
            joinSql += "LEFT JOIN `" + mtm.table + "` AS mtm ON mtm.`" + mtm.inverseProp + "` = `root`.`id` ";
            additionalWhereSqls.push("mtm.`" + mtm.prop + "` = " + tm.outId(mtm.id));
        }

        joinSql += this._additionalJoinSqls.join(' ');

        // update params
        var updateArgs = [];
        var propertyPairs = [];
        var setSql = '';
        for (var fldName in fieldMap) {
            if (setSql) {
                setSql = setSql + ', ';
            }
            
            var type = meta.fields[fldName];
            var val = fieldMap[fldName];
            updateArgs.push(tm.entityValToDbVal(val, type));
            propertyPairs.push("`" + fldName + "` = " + tm.outVar("?", type));
        }
        
        var additionalWhereSqls = this._additionalWhereSqls.slice(0);

        var whereSql = "WHERE "
        + [ this._filter.sql(meta, null, []) ].concat(additionalWhereSqls).join(' AND ');

        var selectSql = "SELECT root.id FROM `" + entityName + "` as root " + joinSql + ' ' + whereSql;
        var updateSql = "UPDATE `" + entityName + "`" + " SET " + propertyPairs.join(',') + ' ';
        
        tx.executeSql(selectSql, [], function(results) {
            // Take these objects out of the tracked objects list so that we do
            // not mistakenly use a cached copy of them with a wrong value in it.
            var idsToUpdate = [];
            for(var i = 0; i < results.length; i++) {
                var nxtId = results[i].id;
                idsToUpdate.push(nxtId);
                delete session.trackedObjects[nxtId];
            }
            // Update them all.
            i = 0;
            while ((i * 25) < idsToUpdate.length) {
                // Update in batches of 25
                var startIdx = i * 25;
                var endIdx = startIdx + 24;
                var nxtIdArr = idsToUpdate.slice(startIdx, endIdx >= idsToUpdate.length ? idsToUpdate.length : endIdx);
                var idList = '';
                for (var j = 0; j < nxtIdArr.length; ++j) {
                    if (idList) {
                        idList = idList + ',';
                    }
                    idList = idList + "'" + nxtIdArr[j] + "'";
                }
                
                var nxtUpdateSql = updateSql + ' WHERE id IN (' +  idList + ')';
                tx.executeSql(nxtUpdateSql, updateArgs, callback, callback);
                ++i;
            }
        }, callback);
    };

    /**
   * Asynchronous call to count the number of items in the collection.
   * @param tx transaction to use
   * @param callback function to be called when clearing has completed
   */
    persistence.DbQueryCollection.prototype.count = function (tx, callback) {
        var args = argspec.getArgs(arguments, [
        {
            name: 'tx', 
            optional: true, 
            check: persistence.isTransaction, 
            defaultValue: null
        },
        {
            name: 'callback', 
            optional: false, 
            check: argspec.isCallback()
        }
        ]);
        tx = args.tx;
        callback = args.callback;

        var that = this;
        var session = this._session;
        if(tx && !tx.executeSql) { // provided callback as first argument
            callback = tx;
            tx = null;
        }
        if(!tx) { // no transaction supplied
            session.transaction(function(tx) {
                that.count(tx, callback);
            });
            return;
        }
        var entityName = this._entityName;
        var meta = persistence.getMeta(entityName);
        var tm = persistence.typeMapper;

        // handles mixin case -- this logic is generic and could be in persistence.
        if (meta.isMixin) {
            var result = 0;
            persistence.asyncForEach(meta.mixedIns, function(realMeta, next) {
                var query = that.clone();
                query._entityName = realMeta.name;
                query.count(tx, function(count) {
                    result += count;
                    next();
                });
            }, function() {
                callback(result);
            });
            return;
        }

        var joinSql = '';
        var additionalWhereSqls = this._additionalWhereSqls.slice(0);
        var mtm = this._manyToManyFetch;
        if(mtm) {
            joinSql += "LEFT JOIN `" + mtm.table + "` AS mtm ON mtm.`" + mtm.inverseProp + "` = `root`.`id` ";
            additionalWhereSqls.push("mtm.`" + mtm.prop + "` = " + tm.outId(mtm.id));
        }

        joinSql += this._additionalJoinSqls.join(' ');
        var args = [];
        var whereSql = "WHERE " + [ this._filter.sql(meta, "root", args) ].concat(additionalWhereSqls).join(' AND ');

        var sql = "SELECT COUNT(*) AS cnt FROM `" + entityName + "` AS `root` " + joinSql + " " + whereSql;

        session.flush(tx, function () {
            tx.executeSql(sql, args, function(results) {
                callback(parseInt(results[0].cnt, 10));
            });
        });
    };

    persistence.ManyToManyDbQueryCollection.prototype.persistQueries = function() {
        var queries = [];
        var meta = persistence.getMeta(this._obj._type);
        var inverseMeta = meta.hasMany[this._coll].type.meta;
        var tm = persistence.typeMapper;
        var rel = meta.hasMany[this._coll];
        var inv = inverseMeta.hasMany[rel.inverseProperty];
        var direct = rel.mixin ? rel.mixin.meta.name : meta.name;
        var inverse = inv.mixin ? inv.mixin.meta.name : inverseMeta.name;

        // Added
        for(var i = 0; i < this._localAdded.length; i++) {
            var columns = [direct + "_" + this._coll, inverse + '_' + rel.inverseProperty];
            var vars = [tm.outIdVar("?"), tm.outIdVar("?")];
            var args = [tm.entityIdToDbId(this._obj.id), tm.entityIdToDbId(this._localAdded[i].id)];
            if (rel.mixin) {
                columns.push(direct + "_" + this._coll + "_class");
                vars.push("?");
                args.push(meta.name);
            }
            if (inv.mixin) {
                columns.push(inverse + "_" + rel.inverseProperty + "_class");
                vars.push("?");
                args.push(inverseMeta.name);
            }
            queries.push(["INSERT INTO " + rel.tableName +
                " (`" + columns.join("`, `") + "`) VALUES (" + vars.join(",") + ")", args]);
        }
        this._localAdded = [];
        // Removed
        for(var i = 0; i < this._localRemoved.length; i++) {
            queries.push(["DELETE FROM  " + rel.tableName +
                " WHERE `" + direct + "_" + this._coll + "` = " + tm.outIdVar("?") + " AND `" +
                inverse + '_' + rel.inverseProperty +
                "` = " + tm.outIdVar("?"), [tm.entityIdToDbId(this._obj.id), tm.entityIdToDbId(this._localRemoved[i].id)]]);
        }
        this._localRemoved = [];
        return queries;
    };
};

if (typeof exports !== 'undefined') {
    exports.defaultTypeMapper = defaultTypeMapper;
    exports.config = config;
}
else {
    window = window || {};
    window.persistence = window.persistence || {};
    window.persistence.store = window.persistence.store || {};
    window.persistence.store.sql = {
        defaultTypeMapper: defaultTypeMapper,
        config: config
    };
}
;try {
  if(!window) {
    window = {};
    //exports.console = console;
  }
} catch(e) {
  window = {};
  exports.console = console;
}

var persistence = (window && window.persistence) ? window.persistence : {}; 

if(!persistence.store) {
  persistence.store = {};
}

persistence.store.websql = {};


persistence.store.websql.config = function(persistence, dbname, description, size, callback) {
  var conn = null;

  /**
   * Create a transaction
   * 
   * @param callback,
   *            the callback function to be invoked when the transaction
   *            starts, taking the transaction object as argument
   */
  persistence.transaction = function (callback) {
    if(!conn) {
      throw new Error("No ongoing database connection, please connect first.");
    } else {
      conn.transaction(callback);
    }
  };

  ////////// Low-level database interface, abstracting from HTML5 and Gears databases \\\\
  persistence.db = persistence.db || {};

  persistence.db.implementation = "unsupported";
  persistence.db.conn = null;

  // window object does not exist on Qt Declarative UI (http://doc.trolltech.org/4.7-snapshot/declarativeui.html)
  if (window && window.openDatabase) {
    persistence.db.implementation = "html5";
  }else {
    alert("This browser does not support web SQL. We currently do not support any other HTML5 offline storage standards.");
    throw new Error("WebSQL is not available.");
  }

  persistence.db.html5 = {};

  persistence.db.html5.connect = function (dbname, description, size, callback) {
    var that = {};
    var conn = openDatabase(dbname, '1.0', description, size, callback);

    that.transaction = function (fn) {
      return conn.transaction(function (sqlt) {
          return fn(persistence.db.html5.transaction(sqlt));
        });
    };
    return that;    
  };

  persistence.db.html5.transaction = function (t) {
    var that = {};
    that.executeSql = function (query, args, successFn, errorFn) {
      if(persistence.debug) {
        console.log(query, args);
      }
      t.executeSql(query, args, function (tx, result) {
          if (successFn) {
            var results = [];
            for ( var i = 0; i < result.rows.length; i++) {
              results.push(result.rows.item(i));
            }
            //successFn(results, result);
            successFn(results);
          }
        }, 
        function(t, e) {
            errorFn(t, e, query, args);
        });
    };
    return that;
  };

  persistence.db.connect = function (dbname, description, size, callback) {
    return persistence.db.html5.connect(dbname, description, size, callback);
  };

  ///////////////////////// SQLite dialect

  persistence.store.websql.sqliteDialect = {
    // columns is an array of arrays, e.g.
    // [["id", "VARCHAR(32)", "PRIMARY KEY"], ["name", "TEXT"]]
    createTable: function(tableName, columns) {
      var tm = persistence.typeMapper;
      var sql = "CREATE TABLE IF NOT EXISTS `" + tableName + "` (";
      var defs = [];
      for(var i = 0; i < columns.length; i++) {
        var column = columns[i];
        defs.push("`" + column[0] + "` " + tm.columnType(column[1]) + (column[2] ? " " + column[2] : ""));
      }
      sql += defs.join(", ");
      sql += ')';
      return sql;
    },

    // columns is array of column names, e.g.
    // ["id"]
    createIndex: function(tableName, columns, options) {
      options = options || {};
      return "CREATE "+(options.unique?"UNIQUE ":"")+"INDEX IF NOT EXISTS `" + tableName + "__" + columns.join("_") + 
             "` ON `" + tableName + "` (" + 
             columns.map(function(col) { return "`" + col + "`"; }).join(", ") + ")";
    }
  };

  // Configure persistence for generic sql persistence, using sqliteDialect
  persistence.store.sql.config(persistence, persistence.store.websql.sqliteDialect);

  // Make the connection
  conn = persistence.db.connect(dbname, description, size, callback);
  if(!conn) {
    throw new Error("No supported database found in this browser.");
  }
};

try {
  exports.persistence = persistence;
} catch(e) {}
;/**
 * @license
 * Copyright (c) 2010 Zef Hemel <zef@zef.me>
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

try {
    if(!window) {
        window = {};
    }
} catch(e) {
    window = {};
    exports.console = console;
}

var persistence = (window && window.persistence) ? window.persistence : {}; 

persistence.search = {};

persistence.search.config = function(persistence, dialect, options) {
    var filteredWords = {
        'and':true, 
        'the': true, 
        'are': true
    };

    var indexedOnce = false;

    var argspec = persistence.argspec;
    persistence.search.options = options;

    function normalizeWord(word, filterShortWords) {
        // Filter out <3 letter words
        if (filterShortWords && word.length < 3) {
            return null;
        }
        // Filter out numbers.
        if (word.match(/^\d+$/)) {
            return null;
        }
        
        return word;
    }

    /**
   * Does extremely basic tokenizing of text. Also includes some basic stemming.
   */
    function searchTokenizer(text) {
        var words = text.toLowerCase().split(/[^\w\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+/);
        var wordDict = {};
        // Prefixing words with _ to also index Javascript keywords and special fiels like 'constructor'
        for(var i = 0; i < words.length; i++) {
            var normalizedWord = normalizeWord(words[i], true);
            if(normalizedWord) {
                var word = '_' + normalizedWord;
                // Some extremely basic stemming
                if(word in wordDict) {
                    wordDict[word]++;
                } else {
                    wordDict[word] = 1;
                }
            }
        }
        return wordDict;
    }
  
    /**
   * Generate an SQL search phrase for a single word.
   */
    function generateQueryElement(word, indexTbl, prefixByDefault) {
        var sql = '(';
        if(word.search(/\*/) !== -1) {
            sql += "`" + indexTbl + "`.`word` LIKE '" + word.replace(/\*/g, '%') + "'";
        } else if(prefixByDefault) {
            sql += "`" + indexTbl + "`.`word` LIKE '" + word + "%'";
        } else {
            sql += "`" + indexTbl + "`.`word` = '" + word + "'";
        }
        /*if(restrictedToColumn) {
            sql += ' AND `' + indexTbl + "`.`prop` = '" + restrictedToColumn + "'";
        }
         * STRIPPING OUT FOR THE MOMENT BECAUSE THIS WOULD REQUIRE A JOIN ON THE NESTED IN CLAUSES
         * FOR NOW, WE DON'T NEED THIS FEATURE. ONE CAN SPECIFY A PROPERTY RESTRICTION FOR THE WHOLE
         * QUERY, BUT NOT PER WORD
         */
        sql += ')';
        return sql;
    }

    /**
   * Parses a search query and returns it as list SQL parts later to be OR'ed or AND'ed.
   */
    function searchPhraseParser(query, indexTbl, indexPropsTbl, prefixByDefault) {
        query = query.toLowerCase().replace(/['"]/, '').replace(/(^\s+|\s+$)/g, '');
        var words = query.split(/\s+/);
        var sqlParts = [];
        var isFirst = true;
        for(var i = 0; i < words.length; i++) {
            var word = normalizeWord(words[i]);
            if(!word) {
                continue;
            }
            if(isFirst && word.search(/:$/) !== -1) {
                var restrictedToColumn = word.substring(0, word.length-1);
                sqlParts.push("(`" + indexPropsTbl + "`.propName='" + restrictedToColumn + "'");
                continue;
            }
      
            // See if this is a comma separated list of words. If so, create a disjunction on
            // those words.
            var disjunctWords = word.split(/,/);
            var sql = null;
            if (disjunctWords.length > 1) {
                sql = '(';
                var djSql = [];
                for (var j = 0; j < disjunctWords.length; ++j) {
                    djSql.push(generateQueryElement(disjunctWords[j], indexTbl, prefixByDefault));
                }
                sql += djSql.join(' OR ');
                sql += ')';
            } else {
                sql = generateQueryElement(word, indexTbl, prefixByDefault);
            }
            if (isFirst) {
                isFirst = false;
            } else {
                sql = "(`" + indexTbl + "`.`entityId` IN (select entityId from `" +
                indexTbl + "` WHERE " + sql + "))";
            }
            sqlParts.push(sql);
        }
        return sqlParts.length === 0 ? ["1=1"] : sqlParts;
    }

    var queryCollSubscribers = {}; // entityName -> subscription obj
    persistence.searchQueryCollSubscribers = queryCollSubscribers;

    function SearchFilter(query, entityName) {
        this.query = query;
        this.entityName = entityName;
    }

    SearchFilter.prototype.match = function (o) {
        var meta = persistence.getMeta(this.entityName);
        var query = this.query.toLowerCase();
        var text = '';
        for(var p in o) {
            if(meta.textIndex.hasOwnProperty(p)) {
                if(o[p]) {
                    text += o[p];
                }
            }
        }
        text = text.toLowerCase();
        return text && text.indexOf(query) !== -1;
    }

    SearchFilter.prototype.sql = function (o) {
        return "1=1";
    }

    SearchFilter.prototype.subscribeGlobally = function(coll, entityName) {
        var meta = persistence.getMeta(entityName);
        for(var p in meta.textIndex) {
            if(meta.textIndex.hasOwnProperty(p)) {
                persistence.subscribeToGlobalPropertyListener(coll, entityName, p);
            }
        }
    };

    SearchFilter.prototype.unsubscribeGlobally = function(coll, entityName) {
        var meta = persistence.getMeta(entityName);
        for(var p in meta.textIndex) {
            if(meta.textIndex.hasOwnProperty(p)) {
                persistence.unsubscribeFromGlobalPropertyListener(coll, entityName, p);
            }
        }
    };

    SearchFilter.prototype.toUniqueString = function() {
        return "SEARCH: " + this.query;
    }

    function SearchQueryCollection(session, entityName, query, prefixByDefault) {
        this.init(session, entityName, SearchQueryCollection);
        this.subscribers = queryCollSubscribers[entityName];
        this._filter = new SearchFilter(query, entityName);

        if(query) {
            var indexTbl = entityName + '_Index';
            var indexPropsTbl = entityName + '_IndexFields';
            var joinSQL = '`' + indexTbl + '`,`' + indexPropsTbl + '`';
            var joinWhereSQL = '`' + indexTbl +'`.`prop` = `' + indexPropsTbl + '`.`ROWID` AND `' + indexTbl + '`.`entityId` = `root`.ROWID';
            this._additionalJoinSqls.push(', ' + joinSQL);
            this._additionalWhereSqls.push(joinWhereSQL);
            this._additionalWhereSqls.push('(' + searchPhraseParser(query, indexTbl, indexPropsTbl, prefixByDefault).join(' AND ') + ')');
            this._additionalGroupSqls.push(' GROUP BY (`' + entityName + '_Index`.`entityId`)');
        }
    }

    SearchQueryCollection.prototype = new persistence.DbQueryCollection();

    SearchQueryCollection.prototype.oldClone = SearchQueryCollection.prototype.clone;


    SearchQueryCollection.prototype.clone = function() {
        var clone = this.oldClone(false);
        var entityName = this._entityName;
        clone.subscribers = queryCollSubscribers[entityName];
        return clone;
    };

    SearchQueryCollection.prototype.oldOrder = SearchQueryCollection.prototype.order;
    SearchQueryCollection.prototype.order = function(property, ascending, caseSensitive) {
        if (this._usingDefaultOrder) {
            throw new Error("Imposing additional orderings is not support for search query collections.");
        }
        return this.oldOrder(property, ascending, caseSensitive);
    };
  
    SearchQueryCollection.prototype.defaultOrder = function() {
        var entityName = this._entityName;
        this._additionalGroupSqls.push(' ORDER BY SUM(`' + entityName + '_Index`.`occurrences`) DESC');
        this._usingDefaultOrder = true;
    };

    /*
  SearchQueryCollection.prototype.filter = function (property, operator, value) {
    var c = this.clone();
    c._filter = new persistence.AndFilter(this._filter, new persistence.PropertyFilter(property, operator, value));
    // Add global listener (TODO: memory leak waiting to happen!)
    //session.subscribeToGlobalPropertyListener(c, this._entityName, property);
    return c;
  };
  */

    persistence.entityDecoratorHooks.push(function(Entity) {
        /**
         * Declares a property to be full-text indexed.
         */
        Entity.textIndex = function(prop) {
            if(!Entity.meta.textIndex) {
                Entity.meta.textIndex = {};
                // We have not yet generated the index tables.
                Entity.meta.textIndex['__hx_generated'] = false;
            }
            Entity.meta.textIndex[prop] = true;
            
            // SAH - add a field to indicate if this object has been indexed if we
            // are doing async indexing.
            if (persistence.search.options.indexAsync) {
                if (!('__hx_indexed' in Entity.meta.fields)) {
                    Entity.meta.fields['__hx_indexed'] = 'BOOL';
                    //this.addField('__hx_indexed');
                }
            }
            
            // Subscribe
            var entityName = Entity.meta.name;
            if(!queryCollSubscribers[entityName]) {
                queryCollSubscribers[entityName] = {};
            }
        };

        /**
         * Returns a query collection representing the result of a search
         * @param query an object with the following fields:
         */
        Entity.search = function(session, query, prefixByDefault) {
            var args = argspec.getArgs(arguments, [
            {
                name: 'session', 
                optional: true, 
                check: function(obj) {
                    return obj.schemaSync;
                }, 
                defaultValue: persistence
            },
            {
                name: 'query', 
                optional: false, 
                check: argspec.hasType('string')
            },
            {
                name: 'prefixByDefault', 
                optional: false
            }
            ]);
            session = args.session;
            query = args.query;
            prefixByDefault = args.prefixByDefault;

            return session.uniqueQueryCollection(new SearchQueryCollection(session, Entity.meta.name, query, prefixByDefault));
        };
        
        Entity.indexAsync = function(ncalls, __indexFull, __indexParams) {
            // Launch asynchronous indexing, if that has been enabled. This will launch
            // a background task (essentially) to index a table in batches of 100 records
            // at a time.
            if (!persistence.search.options.indexAsync) {
                return;
            }
            if (this.__hx_indexing) {
                // We are already indexing ...
                return;
            }
            if (ncalls == 40 && !__indexFull) {
                // We only do this up to 40 times per index, otherwise the application can
                // be sluggish for far too long.
                indexedOnce = true;
                
                Helix.DB.__indexingCount--;
                if (Helix.DB.__indexingCount == 0) {
                    Helix.Utils.statusMessage("Indexing", "Background indexing is complete.", "info");
                }
                return;
            }
            
            // Pull up to 100 objects from the entity and iterate over them.
            var propList = [];
            if(this.meta.textIndex) {
                for ( var p in this.meta.textIndex) {
                    if (this.meta.textIndex.hasOwnProperty(p)) {
                        propList.push(p);
                    }
                }
            }
            if (propList.length == 0) {
                // Nothing to do ...
                return;
            }
            
            if (ncalls == 0) {
                ++Helix.DB.__indexingCount;
            }
            
            // Run a query to get 100 objects that are not yet indexed.
            if (!__indexParams) {
                __indexParams = {};
                __indexParams.deleteDone = false;
            }
            __indexParams.updateIDs = [];
            __indexParams.updateObjs = [];
            __indexParams.nxtCall = ++ncalls;
            __indexParams.delaySecs = (__indexFull ? 1 : 3);
            __indexParams.toIndex = 0;
            __indexParams.nObjects = 20;
            
            var that = this;
            that.__hx_indexing = true;
            this.all().filter('__hx_indexed', '=', 0).limit(__indexParams.nObjects).order('rowid', false).include(propList.concat(['rowid'])).newEach({
                startFn: function(ct, params) {
                    params.toIndex = ct;
                    if (params.toIndex <= 0) {
                        that.__hx_indexing = false;
                        
                        --Helix.DB.__indexingCount;
                        if (Helix.DB.__indexingCount == 0 && Helix.DB.__indexingMessageShown && ncalls > 0 && (__indexFull || params.nxtCall >= 20)) {
                            Helix.Utils.statusMessage("Indexing", "Background indexing is complete.", "info");
                            Helix.DB.__indexingMessageShown = false;
                        }
                    } else {
                        // Only show a message if we are indexing a lot of data - at least 100 records where nObjects is 20
                        if (params.nxtCall == 5) {
                            if (!Helix.DB.__indexingMessageShown) {
                                Helix.DB.__indexingMessageShown = true;
                                // Only display if we are going to index many times.
                                Helix.Utils.statusMessage("Indexing", "Your data is being indexed. The application will be slow while indexing is in progress. A message is displayed when indexing is done.", "info");
                            }
                        }
                    }
                },
                eachFn: function(elem, params) {
                    params.updateIDs.push(elem._data['rowid']);
                    params.updateObjs.push(elem);
                },
                doneFn: function (ct, params) {
                    if (ct == 0) {
                        return;
                    }
                    
                    var propList = [];
                    for (var prop in that.meta.textIndex) {
                        if (prop !== '__hx_generated') {
                            propList.push(prop);
                        }
                    }
                    
                    
                    var __doIndex = function(params) {
                        indexObjectList(params.updateIDs, params.updateObjs, that, params.propMap, function() {
                            // Now start over ...
                            that.__hx_indexing = false;
                            if (!indexedOnce && ct == params.nObjects) {
                                // Checking that ct == nObjects ensures that we only recurse if we really need to.
                                that.indexAsync(params.nxtCall, __indexFull, params);
                            } else {
                                // When the user has already endured one round of indexing, we don't force them
                                // to endure multiple slow rounds of indexing. Instead we just do 1 shot of indexing
                                // and stop.
                                return;
                            }
                        });
                    };
                    
                    var __getProps = function(params) {
                        if (params.propMap) {
                            __doIndex(params);
                        } else {
                            getPropNameMap(that, propList, function(propMap) {
                                params.propMap = propMap;
                                __doIndex(params);
                            });
                        }                        
                    };
                    
                    var __doDelete = function(params) {
                        if (!params.deleteDone) {
                            // Delete all existing index entries from the DB where the
                            // entity from which that entry was derived is now being re-indexed.
                            var indexTbl = that.meta.name + '_Index';
                            var deleteQry = 'DELETE FROM `' + indexTbl + 
                                '` WHERE entityId IN (SELECT ROWID FROM `' + 
                                    that.meta.name + '` WHERE __hx_indexed=0)';
                            persistence.transaction(function(tx) {
                                tx.executeSql(deleteQry, null, function() {
                                    params.deleteDone = true;
                                    __getProps(params);
                                }, function(t, e) {
                                    persistence.errorHandler(e.message, e.code);
                                });
                            });
                        } else {
                            __getProps(params);
                        }                
                    };
                    
                    __doDelete(params);
                }
            }, (__indexParams ? __indexParams : {}));
        }
    });

    persistence.schemaSyncHooks.push(function(tx) {
        var entityMeta = persistence.getEntityMeta();
        var queries = [];
        for(var entityName in entityMeta) {
            var meta = entityMeta[entityName];
            if(meta.textIndex && !(meta.textIndex['__hx_generated'])) {
                queries.push([dialect.createTable(entityName + '_Index', [['entityId', 'INTEGER'], ['prop', 'INTEGER'], ['word', 'VARCHAR(100)'], ['occurrences', 'INT']]), null]);
                queries.push([dialect.createIndex(entityName + '_Index', ['prop', 'word']), null]);
                queries.push([dialect.createIndex(entityName + '_Index', ['word']), null]);
                persistence.generatedTables[entityName + '_Index'] = true;
          
                queries.push([dialect.createTable(entityName + '_IndexFields', [['propName', 'VARCHAR(100)']]), null]);
                queries.push([dialect.createIndex(entityName + '_IndexFields', ['propName']), null]);
                persistence.generatedTables[entityName + '_IndexFields'] = true;                
            }
        }
        queries.reverse();
        //persistence.executeQueriesSeq(tx, queries);
        return queries;
    });
  
    function indexObject(obj, propMap, insertRows) {
        var id = obj._data['rowid'];
        for (var prop in propMap) {
            var propID = propMap[prop];
            var rawText = obj[prop];
            var occurrences = searchTokenizer(rawText);
            var insertValues = null;
            for(var word in occurrences) {
                if(occurrences.hasOwnProperty(word)) {
                    insertValues = id + "," + propID + "," + "'" + _real_escape_string(word.substring(1)) + "'," + occurrences[word];
                    insertRows.push(insertValues);
                }
            }
        }
    }

    // Helper functions.
    function _real_escape_string (str) {
        return str.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, function (ch) {
            switch (ch) {
                case "\0":
                    return "\\0";
                case "\x08":
                    return "\\b";
                case "\x09":
                    return "\\t";
                case "\x1a":
                    return "\\z";
                case "\n":
                    return "\\n";
                case "\r":
                    return "\\r";
                case "\"":
                case "'":
                case "\\":
                case "%":
                    return "\\"+ch; // prepends a backslash to backslash, percent,
                                      // and double/single quotes
            }
        });
    }
    
    function makeStringVector(eidList) {
        var ret = null;
        for (var x = 0; x < eidList.length; ++x) {
            if (!ret) {
                ret = "'" + _real_escape_string(eidList[x]) + "'";
            } else {
                ret = ret + ",'" + _real_escape_string(eidList[x]) + "'";
            }
        }
        return ret;
    }
    
    function makeIntVector(eidList) {
        var ret = null;
        for (var x = 0; x < eidList.length; ++x) {
            if (!ret) {
                ret = eidList[x].toString();
            } else {
                ret = ret + "," + eidList[x].toString();
            }
        }
        return ret;
    }

    function getPropNameMap(entity, propArray, oncomplete) {
        var propertyVec = makeStringVector(propArray);
        var propMap = {};
        var propTbl = entity.meta.name + '_IndexFields';
        
        // Convert all of the entity IDs into integral IDs
        persistence.transaction(function(tx) {
            tx.executeSql('SELECT propName, ROWID FROM `' + propTbl + '` WHERE propName IN (' + propertyVec + ')', null, function(r, orig) {
                for (var x = 0; x < r.length; ++x) {
                    var nxtROW = r[x];
                    propMap[nxtROW.propName] = nxtROW.rowid;
                }

                // See if we are missing row IDs.
                if (Object.keys(propMap).length != propArray.length) {
                    // Create a single insert for all properties that have no ROWID
                    var valuesList = null;
                    for (x = 0; x < propArray.length; ++x) {
                        var nxtProp = propArray[x];
                        if (nxtProp in propMap) {
                            continue;
                        } else {
                            if (!valuesList) {
                                valuesList = "SELECT '" + nxtProp + "'";
                            } else {
                                valuesList = valuesList + " UNION SELECT '" + nxtProp + "'";
                            }
                        }
                    }

                    persistence.transaction(function(tx) {
                        tx.executeSql('INSERT INTO `' + propTbl + '` ' + valuesList, null, function(r, orig) {
                            // Rinse and repeat.
                            getPropNameMap(entity, propArray, oncomplete);
                        }, function(t, e) {
                            persistence.errorHandler(e.message, e.code);
                        });                        
                    });
                } else {
                    oncomplete(propMap);
                }
            }, function(t, e) {
                persistence.errorHandler(e.message, e.code);
            });            
        });
    }

    function indexObjectList(updateIDs, updateObjs, entity, propMap, oncomplete, tx) {
        // Do the indexing.
        var indexRows = [];
        var indexQueries = [];
        var i;
        var indexTbl = entity.meta.name + '_Index';

        for (i = 0; i < updateObjs.length; ++i) {
            var elem = updateObjs[i];
            indexObject(elem, propMap, indexRows);
        }

        // Turn the rows list into blocks of 50 inserts
        var maxRows = 0;
        var nxtInsert = null;
        for(var k = 0; k < indexRows.length; ++k) {
            if (!nxtInsert) {
                nxtInsert = "SELECT ";
            } else {
                nxtInsert = nxtInsert + " UNION SELECT ";
            }
            nxtInsert = nxtInsert + indexRows[k];
            ++maxRows;
            if (maxRows == 100) {
                indexQueries.push(['INSERT INTO `' + indexTbl + '` ' + nxtInsert, null]);
                nxtInsert = null;
                maxRows = 0;
            }
        }
        if (nxtInsert) {
            indexQueries.push(['INSERT INTO `' + indexTbl + '` ' + nxtInsert, null]);
        }
        
        var updateVec = makeIntVector(updateIDs);
        indexQueries.push(["UPDATE `" + elem._type + "` SET __hx_indexed=1 WHERE rowid IN (" + updateVec + ")", null])

        // Run the queries against the DB. The UPDATE goes last, and we only finish all statements in the array on
        // success.
        indexQueries.reverse();
        persistence.transaction(function(tx) {
            persistence.executeQueriesSeq(tx, indexQueries, function() {
                // Mark the object as indexed, but do not use the setter because
                // we don't want to mark the object as dirty on account of this update.
                for (var z = 0; z < updateObjs.length; ++z) {
                    var obj = updateObjs[z];
                    if (obj) {
                        obj._data['__hx_indexed'] = true;
                    }
                }
                oncomplete();
            }, 100);
        });
    }
  
    function handleDeletes(queries, tx, callback) {
        for (var id in persistence.getObjectsToRemove()) {
            if (persistence.getObjectsToRemove().hasOwnProperty(id)) {
                var obj = persistence.getObjectsToRemove()[id];
                var meta = persistence.getEntityMeta()[obj._type];
                if(meta.textIndex) {
                    queries.push(['DELETE FROM `' + obj._type + '_Index` WHERE `entityId` IN (SELECT ROWID FROM `' + obj._type + '` WHERE `id`=?)', [id]]);
                }
            }
        }
        //
        pushQueries(queries, tx, callback);
    }
  
    function pushQueries(queries, tx, callback) {
        queries.reverse();
        persistence.executeQueriesSeq(tx, queries, callback);
    }
  
    /* SAH - we don't support synchronous indexing. */
};

if(typeof exports === 'object') {
    exports.config = persistence.search.config;
}

;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Integrates Persistence JS ORM with the PrimeFaces Mobile SDK.
 */

function initHelixDB() {
    Helix.DB = {
        
        __masterDBVer : 1,
        
        __schemaVersion: 0,
        
        __indexingMessageShown: false,
        
        __indexingCount: 0,
        
        indexFull: false,
        
        reservedFields : {
            "__hx_sorts" : true,
            "__hx_key" : true,
            "__hx_schema_name" : true,
            "__hx_filters" : true,
            "__hx_text_index" : true,
            "__hx_schema_type" : true,
            "__hx_global_filters" : true
        },

        generatePersistenceFields: function(schemaTemplate,name,allVisited,recursiveFields,allSchemas) {
            var schemaFields = {};
            var subSchemas = {};

            var oneToMany = [];
            var manyToOne = [];
            var myRecursiveFields = [];

            // Check to see if this is a schema forward ref. If so, return null and 
            // let the caller fill in the actual schema after all peer fields have been
            // processed.
            if (schemaTemplate.__hx_schema_type == 1002) {
                return null;
            }

            for (var schemaField in schemaTemplate) {
                if (!schemaTemplate.hasOwnProperty(schemaField)) {
                    continue;
                }
                if (Helix.DB.reservedFields[schemaField]) {
                    continue;
                } 
                var subSchema = schemaTemplate[schemaField];
                if (Object.prototype.toString.call(subSchema) === '[object Array]') {
                    var elemSchema = this.generatePersistenceFields(subSchema[0],schemaField,allVisited,recursiveFields,allSchemas);
                    if (elemSchema != null) {
                        subSchemas[schemaField] = elemSchema;
                        oneToMany.push({
                            "field" : schemaField, 
                            "table" : elemSchema.__hx_schema_name
                        });
                    } else {
                        myRecursiveFields.push({
                            'schemaName': subSchema[0].__hx_schema_name, 
                            'field' : schemaField, 
                            'oneToMany' : true
                        });
                    }
                } else if (Object.prototype.toString.call(subSchema) === '[object Object]') {
                    // This is a dependent object, which we assume is stored in another field.
                    var fieldSchema = this.generatePersistenceFields(subSchema,schemaField,allVisited,recursiveFields,allSchemas);
                    if (fieldSchema != null) {
                        subSchemas[schemaField] = fieldSchema;
                        manyToOne.push({
                            "field" : schemaField, 
                            "table" : fieldSchema.__hx_schema_name
                        });
                    } else {
                        myRecursiveFields.push({
                            'schemaName' : subSchema.__hx_schema_name, 
                            'field' : schemaField, 
                            'oneToMany' : false
                        });
                    }
                } else {
                    // Otherwise this is a scalar type and we handle all scalar types here mapping them
                    // to SQLite data types. For now we don't support blob, but should add support
                    // using HTML5's new support for binary data.
                    if (Object.prototype.toString.call(subSchema) === '[object Date]') {
                        schemaFields[schemaField] = "DATE";
                    } else if (Object.prototype.toString.call(subSchema) === '[object Boolean]') {
                        schemaFields[schemaField] = "BOOL";
                    } else if (Object.prototype.toString.call(subSchema) === '[object String]') {
                        schemaFields[schemaField] = "TEXT";
                    } else if (Object.prototype.toString.call(subSchema) === '[object Number]') {
                        if (Helix.DB.Utils.isInt(subSchema)) {
                            schemaFields[schemaField] = "INT";
                        } else {
                            schemaFields[schemaField] = "REAL";
                        }
                    }
                }
            }
            // Create the persistence schema.
            var objSchema = persistence.define(schemaTemplate.__hx_schema_name, schemaFields, true);
            objSchema.__hx_schema_name = schemaTemplate.__hx_schema_name;
            objSchema.__hx_sorts = schemaTemplate.__hx_sorts;
            objSchema.__hx_filters = schemaTemplate.__hx_filters;
            objSchema.__hx_global_filters = schemaTemplate.__hx_global_filters;

            objSchema.index(schemaTemplate.__hx_key, {
                unique: true
            });
            objSchema.__hx_key = schemaTemplate.__hx_key;
        
            objSchema.__pm_subSchemas = subSchemas;

            // Save a reference to the schema.
            window.__pmAllSchemas[schemaTemplate.__hx_schema_name] = objSchema;

            // Save the schemaFields and the relationships in the allSchemas array
            allSchemas.push({
                'schema': objSchema,
                'fields' : schemaFields,
                'keyField' : schemaTemplate.__hx_key,
                'sortFields' : schemaTemplate.__hx_sorts,
                'filterFields' : schemaTemplate.__hx_filters,
                'globalFilterFields' : schemaTemplate.__hx_global_filters,
                'textIndexFields' : schemaTemplate.__hx_text_index
            });

            // Insert all of the sub schemas.
            var i = 0;

            // Save off our forward references in the global list.
            var recurseIdx;
            for (recurseIdx = 0; recurseIdx < myRecursiveFields.length; ++recurseIdx) {
                var forwardRefObj = myRecursiveFields[recurseIdx];
                recursiveFields.push({
                    'schemaName' : forwardRefObj.schemaName, 
                    'field' : forwardRefObj.field,
                    'name' : name,
                    'schema' : objSchema,
                    'oneToMany' : forwardRefObj.oneToMany
                });
            }

            // 1-many - i.e. this object has an array of these things.
            for (i = 0; i < oneToMany.length; ++i) {
                var oneToManyField = oneToMany[i].field;
                objSchema.hasMany(oneToManyField, subSchemas[oneToManyField], name);
            }
            // Many-to-1 - i.e. this object references an object that may be shared
            // with other objects.
            for (i = 0; i < manyToOne.length; ++i) {
                var manyToOneField = manyToOne[i].field;
                objSchema.hasOne(manyToOneField, subSchemas[manyToOneField]);
            }

            if (schemaTemplate.__hx_sorts) {
                for (var sortField in schemaTemplate.__hx_sorts) {
                    objSchema.index(sortField);
                }
            }
        
            if (schemaTemplate.__hx_filters) {
                for (var filterField in schemaTemplate.__hx_filters) {
                    if (!schemaTemplate.__hx_sorts[filterField]) {
                        objSchema.index(filterField);
                    }
                }
            }
            
            if (schemaTemplate.__hx_global_filters) {
                for (var gFilterField in schemaTemplate.__hx_global_filters) {
                    if (!schemaTemplate.__hx_sorts[gFilterField] &&
                        !schemaTemplate.__hx_filters[gFilterField]) {
                        objSchema.index(gFilterField);
                    }
                }
            }
            
            if (schemaTemplate.__hx_text_index) {
                for (i = 0; i < schemaTemplate.__hx_text_index.length; i++) {
                    var indexField = schemaTemplate.__hx_text_index[i];
                    objSchema.textIndex(indexField);
                }
            }
            return objSchema;
        },

        generatePersistenceSchema: function(schemaTemplate,name,oncomplete,opaque,nRetries) {
            if (!Helix.DB.persistenceIsReady()) {
                $(document).on('hxPersistenceReady', function() {
                    Helix.DB.generatePersistenceSchema(schemaTemplate,name,oncomplete,opaque,nRetries+1);
                });
                return;
            }
        
            // Generate the schema from the supplied schema template and synchronize it with the 
            // database. Returned the generated schema.    
            var s;
            var recursiveFields = [];
            var allSchemas = [];

            if (!window.__pmAllSchemas) {
                window.__pmAllSchemas = {};
            }
            /* First, check to see if the schema was created in a recursive call. */
            if (this.createdSchemas[name]) {
                // We have already created all schemas associated with this widget.
                var oncompleteArgs = [ this.createdSchemas[name] ];
                oncompleteArgs = oncompleteArgs.concat(opaque);
                oncomplete.apply(this, oncompleteArgs);
                return;
            }
            /* Next, check to see if this specific schema is already available from a previous call to
             * generatePersistenceSchema. 
             */
            var schemaNameToCheck;
            if (Object.prototype.toString.call(schemaTemplate) === '[object Array]') {
                schemaNameToCheck = schemaTemplate[0].__hx_schema_name;
            } else {
                schemaNameToCheck = schemaTemplate.__hx_schema_name;
            }
        
            if (window.__pmAllSchemas[schemaNameToCheck]) {
                // We have already created all schemas associated with this widget.
                oncompleteArgs = [ window.__pmAllSchemas[schemaNameToCheck] ];
                oncompleteArgs = oncompleteArgs.concat(opaque);
                oncomplete.apply(this, oncompleteArgs);
                return;
            }
        

            if (Object.prototype.toString.call(schemaTemplate) === '[object Array]') {
                // The template provided references a list of table rows. The schema is
                // the individual table rows.
                s = this.generatePersistenceFields(schemaTemplate[0],name,{},recursiveFields,allSchemas);
            } else {
                // The template provided references a single table row.
                s = this.generatePersistenceFields(schemaTemplate,name,{},recursiveFields,allSchemas);   
            }

            // Recurse over all recursive fields and patch them back into subschemas.
            var recurseIdx;
            for (recurseIdx = 0; recurseIdx < recursiveFields.length; ++recurseIdx) {
                var recurseElem = recursiveFields[recurseIdx];
                var recurseSchema = recurseElem.schema.__pm_subSchemas[recurseElem.field] = window.__pmAllSchemas[recurseElem.schemaName];
                if (recurseElem.oneToMany) {
                    recurseElem.schema.hasMany(recurseElem.field, recurseSchema, recurseElem.name);
                } else {
                    recurseSchema.hasMany(recurseElem.name, recurseElem.schema, recurseElem.field);
                }
            }
        
            // Determine if any upgrades need to be generated. The required SQL commands
            // are stored as schema sync hooks.
            var dirty = false;
            if (Helix.DB.doMigrations(name,allSchemas)) {
                dirty = true;
            }
            
            // Flush all schemas.
            persistence.schemaSync(function(tx) {
                // Flush all master DB changes.
                persistence.flush(function() {
                    if (dirty) {
                        // Clean out Persistence JS' cache of all tracked objects and cached
                        // query collections. Otherwise we can end up with stale objects/queries
                        // that refer to a field list that is out of sync with the flushed schema
                        // changes that we just completed. NOTE that everything we do here should
                        // happen before we are manipulating data from a particular table.
                        persistence.clean();
                    }
                    
                    var oncompleteArgs = [ s ];
                    oncompleteArgs = oncompleteArgs.concat(opaque);
                    oncomplete.apply(this, oncompleteArgs);

                    // Launch async indexing ... these calls do nothing if there are
                    // no fields to index or if async indexing is not enabled.
                    /*for (var schemaName in window.__pmAllSchemas) { 
                        var indexSchema = window.__pmAllSchemas[schemaName];
                        indexSchema.indexAsync(0, Helix.DB.indexFull);
                    }*/
                });
            });
        
            // We are done with this schema ...
            this.createdSchemas[name] = s;
        },

        doAppMigrations: function(tableName, migrationOptions) {
            Helix.DB.defineTableMigration(Helix.DB.__schemaVersion,
                        tableName, 
                        migrationOptions.newFields, 
                        migrationOptions.oldFields, 
                        (migrationOptions.newFields && migrationOptions.oldFields),
                        migrationOptions.oldIndexes, 
                        migrationOptions.newIndexes,
                        null,
                        null,
                        null, 
                        null,
                        null, 
                        null,
                        null, 
                        null);
            persistence.migrate(Helix.DB.__schemaVersion, Helix.DB.__schemaVersion + 1);
            Helix.DB.__schemaVersion = Helix.DB.__schemaVersion + 1;
        },

        doMigrations: function(metaName,allSchemas) {
            // Migrate tables one at a time.
            if (allSchemas.length == 0) {
                return false;
            }

            var dirty = false;
            for (var i = 0; i < allSchemas.length; ++i) {
                var schema = allSchemas[i];
                var tableName = schema.schema.meta.name;
                var dirtyMap = {};

                if (schema.schema.meta.textIndex) {
                    schema.schema.meta.textIndex['__hx_generated'] = false;
                }
                var curVer = Helix.DB.migrateTable(Helix.DB.__schemaVersion, schema, metaName, dirtyMap);
                if (curVer > 0) {
                    // Migrations must be done.
                    dirty = true;
                    
                    persistence.migrate(Helix.DB.__schemaVersion, curVer);
                    Helix.DB.__schemaVersion = curVer;
                    
                    // This table exists. All updates to it are handle as sync hooks.
                    persistence.generatedTables[tableName] = true;
                    
                    if (!dirtyMap['textindex']) {
                        // Do not regenerate textIndex tables.
                        if (schema.schema.meta.textIndex) {
                            schema.schema.meta.textIndex['__hx_generated'] = true;
                        }
                    }
                } else if (curVer <= 0) {
                    if (curVer == 0) {
                        // This table is already in the DB. Mark it as a generated table.
                        persistence.generatedTables[tableName] = true;
                        // Do not regenerate textIndex tables.
                        if (schema.schema.meta.textIndex) {
                            schema.schema.meta.textIndex['__hx_generated'] = true;
                        }
                    }
                }
            }
            return dirty;
        },

        migrateTable: function(oldVersion, schema, metaName, dirtyMap) {
            var tableName = schema.schema.meta.name;
            var schemaRec = window.__pmAllTables[tableName];
            if (schemaRec == null) {
                // This is a new table.
                var newSchema = new window.__pmMasterDB();
                newSchema.metaName = metaName;
                newSchema.tableVersion = 0;
                newSchema.tableName = tableName;
                newSchema.tableFields = JSON.stringify(schema.fields);
                newSchema.keyField = schema.keyField;
                newSchema.sortFields = JSON.stringify(schema.sortFields);
                newSchema.filterFields = JSON.stringify(schema.filterFields);
                newSchema.globalFilterFields = JSON.stringify(schema.globalFilterFields);
                newSchema.textIndexFields = JSON.stringify(schema.textIndexFields);

                // Convert relationships to JSON.
                newSchema.tableOneToMany = Helix.DB.convertRelationshipToString(schema.schema.meta.hasMany);
                newSchema.tableManyToOne = Helix.DB.convertRelationshipToString(schema.schema.meta.hasOne);

                persistence.add(newSchema);
                
                // New table - return -1;
                return -1;
            } else {
                var dirty = 0;
                var fieldsChanged = 0;
                var oldSorts, newSorts;
                var oldKey, newKey;
                var oldFilters, newFilters;
                var oldGlobalFilters, newGlobalFilters;
                var oldTextIndex, newTextIndex;
                var allNewFields = {};
                var allOldFields = {};

                var tf = $.parseJSON(schemaRec.tableFields);
                if (!Helix.Utils.objectsEqual(tf, schema.fields)) {
                    var fieldsString = JSON.stringify(schema.fields);
                    dirty = 1;
                    fieldsChanged = 1;
                    schemaRec.tableFields = fieldsString;
                    dirtyMap['fields'] = true;
                }
                $.extend(allOldFields, tf);
                $.extend(allNewFields, schema.fields);
                
                var manyToOneStr = Helix.DB.convertRelationshipToString(schema.schema.meta.hasOne);
                var oldManyToOne = $.parseJSON(schemaRec.tableManyToOne);
                if (manyToOneStr !== schemaRec.tableManyToOne) {
                    var allManyToOne = {};
                    $.extend(allManyToOne, oldManyToOne);
                    
                    // At this point, allManyToOne includes all old fields. We want to
                    // see if this schema sync is *adding* fields, in which case we mark
                    // the field list as dirty. We DO NOT delete many to one reference fields
                    // because we want to allow a single object type to have different parent
                    // objects in different load commands.
                    for (var newFld in schema.schema.meta.hasOne) {
                        if (!allManyToOne[newFld]) {
                            // we have a new relationship field ...
                            fieldsChanged = 1;
                            var r = schema.schema.meta.hasOne[newFld];
                            allManyToOne[newFld] = {
                                "table" : r.type.__hx_schema_name, 
                                "inverse": r.inverseProperty
                            };
                        }
                    }
                    dirty = 1;
                    
                    // XXX: for now, we never delete relationship fields. Eventually we
                    // might find a way to check and see if the table we are relating to
                    // is deleted, but first we need to invent a mechanism for table deletion.
                    manyToOneStr = JSON.stringify(allManyToOne);
                    schemaRec.tableManyToOne = manyToOneStr;
                    
                    $.extend(allNewFields, allManyToOne);
                    dirtyMap['manytoone'] = true;
                } else if (dirtyMap['fields']) {
                    // We are going to migrate all fields. Make sure we don't omit an id
                    // relationship field.    
                    $.extend(allNewFields, schema.schema.meta.hasOne);
                }
                $.extend(allOldFields, oldManyToOne);
                
                var oneToManyStr = Helix.DB.convertRelationshipToString(schema.schema.meta.hasMany);
                if (oneToManyStr !== schemaRec.tableOneToMany) {
                    dirty = 1;
                    schemaRec.tableOneToMany = oneToManyStr;
                    dirtyMap['onetomany'] = true;
                }
                
                var sortFields = JSON.stringify(schema.sortFields);
                if (sortFields !== schemaRec.sortFields) {
                    dirty = 1;
                    oldSorts = $.parseJSON(schemaRec.sortFields);
                    newSorts = schema.sortFields;
                    schemaRec.sortFields = sortFields;
                    dirtyMap['sorts'] = true;
                }
                var filterFields = JSON.stringify(schema.filterFields);
                if (filterFields !== schemaRec.filterFields) {
                    dirty = 1;
                    oldFilters = $.parseJSON(schemaRec.filterFields);
                    newFilters = schema.filterFields;
                    schemaRec.filterFields = filterFields;
                    dirtyMap['filters'] = true;
                }

                var globalFilterFields = JSON.stringify(schema.globalFilterFields);
                if (globalFilterFields !== schemaRec.globalFilterFields) {
                    dirty = 1;
                    oldGlobalFilters = $.parseJSON(schemaRec.globalFilterFields);
                    newGlobalFilters = schema.globalFilterFields;
                    schemaRec.globalFilterFields = globalFilterFields;
                    dirtyMap['globalfilters'] = true;
                }

                var textIndexFields = JSON.stringify(schema.textIndexFields);
                if (textIndexFields !== schemaRec.textIndexFields) {
                    dirty = 1;
                    oldTextIndex = $.parseJSON(schemaRec.textIndexFields);
                    newTextIndex = schema.textIndexFields;
                    schemaRec.textIndexFields = textIndexFields;
                    dirtyMap['textindex'] = true;
                }

                if (schema.keyField !== schemaRec.keyField) {
                    dirty = 1;
                    oldKey = schemaRec.keyField;
                    newKey = schema.keyField;
                    schemaRec.keyField = schema.keyField;
                    dirtyMap['key'] = true;
                }
                
                if (dirty) {
                    schemaRec.tableVersion = schemaRec.tableVersion + 1;
                    Helix.DB.defineTableMigration(oldVersion,
                        schemaRec.tableName, allNewFields, allOldFields, fieldsChanged,
                        oldSorts, newSorts,
                        oldKey, newKey,
                        oldFilters, newFilters,
                        oldGlobalFilters, newGlobalFilters,
                        oldTextIndex, newTextIndex);
                    
                    // > 0 - means we need to migrate.
                    return oldVersion + 1;
                } else {
                    // 0 means schema is unchanged.
                    return 0;
                }
            }
        },
    
        defineTableMigration: function(oldVersion,
            tableName, allNewFields, allOldFields, fieldsChanged,
            oldSorts, newSorts,
            oldKey, newKey,
            oldFilters, newFilters,
            oldGlobalFilters, newGlobalFilters,
            oldTextIndex, newTextIndex) {
            
            persistence.defineMigration(oldVersion + 1, {
                up: function() {
                    var allNewIndices = {};
                    if (fieldsChanged) {
                        this.updateColumns(allNewFields, allOldFields, tableName);              
                    }
                    if (oldSorts && newSorts) {
                        Helix.DB.migrateIndexes.call(this, tableName, oldSorts, newSorts, allNewIndices);
                    }
                    if (oldFilters && newFilters) {
                        Helix.DB.migrateIndexes.call(this, tableName, oldFilters, newFilters, allNewIndices);
                    }
                    if (oldGlobalFilters && newGlobalFilters) {
                        Helix.DB.migrateIndexes.call(this, tableName, oldGlobalFilters, newGlobalFilters, allNewIndices);
                    }
                    if (oldTextIndex && newTextIndex) {
                        Helix.DB.migrateIndexes.call(this, tableName, oldTextIndex, newTextIndex, allNewIndices);
                    }
                    if (oldKey && newKey) {
                        this.removeIndex(tableName, oldKey);
                        this.addIndex(tableName, newKey);
                    }
                    
                }
            });
        },
        
        migrateIndexes: function(tableName, oldIndexList, newIndexList, allNewIndices) {
            var fld = null;
            for (fld in oldIndexList) {
                if (!newIndexList[fld] && !allNewIndices[fld]) {
                    this.removeIndex(tableName, fld);                            
                }
            }
            for (fld in newIndexList) {
                if (oldIndexList[fld]) {
                    // Already indexed.
                    continue;
                }
                this.addIndex(tableName, fld);
                allNewIndices[fld] = true;
            }
        },

        generateSubSchemaFromDBRow: function(tableName,parentField,parentSchema,inverseField,isOneToMany,oncomplete) {
            Helix.DB.generatePersistenceSchemaFromDB(tableName, null, function(subSchema) {
                if (subSchema) {
                    if (isOneToMany) {
                        parentSchema.hasMany(parentField, subSchema, inverseField);
                    } else {
                        subSchema.hasMany(inverseField, parentSchema, parentField);
                    }
                }
                parentSchema.__pm_subSchemas[parentField] = subSchema;
                oncomplete(parentField, subSchema);
            });  
        },
    
        generatePersistenceSchemaFromDBRow: function(masterRow,oncomplete) {
            /* Generate the schema from this row. */
            var schema = persistence.define(masterRow.tableName, $.parseJSON(masterRow.tableFields) );
            /* SAH - mark this as a table that does not need to be re-created in the DB. */
            persistence.generatedTables[masterRow.tableName] = true;
            schema.index(masterRow.keyField, {
                unique: true
            });
            schema.__hx_key = masterRow.keyField;
            schema.__hx_sorts = masterRow.sortFields;
            schema.__hx_filters = masterRow.filterFields;
            schema.__hx_global_filters = masterRow.globalFilterFields;
            schema.__hx_text_indexes = masterRow.textIndexFields;
            schema.__pm_subSchemas = {};
            if (window.__pmLocalSchemas) {
                window.__pmLocalSchemas[masterRow.tableName] = schema;
            }
        
            var toSync = {};
            var done = function(field) {
                if (field) {
                    delete toSync[field];                
                }
            
                if (Object.keys(toSync).length == 0) {
                    oncomplete(schema);
                }
            };
        
        
            var indexFields = $.parseJSON(masterRow.sortFields);
            if (indexFields) {
                for (var sortField in indexFields) {
                    schema.index(sortField);
                }
            }
        
            var filterFields = $.parseJSON(masterRow.filterFields);
            if (filterFields) {
                for (var filterField in filterFields) {
                    if (!indexFields[filterField]) {
                        schema.index(filterField);
                    }
                }
            }
            
            var textIndexFields = $.parseJSON(masterRow.textIndexFields);
            for (var i = 0; i < textIndexFields.length; i++) {
                var indexField = textIndexFields[i];
                schema.textIndex(indexField);
            }
            // We read this from the DB - no need to attempt to re-generate the text index tables.
            if (schema.textIndex) {
                schema.textIndex['__hx_generated'] = true;
            }
        
            /* Recurse over any dependent tables for which we don't have schema. */
            var field;
        
            /* Track all of the fields we need to sync so that we don't call the completion
         * until we are truly done.
         */
            var manyToOnes = $.parseJSON(masterRow.tableManyToOne);
            if (manyToOnes) {
                for (field in manyToOnes) {
                    toSync[field] = true;
                }
            }
            var oneToManys = $.parseJSON(masterRow.tableOneToMany);
            if (oneToManys) {
                for (field in oneToManys) {
                    toSync[field] = true;
                }
            }
        
            if (Object.keys(toSync).length == 0) {
                done(null);
                return;
            }
        
            if (manyToOnes) {
                for (field in manyToOnes) {
                    Helix.DB.generateSubSchemaFromDBRow(manyToOnes[field].table,
                        field,
                        schema,
                        manyToOnes[field].inverse,
                        false,
                        done);
                }
            }        
        
            if (oneToManys) {
                for (field in oneToManys) {
                    Helix.DB.generateSubSchemaFromDBRow(oneToManys[field].table,
                        field,
                        schema,
                        oneToManys[field].inverse,
                        true,
                        done);
                }
            }
        },

        /**
     * Generates schema for the given name, including all dependent schemas. This
     * function is intended to be called when the local client is trying to access
     * a schema that is generally synchronized from the server. The most common
     * case is to do this when the client is offline, however one might also do this
     * for data that is accessed locally prior to contacting the server or for data
     * that is only stored locally.
     * 
     * @param schemaName Name of the table (schema) we are generating
     * @param schemaTemplate Template object; this is optional, and is generally useful
     *      for schemas that are never synchronized from the server.
     * @param oncomplete This function is asynchronous; this function is called upon completion.
     * @param nRetries Internal parameter - do not pass a value.
     */
        generatePersistenceSchemaFromDB: function(schemaName,schemaTemplate,oncomplete,nRetries) {
            if (!window.__pmMasterDB) {
                throw "You must call initPersistence prior to calling this routine!";
            }
            
            var __continuation = function() {
                /* First, check to see if the schema is already available. */
                if (window.__pmLocalSchemas) {
                    if (window.__pmLocalSchemas[schemaName]) {
                        oncomplete(window.__pmLocalSchemas[schemaName]);
                        return;
                    }
                } else {
                    window.__pmLocalSchemas = {};
                }

                /* If we have a template, just generate the schema from that template. Otherwise
                 * we either (a) read the schema from the DB, or (b) return null because the schema
                 * does not exist.
                 */
                if (schemaTemplate) {
                    Helix.DB.generatePersistenceSchema(schemaTemplate,schemaName,oncomplete);
                } else {
                    /* Next, lookup this schema in the master DB and generate the schema
                     * from the DB. 
                     */
                    var masterRow = window.__pmAllTables[schemaName];
                    if (masterRow) {
                        Helix.DB.generatePersistenceSchemaFromDBRow(masterRow,function(schema) {
                            // This table is already in the DB. No need to call schemaSync.
                            oncomplete(schema);
                        });
                    } else {
                        oncomplete(null);
                    }
                }
            };
            
            if (!Helix.DB.persistenceIsReady()) {
                $(document).on('hxPersistenceReady', function() {
                    __continuation();
                });
            } else {
                __continuation();
            }    
        },


        prepareSchemaTemplate: function(templateObj, tableName, keyField, sorts, filters) {
            templateObj.__hx_schema_name = tableName;
            templateObj.__hx_key = keyField;
            templateObj.__hx_sorts = sorts;
            templateObj.__hx_filters = filters;

            return templateObj;
        },

        convertRelationshipToString: function(relObject) {
            var f, r;
            var relSummary = {};
            if (relObject) {
                for (f in relObject) {
                    r = relObject[f];
                    relSummary[f] = {
                        "table" : r.type.__hx_schema_name, 
                        "inverse": r.inverseProperty
                    };
                }
            }
            return JSON.stringify(relSummary);
        },

        /**
     * Extract the key field from the schema.
     */
        getKeyField: function(schema) {
            return schema.__hx_key
        },
    
        getSchemaForObject: function(obj) {
            return obj.__hx_schema;
        },
        
        getSchemaNameForObject : function(obj) {
            if (Object.prototype.toString.call(obj) === '[object Array]') {
                if (obj.length > 0) {
                    return Helix.DB.getSchemaNameForObject(obj[0]);
                } else {
                    return null;
                }
            }
            return obj.__hx_schema.__hx_schema_name;
        },
    
        getSortsForTable: function(tableName) {
            if (!window.__pmAllSchemas) {
                return null;
            }
        
            var schema = window.__pmAllSchemas[tableName];
            return schema.__hx_sorts;
        },
    
        getFiltersForTable: function(tableName) {
            if (!window.__pmAllSchemas) {
                return null;
            }
        
            var schema = window.__pmAllSchemas[tableName];
            return schema.__hx_filters;
        },
        
        getGlobalFiltersForTable: function(tableName) {
            if (!window.__pmAllSchemas) {
                return null;
            }
        
            var schema = window.__pmAllSchemas[tableName];
            return schema.__hx_global_filters;
        },

        getSchemaForTable: function(tableName) {
            if (!window.__pmAllSchemas) {
                return null;
            }
        
            var schema = window.__pmAllSchemas[tableName];
            return schema;
        },

        getSchemaNameForField: function(persistentObj, fieldName) {
            if (fieldName in persistentObj.__hx_schema.__pm_subSchemas) {
                return persistentObj.__hx_schema.__pm_subSchemas[fieldName].__hx_schema_name;
            }
            return null;
        },
        
        getSchemaForField: function(persistentObj, fieldName) {
            if (fieldName in persistentObj.__hx_schema.__pm_subSchemas) {
                return persistentObj.__hx_schema.__pm_subSchemas[fieldName];
            }
            return null;
        },
    
        createSchemaForTable: function(tableName, fields, indices) {
            var newSchema = persistence.define(tableName, fields);
            window.__pmAllSchemas[tableName] = newSchema;
            var i = 0;
            if (indices) {
                for (i = 0; i < indices.length; ++i) {
                    newSchema.index(indices[i]);
                }            
            }
            return newSchema;
        },
    
        /**
         * Data synchronization routines.
         */
    
        cascadingRemoveQueryCollection: function(queryCollection, oncomplete, overrides) {
            var toDelete = [];
            var cascade = function() {
                if (toDelete.length == 0) {
                    oncomplete();
                    return;
                }
                
                var elem = toDelete.pop();
                Helix.DB.cascadingRemove(elem, function() {
                    queryCollection.remove(elem);
                    persistence.remove(elem);
                    if (overrides.deleteHook) {
                        overrides.deleteHook(elem);
                    }
                    cascade();
                }, overrides);
            };
        
            
            queryCollection.newEach({
                eachFn: function(elem) {
                    toDelete.push(elem);
                },
                doneFn: function(ct) {
                    cascade();
                }
            });
        },
    
        cascadingRemove: function(persistentObj, oncomplete, overrides) {
            var toCascade = [];
            var recurseDown = function() {
                if (toCascade.length == 0) {
                    //persistence.remove(persistentObj);
                    oncomplete(persistentObj, "remove");
                    return;
                }
                
                var nxt = toCascade.pop();
                if (nxt.forEach) {
                    // Query collection.
                    Helix.DB.cascadingRemoveQueryCollection(nxt, recurseDown, overrides);
                } else {
                    Helix.DB.cascadingRemove(nxt, recurseDown, overrides);
                }
            };
            
            // First, save off the objects we need to delete recursively. When we are done, we call
            // recurseDown above.
            var fields = Object.keys(persistentObj._data).slice(0);
            var collect = function() {
                if (fields.length == 0) {
                    recurseDown();
                    return;
                }
                
                var fld = fields.pop();
                if (!persistentObj.hasOwnProperty(fld)) {
                    collect();
                    return;
                }
                
                try {
                    var getter = Object.getOwnPropertyDescriptor(persistentObj, fld).get;
                    var subObj = getter.call(persistentObj);
                    if (subObj && subObj.forEach) {
                        toCascade.push(subObj);
                    }
                    collect();
                } catch(err) {
                    persistentObj.fetch(fld, function(obj) {
                        // This is a one-to-one relationship with an object.
                        if (obj) {
                            toCascade.push(obj);
                        }
                        collect();
                    });
                }
            };
            // Start the recursion.
            collect();
        },
    
        addObjectToQueryCollection: function(allSchemas,
            obj,
            elemSchema, 
            queryCollection, 
            overrides,
            oncomplete,
            opaque) {
            Helix.DB.synchronizeObjectFields(allSchemas, obj, null, elemSchema, function(finalObj) {
                queryCollection.add(finalObj);
                oncomplete(finalObj, opaque);
            }, overrides);
        },
    
        synchronizeQueryCollection: function(allSchemas,
            newObjectMap, 
            parentCollection,
            compareCollection,
            elemSchema, 
            keyFieldName, 
            oncomplete, 
            oncompleteArg,
            overrides) {


            var syncObjs = [];
            var deleteObjs = [];
            var addObjs = [];
            compareCollection.newEach({
                eachFn: function(qryElem) {
                    var qryElemKeyValue = qryElem[keyFieldName];
                    if (newObjectMap[qryElemKeyValue]) {
                        /* The query collection has an object with the same key as an object
                         * in the newObjectMap. Synchronize fields and remove from the map.
                         */
                        var newObj = newObjectMap[qryElemKeyValue];
                        delete newObjectMap[qryElemKeyValue];
                        syncObjs.push({  
                            'newObj' : newObj,
                            'oldObj' : qryElem
                        });
                    } else {
                        /* The query collection has an object that is not in the newObjectMap. Remove it.
                         * We don't proceed until this is done, because otherwise other points in the
                         * sync may pick up stale objects.
                         */
                        deleteObjs.push(qryElem);
                    }
                },
                doneFn: function() {
                    /* Called when the iteration over the query collection is done. */

                    /* First compile the list of objects remaining in the newObjectMap that we
                     * are going to add.
                     */
                    for (var k in newObjectMap) {
                        addObjs.push(newObjectMap[k]);
                    }

                    var doAdds = function() {
                        if (addObjs.length > 0) {
                            var toAdd = addObjs.pop();
                            Helix.DB.addObjectToQueryCollection(allSchemas, toAdd, elemSchema, parentCollection, overrides, doAdds);
                        } else {
                            oncomplete(oncompleteArg);
                        }
                    };

                    var removeFn = function(persistentObj) {
                        if (persistentObj) {
                            parentCollection.remove(persistentObj);
                            persistence.remove(persistentObj);
                            if (overrides.deleteHook) {
                                overrides.deleteHook(persistentObj);
                            }
                        }

                        if (deleteObjs.length > 0) {
                            var toDelete = deleteObjs.pop();
                            Helix.DB.cascadingRemove(toDelete,removeFn,overrides);
                        } else {
                            /* Nothing more to remove. Add in any new objects. */
                            doAdds();
                        }
                    };

                    var syncFn = function() {
                        if (syncObjs.length > 0) {
                            var toSync = syncObjs.pop();
                            Helix.DB.synchronizeObjectFields(allSchemas, toSync.newObj, toSync.oldObj, elemSchema, syncFn, overrides);
                        } else {
                            /* Nothing more to sync. Do all removes. */
                            removeFn();
                        }
                    };

                    syncFn();
                }
            });
        },

        synchronizeArrayField: function(allSchemas, objArray, parentObj, parentCollection, elemSchema, field, oncomplete, overrides) {
            /* Synchronize the query collection. First, we create a map from keys to objects
             * from the new objects in obj[arrLocalField].
             */
            
            /* Refine the query collection using a user-configured call. By default this is
             * an identity call (i.e, it just returns parentCollection). However, in some
             * cases the user knows that a load only loaded a subset of a data list from
             * the server. This call is used to refine the list for comparison.
             */
            var comparisonCollection = overrides.refineEntityArray(field, parentCollection);
            
            /* Handle the special case where the object array has 0 elements. In this case,
             * we just issue a delete. But we do NOT flush the session.
             */
            if (objArray.length == 0) {
                if (!parentObj._new) {
                    // We only need to destroy all child objects in an array relationship if
                    // the parent object is not new. If it is new, comparisonCollection will
                    // always be empty.
                    comparisonCollection.destroyAll();                
                }
                oncomplete(field);
                return;
            }
            
            
            var elemKeyField = Helix.DB.getKeyField(elemSchema);
            var elemMap = {};
            
            for (var i = 0; i < objArray.length; ++i) {
                var curElem = objArray[i];
                elemMap[curElem[elemKeyField]] = curElem;
            }
        
            /* Now sync the query collection against the elemMap. NOTE: delta objects are the more
             * efficient way to do this!
             */
            Helix.DB.synchronizeQueryCollection(allSchemas, elemMap, parentCollection, comparisonCollection, elemSchema, elemKeyField, oncomplete, field, overrides);
        },
    
        updateOneObject: function(allSchemas, persistentObjID, updatedObj, keyField, toUpdateKey, elemSchema, oncomplete, overrides) {
            // To truly "update" an object we would need to actually retrieve that object, then, one by one, update
            // each field of that object. This is incredibly inefficient. Instead, we use the entity ID of this object
            // from the DB to add it to the session and mark all properties in the object dirty (except those that the
            // sync override tells us not to override ...). Then we update the object.
            //elemSchema.findBy(keyField, toUpdateKey, function(toUpdateObj) {
            var toUpdateObj = new elemSchema();
            toUpdateObj.markPersistent(persistentObjID);
            Helix.DB.synchronizeObjectFields(allSchemas, updatedObj, toUpdateObj, elemSchema, function(newObj) {
                if (overrides.updateHook) {
                    overrides.updateHook(newObj);
                }
                oncomplete(newObj);
            }, overrides);
            //});
        },
    
        synchronizeDeltaField: function(allSchemas, deltaObj, parentCollection, elemSchema, field, oncomplete, overrides) {
            var keyField = this.getKeyField(elemSchema);

            var nToAdd = deltaObj.adds.length;
            var nAddsDone = 0;
            var allAdds = [];
            var addDone = function(pObj) {
                ++nAddsDone;
                allAdds.push(pObj);
                if (nAddsDone == nToAdd) {
                    /* Nothing more to add - we are done. */
                    oncomplete(field, allAdds);
                }
            };

            var doAdds = function(uidToEID) {
                if (deltaObj.adds.length == 0) {
                    oncomplete(field, allAdds);
                } else {
                    while (deltaObj.adds.length > 0) {
                        var toAdd = deltaObj.adds.pop();
                        var toAddKey = toAdd[keyField];

                        var objId = uidToEID[toAddKey];
                        if (objId) {
                            Helix.DB.updateOneObject(allSchemas,objId,toAdd,keyField,toAddKey,elemSchema,function(pObj) {
                                parentCollection.add(pObj);
                                addDone(pObj);
                            },overrides);
                        } else {
                            Helix.DB.addObjectToQueryCollection(allSchemas,toAdd,elemSchema, parentCollection,overrides,addDone,uidToEID);
                        }                        
                    }                                     
                }
            };

            var syncFn = function(uidToEID) {
                if (deltaObj.updates.length > 0) {
                    var updatedObj = deltaObj.updates.pop();
                    var toUpdateKey = updatedObj[keyField];
                    var objId = uidToEID[toUpdateKey];
                    Helix.DB.updateOneObject(allSchemas,objId,updatedObj,keyField,toUpdateKey,elemSchema,syncFn,overrides);                    
                } else {
                    /* Nothing more to sync. Do all removes. */
                    doAdds(uidToEID);
                }
            };
            
            var createUIDToEIDMap = function() {
                var uidToEID = {};
                if (deltaObj.adds.length == 0 &&
                    deltaObj.updates.length == 0) {
                    // Skip to the finish line ...
                    doAdds(null);
                } else {
                    elemSchema.all().include([keyField]).newEach({    
                        eachFn: function(elem) {
                            uidToEID[elem[keyField]] = elem.id;
                        }, 
                        doneFn: function() {
                            syncFn(uidToEID);
                        }
                    });
                }
            };
            
            var prepareAdds = function() {
                var addUniqueIDs = [];
                for (var i = 0; i < deltaObj.adds.length; ++i) {
                    addUniqueIDs.push(deltaObj.adds[i][keyField]);
                }
                createUIDToEIDMap();
            };
            
            var removeFn = function(persistentObj) {
                if (persistentObj) {
                    parentCollection.remove(persistentObj);
                    persistence.remove(persistentObj);
                    if (overrides.deleteHook){
                        overrides.deleteHook(persistentObj);
                    }
                }

                if (deltaObj.deletes.length > 0) {
                    var toDeleteKey = deltaObj.deletes.pop();
                    parentCollection.filter(keyField, "=", toDeleteKey).newEach({
                        eachFn: function(elem) { 
                            if (elem) {
                                Helix.DB.cascadingRemove(elem,removeFn,overrides);
                            }
                        },
                        startFn: function(ct) {
                            if (ct == 0) {
                                removeFn();
                            }
                        }
                    });
                } else {
                    /* Make sure all deletes are in the DB. */
                    persistence.flush(function() {
                        /* Nothing more to remove. Add in any new objects. */
                        prepareAdds();                
                    });
                }
            };

            /* Handle deletes, then sync. Then we handle modifications and adds. */
            removeFn();
        },
    
        synchronizeDeltaObject: function(allSchemas, deltaObj, parentCollection, elemSchema, oncomplete, overrides) {
            Helix.DB.synchronizeDeltaField(allSchemas, deltaObj, parentCollection, elemSchema, null, function(fld, allAdds) {
                oncomplete(allAdds);
            }, overrides);
        },
    
        synchronizeObjectField: function(allSchemas, obj, persistentObj, objSchema, field, keyField, oncomplete, overrides) {
            // Update the old object (if it exists) or add the new with a recursive call.
            var objLocalField = field;
            var setter = Object.getOwnPropertyDescriptor(persistentObj, objLocalField).set;
            objSchema.findBy(keyField, obj[keyField], function(dbObj) {
                Helix.DB.synchronizeObjectFields(allSchemas, obj,dbObj,objSchema,function(newObj) {
                    setter.call(persistentObj, newObj);
                    oncomplete(objLocalField);
                }, overrides);
            });
        },

        /**
         * Synchronizes the object fields against either (a) a fresh object, or (b) a 
         * populated object read from the database.
         */
        synchronizeObjectFields: function(allSchemas, obj, persistentObj, objSchema, oncomplete, overrides) {
            /* First determine what fields we will need to handle asynchronously. We are going
             * to execute a recursive descent algorithm, going into sub-arrays and sub-objects of
             * obj and synchronizing them before we synchronize obj itself. The reason is that
             * when we update persistentObj (or create it) the persistence mechanism marks that
             * object as dirty. If a sub-array sync operation triggers a flush to the DB (which it does)
             * then we will asynchronously execute many simultaneous flushes of the same object. This
             * causes a lot of extra DB churn and it will over-populate the full text index.
             */
            var asyncFields = [];
            var scalarFields = [];
            allSchemas[objSchema.__hx_schema_name] = objSchema;
            for (var field in obj) {
                if (!obj.hasOwnProperty(field)) {
                    continue;
                }
                if (field in Helix.DB.reservedFields) {
                    continue;
                }
                if (Object.prototype.toString.call(obj[field]) === '[object Array]' ||
                    Object.prototype.toString.call(obj[field]) === '[object Object]') {
                    asyncFields.push(field);    
                } else {
                    scalarFields.push(field);
                }
            }
            
            if (!persistentObj) {
                persistentObj = new objSchema();
                persistence.add(persistentObj);        
            }
            persistentObj.__hx_schema = objSchema;
            persistentObj.__hx_key = obj[this.getKeyField(objSchema)];
            
            /* Now synchronize all scalar fields (i.e. non-object, non-array) to ensure that we don't 
             * make a bunch of objects dirty and flush them over and over again as
             * we recurse through their children. We make all non-relation changes before
             * we do anything that might trigger a flush.
             */
            while (scalarFields.length > 0) {
                field = scalarFields.pop();
                /* Use the setter to make sure the object is marked as dirty appropriately. */
                var setter = Object.getOwnPropertyDescriptor(persistentObj, field).set;
                if (!overrides.syncFields(setter, obj, field, persistentObj)) {
                    setter.call(persistentObj, obj[field]);
                }
            }
            
            /* Called when an asynchronous relationship field is done sync'ing. */
            var syncDone = function() {
                if (overrides.addHook) {
                    overrides.addHook(persistentObj);
                }
                
                oncomplete(persistentObj);
            };
            
            /* Now handle relationship fields. We must handle them ONE at a time. Otherwise we get multiple asynchronous
             * calls to persistence.flush which stomp all over each other ...
             */
            var handleAsyncFields = function() {
                /* See if we are done. */
                if (asyncFields.length == 0) {
                    syncDone();
                    return;
                }
                
                var field = asyncFields.pop();
                var fieldSchema = objSchema.__pm_subSchemas[field];
                var fieldVal = obj[field];
                if (Object.prototype.toString.call(fieldVal) === '[object Array]') {
                    /* Synchronize the array field - since this is not a delta object, we assume the returned
                     * object has all fields that should be in this data table.
                     */
                    Helix.DB.synchronizeArrayField(allSchemas, fieldVal, persistentObj, persistentObj[field], fieldSchema, field, handleAsyncFields, overrides);
                } else if (Object.prototype.toString.call(fieldVal) === '[object Object]') {
                    if (fieldVal.__hx_type == 1001) {
                        Helix.DB.synchronizeDeltaField(allSchemas, fieldVal, persistentObj[field], fieldSchema, field, handleAsyncFields, overrides);                 
                    } else {
                        var keyField = Helix.DB.getKeyField(fieldSchema);
                        Helix.DB.synchronizeObjectField(allSchemas, fieldVal, persistentObj, fieldSchema, field, keyField, handleAsyncFields, overrides); 
                    }      
                }                
            };
            
            /* Handle all asynchronous fields. */
            handleAsyncFields();
        },

        synchronizeArray: function(allSchemas, obj,objSchema,persistentObj,callback,overrides) {
            Helix.DB.synchronizeArrayField(allSchemas, obj, null, persistentObj, objSchema, null, function() {
                callback(persistentObj);
            }, overrides);
        },

        /**
         * Call this function to synchronize an object to the database after loading that
         * object from the remote server. This function first queries the database using the 
         * object's key field to see if it exists. If so, it updates the old object to 
         * match the new one. If not, it simply converts the object into a persistent object 
         * and flushes it to the DB. Invoke the callback on completion.
         */
        synchronizeObject: function(obj,objSchema,callback,opaque,overrides) {
            var allSchemas = {};
            var syncDone = function(finalObj, opaque) {            
                /* We get here when the synchronize is done. */
                persistence.flush(function() {
                    /* This will either send an object to the callback. */
                    callback(finalObj,opaque);
                    
                    /* Again launch async indexing. If indexing is already in progress or there
                     * is nothing to do, then this will do nothing.
                     */
                    // Launch async indexing ... these calls do nothing if there are
                    // no fields to index or if async indexing is not enabled.
                    for (var schemaName in allSchemas) { 
                        var indexSchema = allSchemas[schemaName];
                        indexSchema.indexAsync(0, Helix.DB.indexFull);
                    }
                });
            };
        
            /* Check the overrides. IF we do not have overrides for the field sync then
             * install the default.
             */
            if (!overrides) {
                overrides = {};
            }
            if (!overrides.syncFields) {
                overrides.syncFields = Helix.DB.Utils.defaultFieldSync;
            }
            if (!overrides.refineEntityArray) {
                overrides.refineEntityArray = Helix.DB.Utils.identityRefineEntityArray;
            }
            
            if (Object.prototype.toString.call(obj) === '[object Array]') {
                Helix.DB.synchronizeArray(allSchemas, obj,objSchema,objSchema.all(),function(finalObj) {
                    syncDone(finalObj, opaque);
                },overrides);
            } else if (obj.__hx_type == 1001) {
                Helix.DB.synchronizeDeltaObject(allSchemas, obj,objSchema.all(),objSchema,function(finalObj) {
                    syncDone(finalObj, opaque);
                },overrides);
            } else if (obj.__hx_type == 1003) {
                // This is an aggregate load command. Each object field represents a distinct object that
                // should be synchronized independently of the others.
                var toSync = Object.keys(obj).slice(0);
                var resultObj = {};
                
                /* Serialize synchronization of each component so that we never have >1 flush in progress. */
                var syncComponent = function() {
                    if (toSync.length == 0) {
                        syncDone(resultObj, opaque);
                        return;
                    }
                    
                    var nxt = toSync.pop();
                    if (nxt == "__hx_type") {
                        syncComponent();
                        return;
                    }
                    var loadCommandConfig = overrides.schemaMap[nxt];
                    Helix.DB.synchronizeObject(obj[nxt], loadCommandConfig.schema, function(finalObj, objName) {
                        resultObj[objName] = finalObj;
                        syncComponent();
                    }, nxt, loadCommandConfig.syncOverrides);
                };
                syncComponent();
            } else {
                var keyField = Helix.DB.getKeyField(objSchema);
                objSchema.findBy(keyField, obj[keyField], function(persistentObj) {
                    Helix.DB.synchronizeObjectFields(allSchemas, obj, persistentObj, objSchema, function(finalObj) {
                        /* Store the schema in the final obj. */
                        finalObj.__hx_schema = objSchema;
                        syncDone(finalObj, opaque);
                    }, overrides);
                });
            }            
        },

        /**
     * In this case there is no new data to synchronize. We are really just pulling
     * an object from the database and handing it back to the caller.
     */
        synchronizeObjectByKey: function(key,objSchema,callback) {
            var loadDone = function(persistentObj) {
                if (persistentObj) {
                    persistentObj.__hx_schema = objSchema;
                }
                callback(persistentObj);
            };
            var keyField = this.getKeyField(objSchema);
            objSchema.findBy(keyField, key, loadDone);
        },

        loadAllObjects: function(objSchema, callback) {
            var persistentObjs = objSchema.all();
            callback(persistentObjs);
        },

        /**
     * Called when this file is loaded. Creates the master table, which is used
     * to store the schemas of all other tables. The master schemas has a very simple
     * format - it is a 4 column table with the table name, the JSON for table fields,
     * the JSON for oneToMany relationships, and the JSON for manyToOne relationships.
     * The metaName is used to generate which loadCommand triggered this DB create.
     * 
     * We use this to check the schema for updates. If an update has occurred then
     * we run the update statements directly against the DB.
     */
        pmCreateMasterTable: function () {
            window.__pmMasterDB = persistence.define('MasterDB',{
                metaName : "TEXT",
                tableVersion: "INT",
                tableName: "TEXT",
                tableFields: "TEXT",
                keyField: "TEXT",
                sortFields: "TEXT",
                filterFields: "TEXT",
                globalFilterFields: "TEXT",
                textIndexFields: "TEXT",
                tableOneToMany: "TEXT",
                tableManyToOne: "TEXT",
                masterDBVer: "INT"
            });
            window.__pmMasterDB.index('tableName', {
                unique: true
            });
            
            var allTables = {};
            var masterDBVer = 0;
            persistence.schemaSync(function(tx) {
                window.__pmMasterDB.all().newEach({
                    eachFn: function(elem) {
                        if (elem.masterDBVer) {
                            masterDBVer = elem.masterDBVer;
                        }
                        
                        allTables[elem.tableName] = elem;
                    }, 
                    doneFn: function(ct) {
                        var dirty = 0;
                        if (masterDBVer == 0 && ct > 0) {
                            dirty = 1;
                            persistence.schemaSyncHooks.push(function() {
                                var queries = [];
                                queries.push(["ALTER TABLE MasterDB ADD COLUMN masterDBVer TEXT" , null]);
                                queries.push(["ALTER TABLE MasterDB ADD COLUMN textIndexFields TEXT" , null]);
                                return queries.reverse();
                            });
                        }
                        if (masterDBVer != Helix.DB.__masterDBVer) {
                            dirty = 1;
                            persistence.nextSchemaSyncHooks.push(function() {
                                var queries = [];
                                queries.push(["UPDATE MasterDB SET masterDBVer=?", [ Helix.DB.__masterDBVer ]]);
                                return queries;
                            });
                        }
                        
                        if (dirty) {
                            persistence.schemaSync(function() {
                                window.__persistenceReady = true;
                                window.__pmAllTables = allTables;
                                $(document).trigger('hxPersistenceReady');
                            });
                        } else {
                            window.__persistenceReady = true;
                            window.__pmAllTables = allTables;
                            $(document).trigger('hxPersistenceReady');
                        }
                    }
                })
            });
        },
    
        initPersistence: function () {
            window.__persistenceReady = false;
            
            /* Initialize PersistenceJS for use with WebSQL. Eventually need to add IndexedDB support. */
            persistence.store.websql.config(persistence, 'OfflineAppDB', 'Managed offline DB for app.', 5 * 1024 * 1024);
            
            /* Initialize PersistenceJS searching. */
            persistence.search.config(persistence, persistence.store.websql.sqliteDialect, {
                indexAsync : true
            });

            /* Keep a master list of all widget schemas we have attempted to create. This ensures we
             * don't recreate the schema each time we run a load command.
             */
            this.createdSchemas = {};

            /* Initialize PersistenceJS migrations. */
            persistence.transaction(function(tx) {
                persistence.migrations.init(tx, function() {
                    persistence.migrations.Migrator.version(tx, function(schemaVer) {
                        Helix.DB.__schemaVersion = schemaVer;
                        Helix.DB.pmCreateMasterTable();
                    });
                });
            });
        },
    
        persistenceIsReady: function() {
            if (!window.__persistenceReady) {
                return false;
            }
        
            return true;
        }
    };
    
    initHelixDBUtils();
}
;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function initHelixDBUtils() {
    Helix.DB.Utils = {
    
        /**
     * Check if a numeric value is an integer. Used to infer data types for
     * object schema.
     */
        isInt: function(n) {
            return n % 1 === 0;
        },
    
        /**
     * Default sync fields override. Just return false, which means that the framework
     * should handle the field sync.
     * 
     * @param persistentObjSetter The persistent object's setter for this field.
     * @param newObj The new object we are synchronizing against the DB.
     * @param fieldName The name of the field we are synchronizing.
     * @return true if this routine handled the sync; false if not
     */
        defaultFieldSync: function(persistentObjSetter, newObj, fieldName) {
            return false;
        },
    
        /**
     * Default array refinement function that just returns the identity (i.e., returns
     * the query collection it is given). This override is used when only a subset
     * of a table is synchronized during a load command.
     * 
     * @param field The name of the field we are synchronizing against the query collection.
     * @param queryCollection Collection in the DB that should match the array pointed to by field.
     * @return Returns a query collection that represents the proper set of objects to compare.
     */
        identityRefineEntityArray: function(field, queryCollection) {
            return queryCollection;
        }
    };
};/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function() {
    $(document).on('cordovaReady', function() {
        if (window.Helix.DB === undefined) {
            if (window.CordovaInstalled) {
                MobileHelixDatabase.install();
            }
            initHelixDB();
            definePersistenceMigrations()
        }

        Helix.DB.initPersistence();
    });
})();;/*
 * jQuery prettyDate v1.1.0
 *
 * @author John Resig (ejohn.org)
 * @author Jrn Zaefferer
 * @author Timo Tijhof
 *
 * Based on http://ejohn.org/blog/javascript-pretty-date
 * Documentation: http://bassistance.de/jquery-plugins/jquery-plugin-prettydate/
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

(function ($) {
	'use strict';

	var slice = Array.prototype.slice,
		rES5ts = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/,
		// Indexes in a rES5ts match list that are required for Date.UTC,
		// Use in a loop to replace undefined with 0 (otherwise Date.UTC would give NaN)
		dateUrcReqIndx = [1, 4, 5, 6, 7, 10, 11];

	$.prettyDate = {

		/**
		 * Replace numerial placeholders ({0}, {1}, ..) with the value
		 * at that index in the array or variadic list of arugments.
		 * When called with only a source, a function is returned that calls itself
		 * again, that time with the arguments passed to apply the template.
		 *
		 * @param {string} source Text containing {#} placeholders where
		 *  '#' is a number referring to an index in `params`.
		 * @param {string|Array} [params...] List of replacement values or a
		 *  varadic argument list starting where this argument is the first one.
		 */
		template: function (source, params) {
			if (arguments.length === 1) {
				return function () {
					var args = slice.call(arguments);
					args.unshift(source);
					return $.prettyDate.template.apply(this, args);
				};
			}
			// Detect different call patterns:
			// * template(source, [1, 2, 3])
			// * template(source, 1, 2, 3)
			if (!$.isArray(params)) {
				params = slice.call(arguments, 1);
			}
			$.each(params, function (i, n) {
				source = source.replace(new RegExp('\\{' + i + '\\}', 'g'), n);
			});
			return source;
		},

		/**
		 * Offset from which the relative date will be generated.
		 * @return {Date}
		 */
		now: function () {
			return new Date();
		},

		/**
		 * Implementation of the ES5 Date.parse specification (ES5 15.9.4.2,
		 * which is a subset of ISO 8601), see http://es5.github.com/#x15.9.1.15.

		 * Since Date.parse already existed in old browsers and there would be
		 * many forms to be tested for, don't use feature-detection but just
		 * implement it straight up.
		 *
		 * Based on https://github.com/csnover/js-iso8601
		 *
		 * @example
		 *  '2012'
		 *  '2012-01-07'
		 *  '2012-01-07T23:30:59Z'
		 *  '2012-01-07T23:30:59+01:00'
		 *  '2012-01-07T23:30:59.001+01:00'
		 * @param {string} timestamp
		 * @return {number} Unix epoch or NaN.
		 */
		parse: function (timestamp) {
			var i, k, minutesOffset,
				m = rES5ts.exec(timestamp);
			if (!m) {
				return NaN;
			}
			for (i = 0; (k = dateUrcReqIndx[i]); i += 1) {
				m[k] = +m[k] || 0;
			}
			// Undefined days and months are allowed
			m[2] = +m[2] || 1;
			m[3] = +m[3] || 1;

			if (m[8] !== 'Z' && m[9] !== undefined) {
				minutesOffset = m[10] * 60 + m[11];

				if (m[9] === '+') {
					minutesOffset = 0 - minutesOffset;
				}
			} else {
				minutesOffset = 0;
			}

			return Date.UTC(
				// Year
				m[1],
				// Month
				m[2] - 1,
				// Day
				m[3],
				// Hour
				m[4],
				// Minutes
				// Date.UTC allows values higher than 59 here,
				// it increments hours, days etc. if needed.
				m[5] + minutesOffset,
				// Seconds
				m[6],
				// Milliseconds
				m[7]
			);
		},

		/**
		 * Takes an ISO time and returns a string representing how
		 * long ago the date represents.
		 * @param {string} targetTs Timestamp in ISO 8601 format.
		 * @return {string}
		 */
		format: function (target) {
			var messages,
				targetTime = $.prettyDate.parse(target),
				nowTime = $.prettyDate.now().getTime(),
				diff = (nowTime - targetTime) / 1000,
				dayDiff = Math.floor(diff / 86400);

			if (isNaN(dayDiff) || dayDiff < 0) {
				return;
			}

			messages = $.prettyDate.messages;
			return dayDiff === 0 && (
					diff < 60 && messages.now ||
					diff < 120 && messages.minute ||
					diff < 3600 && messages.minutes(Math.floor(diff / 60)) ||
					diff < 7200 && messages.hour ||
					diff < 86400 && messages.hours(targetTime/*Math.floor(diff / 3600)*/)) ||
					dayDiff === 1 && messages.yesterday ||
					dayDiff < 7 && messages.days(dayDiff) ||
					dayDiff < 8 && messages.week ||
					dayDiff < 14 && messages.days(dayDiff) ||
					dayDiff < 30 && messages.weeks(Math.ceil(dayDiff / 7)) ||
					dayDiff < 32 && messages.month ||
					dayDiff < 363 && messages.months(Math.ceil(dayDiff / 31)) ||
					dayDiff <= 380 && messages.year ||
					dayDiff > 380 && messages.years(Math.ceil(dayDiff / 365));
		}

	};

	$.prettyDate.messages = {
		now: 'just now',
		minute: '1 minute ago',
		minutes: $.prettyDate.template('{0} minutes ago'),
		hour: '1 hour ago',
		hours: function(tgtTime) {
                    var tgtDate = new Date(tgtTime);
                    return tgtDate.toLocaleTimeString({hour: '2-digit', minute:'2-digit'});
                },
                    
                    //$.prettyDate.template('{0} hours ago'),
		yesterday: 'Yesterday',
		days: $.prettyDate.template('{0} days ago'),
		week: '1 week ago',
		weeks: $.prettyDate.template('{0} weeks ago'),
		month: '1 month ago',
		months: $.prettyDate.template('{0} months ago'),
		year: '1 year ago',
		years: $.prettyDate.template('{0} years ago')
	};

	/**
	 * @context {jQuery}
	 * @param {Object} options
	 *  - {number|false} interval Time in milliseconds between updates,
	 *      or set to false to disable auto updating interval.
	 *  - {string} attribute Name of attribute where the timestamp should
	 *     be accessed from.
	 *  - {Function} value Overrides 'attribute', a custom function to get the
	 *     timestamp. 'this' context is set to the HTMLElement.
	 */
	$.fn.prettyDate = function (options) {
		options = $.extend({
			interval: 10000,
			attribute: 'title',
			value: function () {
				return $(this).attr(options.attribute);
			}
		}, options);
		var elements = this;
		function format() {
			elements.each(function () {
				var date = $.prettyDate.format(options.value.apply(this));
				if (date && $(this).text() !== date) {
					$(this).text(date);
				}
			});
		}
		format();
		if (options.interval) {
			setInterval(format, options.interval);
		}
		return this;
	};

}(jQuery));
;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function($) {
    /**
     * Private constants.
     */
    var CONTENT_CLASS_MOBILE = "ui-datagrid-content ui-widget-content hx-scroller-nozoom mh-layout-parent-height";
    var EMPTY_CONTENT_CLASS = "ui-datagrid-content ui-datagrid-content-empty ui-widget-content mh-layout-parent-height";
    var TABLE_CLASS = "ui-datagrid-data";
    var TABLE_ROW_CLASS = "ui-datagrid-row";
    var TABLE_COLUMN_CLASS = "ui-datagrid-column";
    
    $.widget("helix.helixDatagrid", {        
        
        options: {
            /**
             * Number of rows/cols in the datagrid. Specify as either an integral value or
             * a CSV string with at least 2 comma-separated values. The first is the
             * number of rows on a phone, the second a phablet, and the (optional)
             * third a tablet. If the third dimension is not specified then tablets and
             * phablets will use the same dimensions.
             */
            rows: 3,
            cols: 3,
            
            /**
             * String indicating the structure of the paginator. The default is
             * {PreviousPageLink} {CurrentPageReport} {NextPageLink}, which has
             * a left arrow link, the current page number (e.g., 1 of 3) and a
             * right arrow link.
             */
            paginatorTemplate: '{PreviousPageLink} {CurrentPageReport} {NextPageLink}',
            
            /**
             * The itemList is either an array of items to display in the grid or a 
             * QueryCollection. This is often null on initial load, and may be
             * specified on a subsequent refresh call.
             */
            itemList : null,
            
            /**
             * The renderer is a function used to render a single element in the
             * grid. This callback is executed on each element each time the
             * datagrid is refreshed. The cellDOM parameter is the parent of the
             * cell's DOM. All rendered elements should be appended to cellDOM. dataElem
             * is the current cell's data item, obtained from the itemList. stringsArray
             * is a list of strings supplied as configuration, which is used to
             * integrate with a framework like JSF's internationalization features.
             */
            renderer: function(cellDOM, dataElem, stringsArray) {
                
            },
            
            /**
             * Context menu that appears on either tap-hold (for touch devices)
             * or double click on the grid container itself. This is a different
             * menu from the context menu that can be attached to each individual
             * grid item. This should be a standard jQuery Mobile popup menu.
             */
            defaultContextMenu: null,
            
            /**
             * Context menu that is attached to individual grid elements. This
             * should be a Link SDK contextMenu component.
             */
            itemContextMenu: null,
            
            /**
             * Message to display in the grid body if the grid is empty.
             */
            emptyMessage: 'There are no items to display.',
            
            /**
             * Comma-separated list of strings which are passed through to the
             * grid item renderer. This list is generally used for internationalization.
             * If a CSV list is specified, it is parsed into an array of strings
             * before being passed to a renderer.
             */
            strings: '',
            
            /**
             * JavaScript expression that dictates if this component is rendered.
             * When the expression is true, the component is rendered. When either
             * undefined or otherwise evaluating to false the component is not
             * rendered.
             */
            condition: true
        },

        _create: function() {
            // Private variables.
            this.currentPage = 0;

            if (typeof this.options.rows === 'string') {
                this.options.rows = this._getDimensionForDeviceType(this.options.rows);
            }
            if (typeof this.options.cols === 'string') {
                this.options.cols = this._getDimensionForDeviceType(this.options.cols);
            }
            this.itemsPerPage = (this.options.rows * this.options.cols);
            this.id = this.element.attr('id');
            if (!this.id) {
                this.id = Helix.Utils.getUniqueID();
            }
            this.contentId = this.id + '_content';
            this.paginatorId = this.id + '_paginator';
            this.list = this.options.itemList;
            this.renderer = this.options.renderer;
            this.defaultContextMenu = this.options.defaultContextMenu;
            this.itemContextMenu = this.options.itemContextMenu;
            this.emptyMessage = this.options.emptyMessage;
            if (this.options.strings) {
                this.strings = this.options.strings.split(",");            
            }
            if (Helix.hasTouch) {
                this.contextEvent = 'taphold';
            } else {
                this.contextEvent = 'contextmenu';
            }
            
            this.parent = this.element;
            this.refresh(this.list, this.options.condition);
            this._setupEvents();
        },
    
        /**
         * Render the grid using the list of items supplied as the first parameter.
         * Condition is a dynamic, JavaScript expression that dictates if this
         * component is rendered at all. oncomplete is called when rendering is
         * done. oncomplete accepts a single argument, the number of items in
         * the grid.
         */
        refresh: function(list, condition, oncomplete) {
            if (!oncomplete && condition && typeof(condition) === 'function') {
                oncomplete = condition;
                condition = true;
            }
        
            this.list = list;
            if ((condition !== undefined) &&
                !condition) {
                /* The condition is false. Remove this entirely from the DOM. */
                $(this.parent).hide();
                return;
            } else {
                $(this.parent).show();
            }
        
            var _self = this;
            var refreshDone = function() {
                /* Create the scroller on the content container. */
                //Helix.Layout.addScrollers(_self.contentContainer);
                
                /* Attach the context menu to the grid header. */
                if (_self.defaultContextMenu) {
                    var cMenu = _self.defaultContextMenu;
                    $(_self.parent).on(_self.contextEvent, function(event) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        $(PrimeFaces.escapeClientId(cMenu)).popup( "open" );
                    });
                } 
                if (oncomplete) {
                    oncomplete(_self.itemCount);
                }
            };
            if ($.isArray(_self.list)) {
                /* Array. */
                _self.itemCount = _self.list.length;
                _self._refreshPaginatorContainer(_self.list.length);
                _self._refreshData(_self.list.length, refreshDone);
            } else if (_self.list && _self.list.forEach) {
                /* Query collection. */
                _self.list.count(function(ct) {
                    _self.itemCount = ct;
                    _self._refreshPaginatorContainer(ct);
                    _self._refreshData(ct, refreshDone);
                })
            } else {
                _self._refreshPaginatorContainer(0);
                _self._refreshData(0, refreshDone);
            }
        },
    
        _refreshPaginatorContainer: function(nElems) {
            var paginatorContainer = $(PrimeFaces.escapeClientId(this.paginatorId));
            if (paginatorContainer.length == 0) {
                paginatorContainer = $('<div />').attr({
                        'id' : this.paginatorId,
                        'class': Helix.Utils.paginator.PAGINATOR_TOP_CONTAINER_CLASS
                    }).appendTo($(this.parent));
            } else {
                // Clear out all children of the paginator so that we can refresh it.
                $(paginatorContainer).empty();
            }
            var parent = this;
            $.each(this.options.paginatorTemplate.split(" "), function(idx, obj) {
                Helix.Utils.paginator.render(obj, paginatorContainer, {
                    'page' : parent.currentPage,
                    'totalItems' : nElems,
                    'itemsPerPage' : parent.itemsPerPage,
                    'nextPage' : parent.nextPage,
                    'prevPage' : parent.prevPage,
                    'owner' : parent
                });
            });
        },
    
        _createRefreshState: function(nElems) {
            var startElem = this.currentPage * this.itemsPerPage;
            var endElem = startElem + this.itemsPerPage;
            if (endElem > nElems) {
                endElem = nElems;
            }

            return {
                'curRow' : null,
                'parent' : this,
                'startElem' : startElem,
                'endElem' : endElem
            };
        },
    
        _createOneElement: function(tableBody, curState, idx, elem) {
            // Determine if we need to start a new row.
            if (!curState.curRow || (idx % curState.parent.options.cols) == 0) {
                curState.curRow = $('<tr />').attr({
                        'class' : TABLE_ROW_CLASS
                    })
                .appendTo(tableBody);
            }

            var _self = this;
            var nxtCol = $('<td />').attr({
                'class' : TABLE_COLUMN_CLASS,
                'data-index' : curState.startElem + idx
            }).appendTo(curState.curRow);
            if (curState.parent.itemContextMenu) {
                $(nxtCol).on(_self.contextEvent, function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    // Select the item that is being tap-held/double clicked.
                    curState.parent.selectedIndex = $(event.target).closest("td").attr('data-index');
                    curState.parent.selected = elem;

                    // Open the context menu.
                    _self.itemContextMenu.open({ 
                        positionTo: event.target,
                        thisArg: _self
                    });
                });
            }
            /* Must be called *AFTER* we attach the tap hold event so that any events attached
             * to nxtCol in the renderer can be stopped when we want to display the context
             * menu. */
            curState.parent.renderer(_self, nxtCol, elem, curState.parent.strings);
        },
    
        _refreshData: function(nElems, oncomplete) {
            var _self = this;
            var gridBody, tableBody, curState;        

            var contentContainer = _self.contentContainer = $(PrimeFaces.escapeClientId(this.contentId));
            if (contentContainer.length == 0) {
                contentContainer = $('<div />').attr({
                    'id' : this.contentId
                }).append($('<div/>')).appendTo(this.parent);
            } else {
                $(contentContainer).children('div').empty();
            }
            var contentParent = $(contentContainer).children('div');
            var doneFn = function(b) {
                $(contentParent).append(b);
                oncomplete();
            };
            if (nElems > 0) {
                if ($.isArray(this.list)) {
                    $(contentContainer).attr('class', CONTENT_CLASS_MOBILE);

                    /* Generate the actual data for the current page. */
                    tableBody = $('<tbody />');
                    curState = this._createRefreshState(this.list.length);
                    $.each(this.list.slice(curState.startElem, curState.endElem), function(idx, elem) {
                        _self._createOneElement(tableBody, curState, idx, elem);
                    });
                    gridBody = $('<table />').attr({
                                'class' : TABLE_CLASS
                                }).append(tableBody);
                    doneFn(gridBody);
                } else if (this.list.forEach) {
                    $(contentContainer).attr('class', CONTENT_CLASS_MOBILE);

                    /* Generate the actual data for the current page. */
                    tableBody = $('<tbody />');
                    var _list = this.list;

                    var _idx = 0;
                    curState = _self._createRefreshState(nElems);
                    _list.skip(curState.startElem);
                    _list.limit(curState.endElem - curState.startElem);
                    _list.each(function(elem) {
                        _self._createOneElement(tableBody, curState, _idx, elem);
                        ++_idx;
                    }, 
                    function() {

                    },
                    function() {
                        gridBody = $('<table />').attr({
                                'class' : TABLE_CLASS
                                }).append(tableBody);                    
                        doneFn(gridBody);
                    });
                } else {
                    gridBody = "Invalid item list type.";
                    doneFn(gridBody);
                }
            } else {
                $(contentContainer).attr('class', EMPTY_CONTENT_CLASS);
                gridBody = this.options.emptyMessage;
                doneFn(gridBody);
            }
        },
    
        nextPage: function(nPages, oncomplete) {
            if (this.currentPage < (nPages - 1)) {
                this.currentPage++;
                this.refresh(this.list, this.condition, oncomplete);
            }
        },
        prevPage : function(oncomplete) {
            if (this.currentPage > 0) {
                this.currentPage--;
                this.refresh(this.list, this.condition, oncomplete);
            }
        },
        _setupEvents: function() {
            if (Helix.hasTouch) {
                $(this.contentId).on('swiperight', function() {
                    this.prevPage();
                });
                $(this.contentId).on('swipeleft', function() {
                    this.prevPage();
                });
            }
        },
        _getDimensionForDeviceType: function(dimensionString) {
            var rowsOptions = dimensionString.split(",");
            if (Helix.deviceType == 'phone') {
                return rowsOptions[0];
            } else if (Helix.deviceType == 'phablet') {
                return rowsOptions[1];
            } else {
                return rowsOptions[rowsOptions.length - 1];
            }
        },
        refreshScroller: function() {
            if (this.contentContainer) {
                //Helix.Layout.updateScrollers(this.contentContainer);
            }
        },
        destroy: function() {
            if (this.contentContainer) {
                //Helix.Layout.cleanupScrollers(this.parent);
            }
        },
        clear: function() {
            if (this.contentContainer) {
                $(this.contentContainer).children('div').empty();
            }
        },
        closeItemContextMenu: function() {
            this.options.itemContextMenu.close();
        },
        bindClick : function(target, fn) {
            var _self = this;
            $(target).on(Helix.clickEvent, function(ev) {
                if (_self.options.itemContextMenu && _self.options.itemContextMenu.active) {
                    return false;
                }
                fn(ev);
                return false;
            });
        },
        getSelected: function() {
            return this.selected;
        }
    });
}( jQuery ));;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Mobile Helix PanelGroup Widget
 */
(function($) {
    
    $.widget("helix.helixPanelgroup", {
        
        options: {
            /**
             * The renderer is a function used to render a single element in the
             * panel group. This callback is executed on each element each time the
             * panel group is refreshed. The cellDOM parameter is the parent of the
             * cell's DOM. All rendered elements should be appended to cellDOM. dataElem
             * is the current cell's data item, obtained from the itemList. stringsArray
             * is a list of strings supplied as configuration, which is used to
             * integrate with a framework like JSF's internationalization features.
             */
            renderer: function(cellDOM, dataElem, stringsArray) {
                
            },
            
            /**
             * The itemList is either an array of items to display in the grid or a 
             * QueryCollection. This is often null on initial load, and may be
             * specified on a subsequent refresh call.
             */
            itemList: null,
            
            /**
             * Comma-separated list of strings which are passed through to the
             * grid item renderer. This list is generally used for internationalization.
             * If a CSV list is specified, it is parsed into an array of strings
             * before being passed to a renderer.
             */
            strings: '',
            
            /**
             * JavaScript expression that dictates if this component is rendered.
             * When the expression is true, the component is rendered. When either
             * undefined or otherwise evaluating to false the component is not
             * rendered.
             */
            condition: true
        },
    
        _create: function() {
            this._parent = this.element;
            if (this.options.strings) {
                this._strings = this.options.strings.split(",");            
            } else {
                this._strings = [];
            }

            if (this.options.itemList) {
                this.refresh(this.options.itemList,this.options.condition);
            }
        },
        refresh: function(list,condition,oncomplete) {
            this._renderer = this.options.renderer;
            this._list = list;
            this._parent.empty();
            if ((condition !== undefined) &&
                (!condition)) {
                /* The condition is false. Hide this in the DOM. */
                this._parent.hide();
                if (oncomplete) {
                    oncomplete();
                }
                return;
            } else {
                this._parent.show();
                var _self = this;
                if ($.isArray(_self._list)) {
                    $.each(_self._list, function(idx, elem) {
                        var parentDiv = $('<div />').appendTo(_self._parent);
                        _self._renderer(parentDiv, elem, _self._strings);
                    });
                    if (oncomplete) {
                        oncomplete();
                    }
                } else if (_self._list.forEach) {
                    /* This is a QueryCollection. */
                    _self._list.forEach(function(elem) {
                        var parentDiv = $('<div />').appendTo(_self._parent);
                        _self._renderer(parentDiv, elem, _self._strings);
                    },
                    function() {

                    },
                    function(ct) {
                        if (oncomplete) {
                            oncomplete();
                        }
                    });
                } else {
                    var parentDiv = $('<div />').appendTo(_self._parent);
                    _self._renderer(parentDiv, _self._list, _self._strings);
                    if (oncomplete) {
                        oncomplete();
                    }
                }
            }
        }
    
    });
}( jQuery ));;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function($) {
    
    $.widget("helix.helixDatalist", {
        options: {
            /**
             * Determines if the list has the jQuery Mobile 'inset' style.
             */
            inset: true,
            
            /**
             * Determines if the list contents should scroll using native-style
             * scrolling.
             */
            scroll: true,
            
            /**
             * Text to display at the top of the list. Shows up as a divider but it
             * is not associated with the grouping mechanism in any way.
             */
            headerText: null,
            
            /**
             * Determines if the list is grouped. Groups are divided using a 
             * jQuery Mobile list divider. If the list is grouped, then the groupName
             * and groupMembers options must be provided.
             */
            grouped: false,
            
            /**
             * For grouped lists, apply this function to each row to get the group
             * name of that row. The query collection supplied to this object is
             * the collection of groups, not group rows.
             */
            groupName: null,
            
            /**
             * For grouped lists, apply this function to each group row to get the
             * query collection of group members.
             */
            groupMembers: null,
            
            /**
             * Style class applied to each divider row.
             */
            dividerStyleClass: null,
            
            /**
             * Style class applied to each non-divider row.
             */
            rowStyleClass: null,
            
            /**
             * JavaScript condition that indicates if this data list is currently
             * visible.
             */
            condition: true,
            
            /**
             * Message to display in the list if the entire list is empty.
             */
            emptyMessage: "There are no items to display.",
            
            /**
             * Message to display in the list if a group has no rows.
             */
            emptyGroupMessage: "There are no items to display in this group.",
            
            /**
             * Message to display when a search returns no results.
             */
            emptySearchMessage: "The search did not return any results from the local database.",
            
            /**
             * Action to perform if the user taps/clicks on a list item.
             */
            selectAction: null,
            
            /**
             * Action to perform if the user swipes an item left.
             */
            swipeLeftAction: null,
            
            /**
             * Action to perform if the user swipes an item right.
             */
            swipeRightAction: null,
            
            /**
             * Context menu to display if the user tap-holds (for touch devices)
             * or double clicks (for non-touch devices) on a list item. When 
             * both this option and holdAction are specified, this option takes
             * precedence. Specify either a jQuery object or a selector to uniquely
             * identify the jQuery Mobile popup to open.
             */
            itemContextMenu: null,
            
            /**
             * Filter to apply to determine whether or not a particular item has
             * the context menu attached to it. By default, all list items have the
             * context menu attached. If a function returning a boolean value is 
             * specified for this option, then when that function returns true
             * the item context menu is attached, and when the function returns false
             * it is not. This function accepts a single argument, which is the row
             * record from the itemList specified as an option at create time or in a
             * call to refreshList.
             */
            itemContextMenuFilter: null,
            
            /**
             * Action to perform if the user tap-holds (for touch devices) or 
             * double clicks (for non-touch devices) on a list item.
             */
            holdAction: null,
            
            /**
             * Function that accepts a query collection and the contents of
             * the search box and returns a filtered query collection. If null,
             * no search box is shown.
             */
            indexedSearch: null,
            
            /**
             * List of fields to allow the user to selectively sort by. This option
             * is specified as an object mapping field names for rows in the
             * underlying QueryCollection object to a user-friendly name that is
             * displayed in the sort popup menu. e.g.,
             *     {
             *          'firstName' : 'First Name',
             *          'lastName'  : 'Last Name'
             *     }
             */
            sorts: null,
            
            /**
             * Comma-delimited, ordered list of fields to sort by.
             */
            sortBy: null,
            
            /**
             * Comma-delimited, ordered list of sort directions. Each direction is
             * either ASCENDING or DESCENDING. If this list is shorter than the
             * sortBy list, then the final value in this list will apply to all
             * non-matching fields in the sortBy list.
             */
            sortOrder: "ASCENDING",
            
            
            /**
             * By default we do not sort case sensitive.
             */
            sortCaseSensitive: false,
            
            /**
             * Callback to execute when the sort order changes. The first argument
             * is the new sort field. The second is either ASCENDING or DESCENDING
             * to specify the new sort order. This callback is invoked before
             * the list is refreshed.
             */
            onSortChange: null,
            
            /**
             * A common behavior is to have a visual cue that changes when the sort
             * is ascending vs. descending. This component implements this behavior
             * by automatically toggling between alternative buttons when the 
             * direction changes. This behavior is enabled by providing an object
             * for the sortButtons option that has an ascending and descending field,
             * each of whose value is a selector to find the appropriate button that
             * should be turned on/off. By default this behavior is disabled.
             */
            sortButtons : { },
            
            /**
             * List of fields to use as "this filters." This filters allow the user
             * to filter the list to the value of the currently selected item. Since
             * selecting an item often navigates away from the screen displaying the list,
             * it is recommended that the "this filters" list appears on tap-hold, using the
             * itemContextMenu. These fields are specified as a map similar to the sorts field.
             * The map's keys are field names which are present in each object in the list. The
             * map's values are display strings used to present the filter options to the user
             * in a popup list. Unlike sorts and global filters, no button is rendered to display
             * this filters. Instead, call displayFilterMenu from your own context menus supplied
             * as a selector value to the itemContextMenu option. NOTE, that because nested popups
             * are NOT permitted in jQuery Mobile, you must call popup("close") on the context
             * menu before calling displayFilterMenu! The argument to displayFilterMenu should
             * be the event target (i.e. what was clicked to pop up this menu).
             */
            thisFilters: null,
            
            /**
             * Callback that is invoked to do the actual filtering for this filters. 
             * The input to this callback is the current query collection for all items in
             * the list, the field name from the filters list, and the
             * currently selected row. E.g.,
             *     doThisFilter(allItemsCollection, fieldName, selectedRow)
             * The callback should return a filtered query collection object.
             */
            doThisFilter: null,
            
            /**
             * Map of global filters, which allow the user to narrow down the list to a particular
             * value for a field present in each object in the list. Global filters, if present,
             * are also displayed in a popup menu. That menu is opened via a sort button that is
             * placed next to the sort button and search box. Each global filter is represented as
             * an object, with fields 'display', for a string used to describe the filter in the
             * popup menu, 'values', for a list of potential values for the field, and 'valueNames'
             * for a list of descriptive names corresponding to those values. The globalFilters field
             * itself is, much like thisFilters, a map from field names to global filter objects.
             */
            globalFilters: null,
            
            /**
             * Callback that is invoked to do the actual filtering for global filters. The 
             * input to this callback is the current query collection for all items in
             * the list, the field name from the filters list, and the
             * currently selected row. E.g.,
             *     doThisFilter(allItemsCollection, fieldName, selectedVal)
             * The callback should return a filtered query collection object.
             */
            doGlobalFilter: null,
            
            /**
             * List of data to display in the list. Must be a PersistenceJS
             * QueryCollection object.
             */
            itemList: null,
            
            /**
             * Specify the icon for a split icon layout if one is going to be
             * used for the list items. See jQuery Mobile documentation of the
             * listview plugin for further detail on what a split icon layout
             * means.
             */
            splitIcon: null,
            
            /**
             * Specify the theme for the split button. This item is ignored unless
             * splitIcon is non-null.
             */
            splitTheme: null,
            
            /**
             * Function used to render a single data row (i.e. a non-group-name
             * row). If a list row should be skipped the renderer should return
             * false. Otherwise, to include a row in the list it must return
             * true. Options to this function are the parent div of the row markup,
             * a reference to this list object, the row data, the row index, and
             * the array of strings supplied with the strings option. E.g.,:
             *      renderRow(curRowParent, list, rowData, rowIndex, strings)
             */
            rowRenderer: null,
            
            /**
             * When supplied, a function to call on pull-to-refresh. When null,
             * pull to refresh is disabled.
             */
            pullToRefresh: null,
            
            /**
             * Comma-separated list of localizable strings. These can be supplied
             * when a server generates this markup using a server-side localization
             * technique. These strings are separated into an array and then passed
             * through to the rowRenderer function.
             */
            strings: null,
            
            /*
             * If true, auto dividers will be used
             */
            autodividers: false,
            
            /*
             * Function used to generate the title of each section created by
             * the auto-divider based on the content of the provided cell.
             */
            autodividersSelectorCallback: null,
            
            /*
             * Display sort buttons or not
             */
            showButtons: true,
            
            /*
             * If true, shows an arrow icon on the right hand side of each list item
             */
            showDataIcon: true,

            /*
             * Number of rows to display in a single view of the list. The list automatically
             * paginates as the user scrolls.
             */
            itemsPerPage: 50
        },
    
        _create: function() {
            var _self = this;
            this.$wrapper = this.element;
            if (this.options.scroll) {
                this.$wrapper.addClass('pm-layout-full-height');
            }
            
            this.$page = this.$wrapper.closest('.ui-page');
            var parentId = this.$wrapper.parent().attr('id');
            if (!parentId) {
                parentId = Helix.Utils.getUniqueID();
                this.$wrapper.parent().attr('id', parentId);
            }
            
            this.$searchSortDiv = $('<div/>')
                .appendTo(this.$wrapper)
                .addClass('hx-full-width')
                .attr('id', parentId + '_list_header')
                .hide();
            this._searchSortDirty = true;
            
            /**
             * Append the hook div if we have pull to refresh setup.
             */
            this.$hookDiv = null;
            if (this.options.pullToRefresh) {
                this.$hookDiv = $('<div/>').appendTo(this.$wrapper);
            }
                        
            /**
             * Append the data list.
             */
            var listWrapper = this.$listWrapper = $('<div/>').appendTo(this.$wrapper);
            this.$parent = $('<ul/>').attr({
                'data-role' : 'listview',
                'class' : 'hx-listview'
            }).appendTo(listWrapper);
            if (this.options.inset) {
                this.$parent.attr('data-inset', true);
            }
            
            /**
             * Split icons, if appropriate.
             */
            if (this.options.splitIcon) {
                this.$parent.attr('data-split-icon', this.options.splitIcon);
            }
            if (this.options.splitTheme) {
                this.$parent.attr('data-split-theme', this.options.splitTheme);
            }

            if (this.options.showDataIcon === false) {
                this.showDataIcon = false;
                this.$parent.attr('data-icon', false);
            }

            var sb = true;
            
            if (this.options.showButtons === false) {
                sb = false;
            }
            
            this.showButtons = sb;
            var ad = this.options.autodividers;
            if (!ad) {
                ad = false;
            } else if (Helix.Utils.isString(ad) && (ad.toLowerCase() == 'false')) {
                ad = false;
            }
            var ads = function(elt) { 
                    var callback = _self.options.autodividersSelectorCallback;

                    if (callback && $(elt).is(':visible')) {
                       return callback(elt, _self.displayList, _self._currentSort);
                    } 
                    
                    return null;
                };

            this.$parent.listview({
                autodividers: ad,
                autodividersSelector: ads
            });
            
            if (this.$hookDiv) {
                this.$hookDiv.hook({
                    reloadPage: false,
                    scrollTarget: listWrapper,
                    reloadEl: function() {
                        if (!_self.refreshInProgress) {
                            _self.options.pullToRefresh.call(this);
                            _self._clearGlobalFilterMenu();
                        }
                    }
                });            
            }

            // Pagination setup.
            this._resetPaging();

            // Other globals.
            this.refreshInProgress = false;
            this.isLoaded = false;
            
            // Set context menu event to taphold for touch devices, dblclick for none-touch.
            //this.contextEvent = 'taphold';
            this.contextEvent = Helix.contextEvent;
            this.tapEvent = Helix.clickEvent;
        
            // Default sort.
            this._currentSort = this.options.sortBy;
            this._currentSortOrder = this.options.sortOrder.toUpperCase();
            this._currentSortCase = '';
            this._updateSortButtons();
        
            if (this.options.strings) {
                this.strings = this.options.strings.split(",");            
            }

            this.refreshList(this.options.itemList,this.options.condition,null,function() {
                
            });
        },
        
        _getSortsFromOptions: function(sortFilterOptions) {
            if (sortFilterOptions.__hx_sorts) {
                return sortFilterOptions.__hx_sorts;
            }
            
            return sortFilterOptions.sorts;
        },
        
        _getThisFiltersFromOptions: function(sortFilterOptions) {
            if (sortFilterOptions.__hx_filters) {
                return sortFilterOptions.__hx_filters;
            }
            
            return sortFilterOptions.thisFilters;
        },
        
        _getGlobalFiltersFromOptions: function(sortFilterOptions) {
            if (sortFilterOptions.__hx_global_filters) {
                return sortFilterOptions.__hx_global_filters;
            }
            
            return sortFilterOptions.globalFilters;
        },
        
        _handleEmpty: function(msg) {
            var emptyLI = $(this.$parent).find('li[data-role="empty-message"]');
            if (this.nElems == 0) {                    
                if (emptyLI.length) {
                    $(emptyLI).show();
                } else if (msg) {
                    this.$parent.append($('<li />')
                        .attr('data-role', 'empty-message')
                        .append(msg));                        
                }
            } else if (emptyLI.length) {
                $(emptyLI).hide();
            }
        },
        
        /**
         * sortFilterOptions can either be a Mobile Helix enhanced PersistenceJS
         * schema (with the __hx_* fields) or a map with 3 fields - sorts, thisFilters,
         * and globalFilters with the format described in the options documentation.
         */
        refreshList: function(list,condition,sortFilterOptions,oncomplete,resetSelection) {
            var _self = this;
            
            /* itemList is the current query collection. Display list is an array
             * of the currently displayed items.
             */
            _self.originalList = _self.unfilteredList = _self.itemList = list;
        
            /* Hide the list while we are manipulating it. */
            if ((condition !== undefined) &&
                !condition) {
                /* The condition is false. Remove this entirely from the DOM. */    
                _self.$wrapper.hide();
                return;
            }   
            
            /* Create the sort popup */
            var sorts = null;
            if (!sortFilterOptions) {
                sorts = _self.options.sorts;
            } else {
                sorts = _self._getSortsFromOptions(sortFilterOptions);
            }            
            if (sorts) {
                // If there is a default sort that is not returned in the list of sorts,
                // add it. (EG. It can happen if the default sort uses a combination
                // of fields).
                if ((this.options.sortBy) && (sorts[this.options.sortBy] === undefined)) {
                   sorts[this.options.sortBy] = {
                        display : "Default",
                        direction : this.options.sortOrder.toUpperCase(),
                        usecase : this.options.sortCaseSensitive
                   };
                }
                
                _self._refreshSortContainer(sorts);
            }
            
            var thisFilters = null;
            if (!sortFilterOptions) {
                thisFilters = _self.options.thisFilters;
            } else {
                thisFilters = _self._getThisFiltersFromOptions(sortFilterOptions);
            }
            if (thisFilters && _self.options.doThisFilter) {
                _self._refreshFilterContainer(thisFilters);
            }
            
            var globalFilters = null;
            if (!sortFilterOptions) {
                globalFilters = _self.options.globalFilters;
            } else {
                globalFilters = _self._getGlobalFiltersFromOptions(sortFilterOptions);
            }
            if (globalFilters && _self.options.doGlobalFilter) {
                _self._refreshGlobalFilterContainer(globalFilters);
            }
            
            /* Generate the actual data for the current page. */
            _self._prependSearchBox();
            _self._updateSortButtons();
            
            /**
             * Display from the beginning of the list.
             */
            _self._resetPaging();
            _self._refreshData(function() {
                _self.$parent.listview( "refresh" );
                
                /**
                 * Reset the selection if directed to do so.
                 */
                if (resetSelection) {
                    _self.selected = null;
                    _self.selectItem(true);
                }
                
                _self.$wrapper.show();
                
                /* It seems that attaching the scrolling classes after showing the list
                 * is required to make scrolling work properly on iOS.
                 */
                if (_self.options.scroll) {
                    _self.$listWrapper.removeClass('hx-scroller-nozoom');
                    _self.$listWrapper.addClass('hx-scroller-nozoom');
                    _self.$listWrapper.addClass('mh-layout-parent-height');
                    _self.$listWrapper.scroll(function(ev) {
                        /*if (_self.refreshInProgress) {
                            return true;
                        }*/
                        if (_self.refreshInProgress || _self.scrollCalculationInProgress) {
                            ev.stopImmediatePropagation();
                            return false;
                        }
                        
                        var scrollPos = _self.$listWrapper.scrollTop();
                        var listHeight = _self.$parent.height();
                        var firstShowing;

                        if (_self.rescrollInProgress) {
                            // This occurs when the scroll handler is triggered by the scrollTop
                            // call in datalist.js. Because there is a delay between calling scrollTop
                            // and the actual scroll (browser dependent), the rescrollInProgress flag
                            // does not help prevent us undoing the scroll we just did. We catch that
                            // case here. Return true to allow the scroll to happen.
                            _self._lastScrollPos = scrollPos;
                            _self.rescrollInProgress = false;
                            return true;
                        }

                        // We display a scrolling window of items. We always pull in
                        // page size * 2 items. If we are in the bottom half of the list
                        // we prepend more to the bottom of the list and remove from the
                        // top. If we are in the top half of the list we append to the end
                        // of the list and remove from the front.
                        var oldDataStart = _self._renderWindowStart, newDataStart;
                        var preRefreshScrollPosition = scrollPos;
                        if (_self._lastScrollPos > scrollPos &&
                            scrollPos < (listHeight * .25)) {
                            // Scroll is moving down and we are in the 1st third of the 
                            // list.
                            if (oldDataStart > 0) {
                                // SCROLLING UP
                                // Update the render window to the _itemsPerPage rows with the
                                // current set of visible rows as the last third of the list.
                                _self.scrollCalculationInProgress = true;
                                
                                // Snapshot what is currently at the top of the scroll window.
                                firstShowing = _self._captureTopLI(ev);
                                newDataStart = _self._updateRenderWindow(firstShowing, 0);
                                firstShowing += (oldDataStart - newDataStart);
                                _self._lastUpdateScroll = scrollPos;
                                
                                // Fetch another 50 rows prior to the data window start.
                                _self._refreshData(function() {
                                    // Scroll to the right spot so that the element the viewer was
                                    // viewing is still centered in the screen.                                    
                                    _self.$parent.listview( "refresh" );
                                    
                                    _self.scrollCalculationInProgress = false;
                                    _self._updateScrollPosition(ev, firstShowing, scrollPos, preRefreshScrollPosition);
                                });
                                _self._atDataTop = false;
                            }
                        } else if (_self._lastScrollPos < scrollPos &&
                                   scrollPos > (listHeight * .75)) {
                            // SCROLLING DOWN
                            // Update the render window to the _itemsPerPage rows centered
                            // around the current set of visible rows as the first third of the
                            // list.
                            if (!_self._atDataTop) {
                                firstShowing = _self._captureTopLI(ev);
                                newDataStart = _self._updateRenderWindow(firstShowing, 1);
                                firstShowing -= (newDataStart - oldDataStart);
                                _self._lastUpdateScroll = scrollPos;
                                
                                _self.scrollCalculationInProgress = true;
                                
                                // Scroll is moving up and we are in the top third of the list.
                                // Fetch another 50 rows prior to the data window start.
                                _self._refreshData(function() {
                                    // Scroll to the right spot so that the element the viewer was
                                    // viewing is still centered in the screen.
                                    _self.$parent.listview( "refresh" );
            
                                    _self.scrollCalculationInProgress = false;
                                    _self._updateScrollPosition(ev, firstShowing - 1, scrollPos, preRefreshScrollPosition);
                                }, true /* Do not recompute the qry collection */);
                            }
                        }
                        
                        // Record the last scroll position so that we can determine scroll 
                        // direction.
                        _self._lastScrollPos = scrollPos;
                        return true;
                    });
                }
                _self.$listWrapper.css('-webkit-overflow-scrolling', 'touch');
                _self.isLoaded = true;
                
                if (oncomplete) {
                    oncomplete(_self);
                    _self.isDirty = false;
                }
            });
        },
        
        /**
         * Helpers for infinite scroll.
         */
        _captureTopLI: function(ev) {
            this.scrollCalculationInProgress = true;
            var $curTop = this.$listWrapper.find('li').withinViewport({ 'container' : this.$listWrapper[0], 'sides' : 'top bottom' });
            this.scrollCalculationInProgress = false;
            return parseInt($($curTop[0]).attr('data-index'));
        },
        
        _updateScrollPosition: function(ev, topIndex, scrollPos, preRefreshScrollPosition) {
            // Figure out where the old top item has gone.
            var newTopPos = this.$parent.find('li[data-index="' + topIndex + '"]').position().top;
            var curScrollTop = $(this.$listWrapper).scrollTop();
            if (curScrollTop < 0) {
                curScrollTop = 0;
            }
            var scrollDelta = curScrollTop - preRefreshScrollPosition;
            var newScrollPos = scrollPos + newTopPos + scrollDelta;
            var wrapperHeight = $(this.$listWrapper).height();
            var listHeight = this.$parent.height();
            
            if (newScrollPos < 0) {
                newScrollPos = 0;
            } else if (newScrollPos > (listHeight - wrapperHeight)) {
                newScrollPos = listHeight - wrapperHeight;
            }
            
            this.rescrollInProgress = true;
            $(this.$listWrapper).scrollTop(newScrollPos);
        },
        
        /**
         * Called when the data in the list has changed, but the list structure itself
         * has not.
         */
        refreshData: function(list,condition,oncomplete) {
            var _self = this;
            
            /* itemList is the current query collection. Display list is an array
             * of the currently displayed items.
             */
            _self.originalList = _self.unfilteredList = _self.itemList = list;
        
            /* Hide the list while we are manipulating it. */
            if ((condition !== undefined) &&
                !condition) {
                /* The condition is false. Remove this entirely from the DOM. */    
                _self.$wrapper.hide();
                return;
            }
            
            _self._refreshData(function() {
                _self.$parent.listview( "refresh" );
                if (oncomplete) {
                    oncomplete(_self);
                    _self.isDirty = false;
                }
            });
        },
        
        _updateSortButtons: function() {
            if ('ascending' in this.options.sortButtons &&
                'descending' in this.options.sortButtons) {
                if (this._currentSortOrder.toUpperCase().indexOf("DESCENDING") == 0) {
                    // Show the descending button, reflecting the CURRENT order.
                    $(this.options.sortButtons.descending).show();
                    $(this.options.sortButtons.ascending).hide();
                } else {
                    $(this.options.sortButtons.ascending).show();                            
                    $(this.options.sortButtons.descending).hide();
                }
            }
        },
                        
        _refreshSortContainer: function(sorts) {
            var _self = this;
            
            /* See if the contents of the sorts has changed. */
            var newSortsJSON = JSON.stringify(sorts);
            if (_self._currentSortsJSON) {
                if (newSortsJSON === _self._currentSortsJSON) {
                    // No change.
                    return;
                }
            }
            _self._currentSortsJSON = newSortsJSON;
            /* Need to refresh the search/sort area. */
            _self._searchSortDirty = true;
            
            /* we are only called if sorts is non-null. */
            if (_self._sortContainer) {
                /* Remove the old context menu ... */
                _self._sortContainer.remove();
            }
            
            _self._sortContainer = $('<div/>').attr({
                'data-role' : 'popup',
                'id' : Helix.Utils.getUniqueID(),
                'data-theme' : 'a',
                'data-position-to' : 'origin',
                'data-history': 'false'
            }).appendTo(_self.$wrapper);
            var sortsList = $('<ul />').attr({ 
                'data-role' : 'listview',
                'data-inset' : 'true',
                'data-theme' : 'b'
            }).appendTo(_self._sortContainer);
            for (var sortFld in sorts) {
                var nxtSort = sorts[sortFld];
                if (nxtSort.display !== "[none]") {
                    var sortItem = $('<li />').append($('<a />').attr({ 
                        'href' : 'javascript:void(0)',
                        'data-field': sortFld,
                        'data-direction' : nxtSort.direction,
                        'data-case' : nxtSort.usecase
                    }).append(nxtSort.display));
                    $(sortsList).append(sortItem);
                    
                    /* Highlight the current sort. */
                    if (sortFld === _self._currentSort) {
                        $(sortItem).addClass('hx-current-sort');
                    }
                    
                    /* Do the actual sorting ... */
                    $(sortItem).on(_self.tapEvent, function(evt) {
                        evt.stopImmediatePropagation();                       
                        var newSortField = $(evt.target).attr('data-field');
                        var defDirection = $(evt.target).attr('data-direction');
                        var caseSensitive = $(evt.target).attr('data-case');
                        
                        var found = false;
                        if (_self._currentSort) {
                            var curSortFields = _self._currentSort.split(',');
                            var curSortOrders = _self._currentSortOrder.split(',');
                            
                            for (var i = 0; i < curSortFields.length; ++i) {
                                var sortFld = curSortFields[i];
                                var sortOrder = null;
                                if (i == curSortOrders.length) {
                                    curSortOrders.push(curSortOrders[i - 1]);
                                }
                                sortOrder = curSortOrders[i];
                                
                                if (sortFld == newSortField) {
                                    // Reverse the direction.
                                    if (sortOrder.toUpperCase() == "ASCENDING") {
                                        curSortOrders[i] = "DESCENDING";
                                    } else {
                                        curSortOrders[i] = "ASCENDING";
                                    }
                                    found = true;
                                    break;
                                }
                            }
                            if (found) {
                                _self._currentSortOrder = curSortOrders.join(',');
                            }
                        }
                        // We don't append sort orders - we just reset the sort order to the
                        // new field.
                        if (!found) {
                            _self._currentSort = newSortField;
                            _self._currentSortOrder = defDirection; 
                            _self._currentSortCase = caseSensitive;
                        }
                        
                        if (_self.nElems == 0) {
                            /* Nothing to do. */
                            return false;
                        }
                        if (_self.options.onSortChange) {
                            var updatedSorts = _self.options.onSortChange(_self._currentSort, _self._currentSortOrder, newSortField);
                            if (updatedSorts) {
                                _self._currentSort = (updatedSorts.sort ? updatedSorts.sort : _self._currentSort);
                                _self._currentSortOrder = (updatedSorts.sortOrder ? updatedSorts.sortOrder : _self._currentSortOrder);
                                _self._currentSortCase = (updatedSorts.sortCase ? updatedSorts.sortCase : _self._currentSortCase);
                            }
                        }
                        _self._updateSortButtons();
                        
                        // Change the li for this sort field so that we can see it is the current sort field.
                        $(sortsList).find('li').removeClass('hx-current-sort');
                        $(this).addClass('hx-current-sort');

                        // Display from the beginning of the list.
                        _self._resetPaging();
                        _self._refreshData(function() {
                            _self.$parent.listview( "refresh" );
                            _self.$listWrapper.scrollTop(0);
                        });
                        $(_self._sortContainer).popup("close");
                        return false;
                    });
                }
            }
            sortsList.listview();
            _self._sortContainer.popup();            
        },
        
        _refreshFilterContainer: function(filters) {
            var _self = this;
            
            /* See if the contents of the filters has changed. */
            var newFiltersJSON = JSON.stringify(filters);
            if (_self._currentFiltersJSON) {
                if (newFiltersJSON === _self._currentFiltersJSON) {
                    // No change.
                    return;
                }
            }
            _self._currentFiltersJSON = newFiltersJSON;
            
            /* we are only called if filters is non-null. */
            if (_self._filterContainer) {
                /* Remove the old filter menu ... */
                _self._filterContainer.remove();
            }
            
            _self._filterContainer = $('<div/>').appendTo(_self.$wrapper);
            
            var contextMenuItems = [];
            for (var filterFld in filters) {
                if (filters[filterFld] !== "[none]") {
                    var filterItem = $('<li />').append($('<a />').attr({ 
                        'href' : 'javascript:void(0)',
                        'data-field': filterFld
                    }).append());
                    contextMenuItems.push({
                        'display': filters[filterFld],
                        'data': filterFld,
                        'action': function(newFilterField) {
                            _self.itemList = _self.options.doThisFilter(_self.itemList, newFilterField, _self.selected);
                            _self._resetPaging();
                            _self._refreshData(function() {
                                _self.$parent.listview( "refresh" );
                                _self.$listWrapper.scrollTop(0);
                            });
                            _self._filterContextMenu.close();
                        }
                    });
                }
            }
                    
            /* Always have a "Clear" option. */
            contextMenuItems.push({
                'display' : 'Clear',
                'action' : function() {
                    _self.itemList = _self.unfilteredList;
                    _self._resetPaging();
                    _self._refreshData(function() {
                        _self.$parent.listview( "refresh" );
                        _self.$listWrapper.scrollTop(0);
                    });
                    _self._filterContextMenu.close();
                }
            });
            _self._filterContextMenu = $(_self._filterContainer).helixContextMenu({
                items: contextMenuItems
            }).data('helix-helixContextMenu');
        },
        
        _normalizeFilterValue: function(val) {
            var intValue = parseInt(val);
            if (intValue === NaN) {
                return val;
            } else {
                return intValue;
            }
        },
        
        _resetGlobalFilters: function(itemList) {
            var curCollection = (itemList ? itemList : this.unfilteredList);
            for (var filteredFld in this._filterMap) {
                curCollection = this.options.doGlobalFilter(curCollection, filteredFld, this._filterMap[filteredFld]);
            }
            return curCollection;
        },
        
        _doGlobalFilter: function(gFilterField, gFilterValue) {
            var _self = this;
            var _filterValue = this._normalizeFilterValue(gFilterValue);
            if (gFilterValue === '__hx_clear') {
                // Clear out this field, then starting from the unfiltered list re-instate all
                // remaining fields.
                delete _self._filterMap[gFilterField];
                _self.itemList = this._resetGlobalFilters();
            } else {
                if (_self._filterMap[gFilterField] &&
                    _self._filterMap[gFilterField] === _filterValue) {
                    // The filter did not change ... do nothing.
                    return;
                } else if (_self._filterMap[gFilterField] &&
                           _self._filterMap[gFilterField] !== _filterValue) {
                    // Start over.
                    _self._filterMap[gFilterField] = _filterValue;
                    _self.itemList = this._resetGlobalFilters();
                } else {
                    // Use itemList in the call below as filters can build on each other.
                    _self._filterMap[gFilterField] = _filterValue;
                    _self.itemList = _self.options.doGlobalFilter(_self.itemList, gFilterField, _filterValue);
                }
            }
            _self._resetPaging();
            _self._refreshData(function() {
                _self.$parent.listview( "refresh" );
            });
        },
        
        _clearGlobalFilterMenu: function() {
            for (var fField in this._filterMap) {
                $('option[data-field="' + fField + '"]').removeAttr('selected');
                $('option[value="__hx_clear"][data-field="' + fField + '"]').prop('selected', 'true');
                $('select[data-field="' + fField + '"]').selectmenu('refresh');
            }
        },
        
        _refreshGlobalFilterContainer: function(filters) {
            var _self = this;
            
            /* See if the contents of the filters has changed. */
            var newFiltersJSON = JSON.stringify(filters);
            if (_self._currentGlobalFiltersJSON) {
                if (newFiltersJSON === _self._currentGlobalFiltersJSON) {
                    // No change.
                    return;
                }
            }
            _self._currentGlobalFiltersJSON = newFiltersJSON;
            /* Need to refresh the search/sort area. */
            _self._searchSortDirty = true;
            
            /* we are only called if filters is non-null. */
            if (_self._globalFilterContainer) {
                /* Remove the old filter menu ... */
                _self._globalFilterContainer.remove();
            }
            if (!_self._filterMap) {
                _self._filterMap = {};
            }
            
            _self._globalFilterContainer = $('<div/>').attr({
                'data-role' : 'popup',
                'id' : Helix.Utils.getUniqueID(),
                'data-theme' : 'a',
                'data-position-to' : 'origin',
                'data-history': 'false'
            }).appendTo(_self.$wrapper);
            var filtersList = $('<ul />').attr({ 
                'data-role' : 'listview',
                'data-inset' : 'true',
                'data-theme' : 'b'
            }).appendTo(_self._globalFilterContainer);
            for (var fldName in filters) {
                var filterObj = filters[fldName];
                var filterItem = null;
                if (filterObj.values.length == 1) {
                    filterItem = $('<li />').append($('<a />').attr({ 
                        'href' : 'javascript:void(0)',
                        'data-field': fldName,
                        'data-value': filterObj.values[0]
                    }).append(filterObj.valueNames[0]));
                    filtersList.append(filterItem);
                    
                    // Execute the global filter.
                    filterItem.on(_self.tapEvent, function(evt) {
                        evt.stopImmediatePropagation();
                        evt.preventDefault();
                        var newFilterField = $(evt.target).attr('data-field');
                        var newFilterValue = $(evt.target).attr('data-value');
                        
                        _self._doGlobalFilter(newFilterField, newFilterValue);
                        $(_self._globalFilterContainer).popup("close");
                    });
                } else {
                    var selectID = Helix.Utils.getUniqueID();
                    $('<label/>').attr({ 
                        'for' : selectID
                    }).append(filterObj.display).appendTo(filtersList);
                    filterItem = $('<select/>')
                                    .attr({
                                        'name' : selectID,
                                        'id': selectID,
                                        'data-field' : fldName
                                    })
                                    .appendTo(filtersList);
                    for (var i = 0; i < filterObj.values.length; ++i) {
                        var filterName = filterObj.valueNames[i];
                        if (!filterName || !filterName.trim()) {
                            continue;
                        }
                        
                        $('<option/>').attr({
                            'value' : filterObj.values[i],
                            'data-field' : fldName
                        })
                        .append(filterName)
                        .appendTo(filterItem);
                    }
                    // add a special 'clear' value, which is the default value.
                    $('<option/>').attr({
                        'value' : '__hx_clear',
                        'data-field' : fldName,
                        'selected' : 'true'
                    }).append('Clear')
                    .appendTo(filterItem);
                    
                    filterItem.selectmenu({ mini: true });
                    
                    filterItem.change(function(evt) {
                        evt.stopImmediatePropagation();
                        evt.preventDefault();
                        $(this).find("option:selected").each(function() {
                            var gFilterField = $(this).attr('data-field');
                            var gFilterValue = $(this).val();
                            _self._doGlobalFilter(gFilterField, gFilterValue);
                            $(_self._globalFilterContainer).popup("close");
                        });
                    });
                }
            }
            
            /* Always have a "Clear" option. */
            $('<li />').append($('<a />').attr({ 
                'href' : 'javascript:void(0)',
                'data-field': '__clear'
            }).append("Clear"))
              .appendTo(filtersList)
              .on(_self.tapEvent, function(evt) {
                evt.stopImmediatePropagation();
                evt.preventDefault();
                
                // Reset the values in the global filter popup.
                _self._clearGlobalFilterMenu();
                
                _self._filterMap = {};
                _self.itemList = _self.unfilteredList;
                _self._resetPaging();
                _self._refreshData(function() {
                    _self.$parent.listview( "refresh" );
                    _self.$listWrapper.scrollTop(0);
                });
                $(_self._globalFilterContainer).popup("close");
            });
            
            filtersList.listview();
            _self._globalFilterContainer.popup();            
        },
        
        _resetPaging: function() {
            this._lastScrollPos = 0;
            this._renderWindowStart = 0;
            this._renderWindowDelta = 0;
            this._itemsPerPage = this.options.itemsPerPage;
            this._atDataTop = false; 
            this._lastUpdateScroll = 0;
            this.rescrollInProgress = false;
            this.scrollCalculationInProgress = false;
        },
                        
        
        _refreshData: function(oncomplete) {
            var _self = this;
        
            if (_self.__refreshInProgress) {
                // Do not list refreshed interleave. Finish one, then do the next one.
                $(_self.$wrapper).on('refreshdone', function(evt) {
                    _self._refreshData(evt.data);
                    return false;
                }, oncomplete);
                return;
            }
        
            //this._clearListRows();
            _self.refreshInProgress = true;
            _self.displayList = [];
        
            if (_self.options.headerText) {
                if (!_self._headerLI) {
                    _self._headerLI = $('<li />').attr({
                        'data-role' : 'list-divider'
                    }).append(_self.options.headerText)
                    .appendTo(_self.$parent);
                } else {
                    _self._headerLI.text(_self.options.headerText);
                }
            }
        
            /* List must be non-empty and it must be a query collection. */
            var displayCollection = _self.itemList;
            if (!displayCollection || !displayCollection.newEach) {
                return;            
            }
                        
            /* Apply any active search terms, then global filters. Note, we must apply 
             * search first. 
             */
            var emptyMsg = _self.options.emptyMessage;
            var __completion = function(displayCollection) {
                _self._sortAndRenderData(displayCollection, function(oncomplete) {
                    oncomplete();
                    $(_self.$wrapper).trigger('refreshdone');
                }, emptyMsg, oncomplete);
            };
            
            if (this.__searchTextDirty && this.__searchText && this.__searchText.trim()) {
                emptyMsg = this.options.emptySearchMessage;
                this.__searchTextDirty = false;
                this.options.indexedSearch(this.__searchText.trim(), function(displayCollection) {
                    _self.unfilteredList = _self.itemList = displayCollection;
                    __completion(_self.itemList);
                });
                //displayCollection = _self._applySearch(displayCollection);
            } else {
                __completion(displayCollection);
            }
        },
        
        _sortAndRenderData: function(displayCollection, oncomplete, emptyMsg, opaque) {
            var _self = this;
            var orderby = _self._currentSort; 
            displayCollection = _self._resetGlobalFilters(displayCollection);

            if (orderby /*&& !_self.__searchText*/) {
                displayCollection = _self._applyOrdering(displayCollection);
            }

            /* Apply skip and limit. */
            if (_self._renderWindowStart > 0) {
                displayCollection = displayCollection.skip(_self._renderWindowStart);
            }
            displayCollection = displayCollection.limit(Math.floor(_self._itemsPerPage * 1.5));

            var rowIndex = 0;
            var nRendered = 0;
            var LIs = [];
            var groupsToRender = [];
            if (_self.options.grouped) {
                LIs = $(_self.$parent).find('li[data-role=list-divider]');
            } else {
                // Add not selector to make sure we handle auto dividers properly.
                LIs = $(_self.$parent).find('li:not([data-role=list-divider])');
            }
            displayCollection.newEach({
                /* Process each element. */
                eachFn: function(curRow) {
                    if (_self.options.grouped) {
                        groupsToRender.push(curRow);
                    } else {
                        if (nRendered >= _self._itemsPerPage) {
                            return;
                        }

                        ++rowIndex;
                        if (_self._renderSingleRow(LIs, rowIndex - 1, _self._itemsPerPage, curRow, function() {
                            // Nothing to do.
                        })) {
                            ++nRendered;
                        }
                    }
                },
                /* Called on start. */
                startFn: function(count) {
                    _self.nElems = count;
                    if (count < _self._itemsPerPage) {
                        // We did not get the full "limit" count of items requested
                        _self._atDataTop = true;
                    }
                },
                /* Called on done. */
                doneFn: function(count) {
                    var _ridx;
                    if (!_self.options.grouped) {
                        /* We did not render any rows. Call completion. */
                        _self.refreshInProgress = false;

                        var startIdx = nRendered;
                        for (_ridx = startIdx; _ridx < LIs.length; ++_ridx) {
                            $(LIs[_ridx]).hide();
                        }

                        if (count == 0) {
                            _self._handleEmpty(emptyMsg);
                        }
                        oncomplete(opaque);
                    } else {
                        var groupIndex = 0;
                        var __renderGroup = function() {
                            if (groupsToRender.length == 0) {
                                for (_ridx = groupIndex; _ridx < LIs.length; ++_ridx) {
                                    $(LIs[_ridx]).hide();
                                }
                                /* Call completion when all rows are done rendering. */
                                _self.refreshInProgress = false;
                                oncomplete(opaque);
                                if (groupIndex == 0) {
                                    _self._handleEmpty(emptyMsg);
                                }
                                return;
                            }

                            var nxt = groupsToRender.shift();
                            if (nRendered >= _self._itemsPerPage) {
                                return;
                            }

                            ++groupIndex;                            
                            if (_self._renderSingleRow(LIs, groupIndex - 1, _self._itemsPerPage, nxt, function() {
                                __renderGroup();
                            })) {
                                ++nRendered;
                            }
                        };
                        __renderGroup();
                    }
                }
            });  
        },
        
        _updateRenderWindow: function(firstShowingIndex, direction) {
            var listOffset;
            var oldWindowStart = this._renderWindowStart, newWindowStart;
            if (direction == 0) {
                // Scrolling up to the top of the list. Make this item 3/4 of the way to the end of the list.
                listOffset = ((this._itemsPerPage * 3) / 4);
                newWindowStart = oldWindowStart - Math.floor(listOffset - firstShowingIndex);
            } else {
                // Scrolling down to the bottom of the list. Make the current window 1/4 of the way into the list.
                listOffset = ((this._itemsPerPage) / 4);
                newWindowStart = oldWindowStart + Math.floor(firstShowingIndex - listOffset);
            }
            
            if (newWindowStart < 0) {
                newWindowStart = 0;
            }
            
            this._renderWindowStart = newWindowStart;
            return newWindowStart;
        },
        
        _clearListRows: function() {
            this.$listWrapper.scrollTop(0);
            var toRemove = this.$parent.find("li").filter(":not(li[data-fixed-header='yes'])");
            toRemove.remove();
            this.$parent.find('[data-role="fieldcontain"]').remove();
        },
        
        _doSearch: function() {
            var _self = this;
            _self.__searchText = _self.$searchBox.val();
            if (_self.__searchReadyTimeout) {
                clearTimeout(_self.__searchReadyTimeout);
            }

            _self.__searchReadyTimeout = setTimeout(function() {
                if (_self.__searchReadyTimeout) {
                    clearTimeout(_self.__searchReadyTimeout);
                }
                
                _self._resetPaging();
                _self.__searchTextDirty = true;
                _self._refreshData(function() {
                    _self.$parent.listview( "refresh" );
                });
                _self.__searchReadyTimeout = null;
            }, 1000);
        },
        
        _prependSearchBox: function() {
            var _self = this;
            var hasButtons = (_self._globalFilterContainer || _self._sortContainer) && _self.showButtons; 
            var useControlGroup = false;
            if (!_self._searchSortDirty) {
                return;
            }
            
            _self.$searchSortDiv.empty();
            _self._searchSortDirty = false;

            if (hasButtons) {
                if (_self._sortContainer && _self._globalFilterContainer) {
                    useControlGroup = true;
                }
                
                var $sortDiv = $('<div/>').attr({
                    'class' : 'hx-display-inline',
                    'data-role' : 'none',
                    'data-type' : 'horizontal'
                }).appendTo(_self.$searchSortDiv);
                if (_self._sortContainer) {
                    /* Ascending/descending sort buttons. */
                    var sAscendID = Helix.Utils.getUniqueID();
                    var sDescendID = Helix.Utils.getUniqueID();
                    this.options.sortButtons = {
                        'ascending' : PrimeFaces.escapeClientId(sAscendID),
                        'descending' : PrimeFaces.escapeClientId(sDescendID)
                    };

                    this.$sortAscending = $('<a/>').attr({
                        'id' : sAscendID,
                        'data-role' : 'none',
                        'data-icon' : 'arrow-u',
                        'data-iconpos' : 'notext',
                        'data-theme' : 'b',
                        'data-mini' : (useControlGroup ? 'true' : 'false')
                    }).button()
                    .appendTo($sortDiv)
                    .on(_self.tapEvent, function(ev) {
                        ev.stopPropagation();
                        ev.stopImmediatePropagation();
                        ev.preventDefault();
                        
                        _self.displaySortMenu(this);
                    });
                    this.$sortDescending = $('<a/>').attr({
                        'id' : sDescendID,
                        'data-role' : 'none',
                        'data-icon' : 'arrow-d',
                        'data-iconpos' : 'notext',
                        'data-theme' : 'b',
                        'data-mini' : (useControlGroup ? 'true' : 'false')
                    }).button()
                    .appendTo($sortDiv)
                    .on(_self.tapEvent, function(ev) {
                        ev.stopPropagation();
                        ev.stopImmediatePropagation();
                        ev.preventDefault();
                        
                        _self.displaySortMenu(this);
                    });                    
                }
                
                if (_self._globalFilterContainer) {
                    /* Filter button. */
                    var sFilterID = Helix.Utils.getUniqueID();
                    this.$filter = $('<a/>').attr({
                        'id' : sFilterID,
                        'data-role' : 'none',
                        'data-icon' : 'filter',
                        'data-iconpos' : 'notext',
                        'data-theme' : 'b',
                        'data-mini' : (useControlGroup ? 'true' : 'false')
                    }).button()
                    .appendTo($sortDiv)
                    .on(_self.tapEvent, function(ev) {
                        ev.stopPropagation();
                        ev.stopImmediatePropagation();
                        ev.preventDefault();
                        
                        _self.displayGlobalFilterMenu(this);
                    });                    
                }
                
                if (useControlGroup) {
                    $sortDiv.controlgroup();
                } else {
                    $sortDiv.controlgroup({ corners: false });
                }
            }
            if (this.options.indexedSearch) {
                var styleClass = 'hx-display-inline';
                var widthStyle = null;
                if (!hasButtons) {
                    styleClass = styleClass + ' hx-full-width';
                } else {
                    if (useControlGroup) {
                        widthStyle = '60%';
                    } else {
                        widthStyle = '80%';
                    }
                }
                var $searchDiv = $('<div/>').attr({
                    'class' : styleClass
                }).appendTo(_self.$searchSortDiv);
                var sboxID = Helix.Utils.getUniqueID();
                this.$searchBox = $('<input/>').attr({
                    'type' : 'search',
                    'name' : 'search',
                    'id' : sboxID,
                    'value' : '',
                    'data-role' : 'none',
                    'data-mini' : true
                }).appendTo($searchDiv);
                if (widthStyle) {
                    $searchDiv.css('width', widthStyle);
                }

                this.$searchLabel = $('<label/>').attr({
                    'for': sboxID
                }).append('Search').appendTo($searchDiv).hide();
                this.$searchBox.textinput();
                if (this.__searchText) {
                    this.$searchBox.val(this.__searchText);
                }
                this.$searchBox.on('input', function() {
                    _self._doSearch();
                });
                $searchDiv.find('a.ui-input-clear').on(_self.tapEvent, function() {
                    _self.itemList = _self.originalList;
                    _self.__searchText = "";
                    _self.$searchBox.val(_self.__searchText);
                    _self._resetPaging();
                    _self._refreshData(function() {
                        _self.$parent.listview( "refresh" );
                        _self.$listWrapper.scrollTop(0);
                    });
                    return false;
                });
            }
            
            _self.$searchSortDiv.show();
        },
        /* Apply the appropriate sort to the display collection. */
        _applyOrdering: function(displayCollection) {
            var orderby = this._currentSort; 
            var direction = this._currentSortOrder;
            var usecase = this._currentSortCase;
        
            var orderbyFields = orderby.split(",");
            var directionVals = direction.split(",");
            var caseVals = usecase.split(",");

            var oidx = 0;
            for (oidx = 0; oidx < orderbyFields.length; ++oidx) {
                var latestDirection = ( (oidx < directionVals.length) ? directionVals[oidx] : directionVals[directionVals.length - 1]);
                var nxtCase = (caseVals[oidx] === 'true' ? true : false);
                if (latestDirection.toUpperCase() == "DESCENDING") {
                    displayCollection = displayCollection.order(orderbyFields[oidx], false, nxtCase);
                } else {
                    displayCollection = displayCollection.order(orderbyFields[oidx], true, nxtCase);
                }
            }
            return displayCollection;
        },
        _renderSingleRow: function(LIs, rowIndex, itemsPerPage, curRow, oncomplete) {
            var _self = this;
            var arrIdx = (itemsPerPage > 0) ? (rowIndex % itemsPerPage) : rowIndex;
            if (_self.options.grouped) {
                var __renderEmptyGroup = function(dividerLI) {
                    // Hide all elements in this group index.
                    _self.$parent.find('li[data-index="' + rowIndex + '"]').hide();

                    // Find the empty element, if it is there. If so, show it.
                    var $emptyElem = _self.$parent.find('li[data-index="' + rowIndex + '"][data-group-index="-1"]');
                    if ($emptyElem.length) {
                        $emptyElem.show();
                    } else {                                 
                        $('<li />').attr({
                            'class' : _self.options.rowStyleClass,
                            'data-index' : rowIndex,
                            'data-group-index' : '-1'
                        }).append(_self.options.emptyGroupMessage)
                        .insertAfter(dividerLI);
                    }
                };

                var rowObject = {
                    'group': curRow, 
                    'rows' : []
                };
                _self.displayList.push(rowObject);
          
                var groupName = _self.options.groupName(rowObject.group);
                var groupMembers = _self.options.groupMembers(rowObject.group);
                var groupIndex = 0;
                
                // Attach the group header.
                var dividerLI;
                if (arrIdx >= LIs.length) {
                    dividerLI = $('<li />').attr({
                        'data-role' : 'list-divider'
                    }).append(groupName).appendTo(_self.$parent);
                } else {
                    dividerLI = LIs[arrIdx];
                    $(dividerLI).text(groupName).show();
                }
                if (_self.options.dividerStyleClass) {
                    $(dividerLI).addClass(_self.options.dividerStyleClass);
                }
                
                if (groupMembers) {
                    // groupLIs are all LIs from dividerLI to the next divider
                    var groupLIs = $(dividerLI).nextUntil('li[data-role="list-divider"]');
                    groupMembers.forEach(
                        /* Element callback. */
                        function(groupRow) {
                            if (_self._renderRowMarkup(groupLIs, groupRow, arrIdx, groupIndex)) {
                                rowObject.rows.push(groupRow);
                                ++groupIndex;
                            }
                        },
                        /* On start. */
                        function(ct) {
                            if (ct == 0) {
                                __renderEmptyGroup(dividerLI);                                
                            }
                        },
                        /* On done. */
                        function() {
                            oncomplete();
                            for (var _gidx = groupIndex; _gidx < groupLIs.length; ++_gidx) {
                                groupLIs[_gidx].hide();
                            }
                        }
                    );
                    return true;
                } else if (groupMembers == null) {
                    __renderEmptyGroup(dividerLI);
                    oncomplete();
                    return true;
                } else {
                    oncomplete();
                    return false;
                }
            } else {
                if (_self._renderRowMarkup(LIs, curRow, _self.displayList.length)) {
                    _self.displayList.push(curRow);
                    oncomplete();
                    return true;
                }
                oncomplete();
                return false;
            }  
        },
    
        _renderRowMarkup: function(LIs, row, rowIndex, groupIndex) {
            var _self = this;
            var curRowParent = null;
            var curRowFresh = false;
            
            if (_self.options.grouped && groupIndex < LIs.length) {
                curRowParent = $(LIs[groupIndex]);
            } else if (!_self.options.grouped) {
                if (rowIndex < LIs.length) {
                    curRowParent = $(LIs[rowIndex]);
                }
            } 
            
            if (!curRowParent) {
                curRowFresh = true;
                curRowParent = $('<li />').attr({
                    'class' : _self.options.rowStyleClass
                });
            }
            
            curRowParent.attr('data-index', rowIndex);
            if (_self.options.grouped) {
                curRowParent.attr('data-group-index', groupIndex);
            }
        
            if (_self.options.rowRenderer(curRowParent, _self, row, rowIndex, _self.options.strings)) {
                if (curRowFresh) {
                    curRowParent.appendTo(_self.$parent);
                } else {
                    curRowParent.show();
                }
            } else {
                return false;
            }
            
            if (_self.options.itemContextMenu) {
                if (!_self.options.itemContextMenuFilter || _self.options.itemContextMenuFilter(row)) {
                    $(curRowParent).off(this.contextEvent).on(this.contextEvent, function(event) {
                        // This allows the container to have taphold context menus that are not
                        // triggered when this event is triggered.
                        event.stopImmediatePropagation();
                        event.stopPropagation();
                        event.preventDefault();

                        _self.setSelected(event.target);
                        _self.options.itemContextMenu.open({
                            positionTo: event.target,
                            thisArg: _self
                        });
                    });
                } else if (!curRowFresh) {
                    $(curRowParent).off(this.contextEvent);
                }
            } else if (_self.options.holdAction && curRowFresh) {
                $(curRowParent).on(_self.contextEvent, function(event) {
                    event.stopImmediatePropagation();
                    event.stopPropagation();
                    event.preventDefault();
                    
                    if (_self.setSelected(event.target)) {
                        _self.selectItem();                    
                    }
                    _self.options.holdAction(_self.selected, _self.selectedGroup, _self.options.strings);
                }); 
            } 
            if (_self.options.selectAction && curRowFresh) {
                $(curRowParent).on(_self.tapEvent, function(event) {
                    event.stopImmediatePropagation();
                    event.stopPropagation();
                    event.preventDefault();
                    
                    if (_self.options.itemContextMenu && _self.options.itemContextMenu.active) {
                        return false;
                    }

                    if (_self.setSelected(event.target)) {
                        _self.selectItem();
                    }
                    return false;
                });
            }
            if (_self.options.swipeLeftAction && curRowFresh) {
                $(curRowParent).on('swipeleft', function(event) {
                    event.stopImmediatePropagation();

                    _self.setSelected(event.target);
                    _self.options.swipeLeftAction(_self.selected);
                    return false;
                });
            }
            if (_self.options.swipeRightAction && curRowFresh) {
                $(curRowParent).on('swiperight', function(event) {
                    event.stopImmediatePropagation();

                    _self.setSelected(event.target);
                    _self.options.swipeRightAction(_self.selected);
                    return false;
                });
            }
        
            return true;
        },
    
        setSelected: function(targetElem) {
            var enclosingLI = $(targetElem).closest("li[data-index]");
            var enclosingIndex = $(enclosingLI).attr('data-index');
            var enclosingGroupIndex;
            var nxtSelection;
            if (this.options.grouped) {
                enclosingGroupIndex = $(enclosingLI).attr('data-group-index');
                nxtSelection = this.displayList[enclosingIndex].rows[enclosingGroupIndex];
            } else {
                nxtSelection = this.displayList[enclosingIndex];
            }
            
            if (this.selectedLI) {
                this.selectedLI.removeClass('ui-btn-active');
            }
            if (this.options.grouped) {
                this.selectedGroupRow = enclosingGroupIndex;
                this.selectedGroup = this.displayList[enclosingIndex].group;
            }
            this.selectedLI = enclosingLI;
            this.selectedLI.addClass('ui-btn-active');
            this.selectedIndex = enclosingIndex;
            this.selected = nxtSelection;
            
            return true;
        },
        getSelected: function() {
            return this.selected;
        },
        
        clearSelected: function() {
            if (this.selected) {
                this.selectedLI.removeClass('ui-btn-active');
                this.selectedLI = null;
                this.selected = null;
            }
        },
        
        getSelectedLI: function() {
            return this.selectedLI;
        },
    
        setSelectedByIndex: function(idx, groupIdx) {
            var targetElem;
            if (idx && groupIdx) {
                targetElem = $(this.$wrapper).find('li[data-index=' + idx +']').filter('[data-group-index=' + groupIdx + ']');
                if (targetElem && targetElem.length > 0) {
                    this.setSelected(targetElem);
                }
            } else {
                targetElem = $(this.$wrapper).find('li[data-index=' + idx +']');
                if (targetElem && targetElem.length > 0) {
                    this.setSelected(targetElem);
                }
            }
        },
        getSelectedRow: function() {
            return this.selectedIndex;
        },
    
        getSelectedGroupRow: function() {
            return this.selectedGroupRow;
        },
        
        updateSelectedRow: function(rowComponents) {
            var parentElement = $(this.element).find('[data-index="'+this.getSelectedRow()+'"]');
            if (rowComponents.icon) {
                var oldIcon = $(parentElement).attr('data-icon');
                $(parentElement).attr('data-icon', rowComponents.icon);
                $(parentElement).find('span')
                    .removeClass('ui-icon-'+oldIcon)
                    .addClass('ui-icon-'+rowComponents.icon);
            }
            if (rowComponents.updateFn) {
                rowComponents.updateFn.call(this, parentElement);
            }
        },
  
        createListRow: function(parentElement,rowComponents) {
            var isEnhanced = false;
            if ($(parentElement).hasClass('ui-li')) {
                // Already enhanced.
                isEnhanced = true;
            }
            
            var mainLink = null;
            if (isEnhanced) {
                mainLink = $(parentElement).find('a');
            } else {
                mainLink = $('<a />').attr({
                    'href' : 'javascript:void(0)'
                }).appendTo($(parentElement));
            }
            
            if (rowComponents.icon) {
                $(parentElement).attr('data-icon', rowComponents.icon);
                var iconMarkup = $(parentElement).find('span.ui-icon');
                if (iconMarkup.length) {
                    // Manually update the icon itself.
                    iconMarkup.removeClass()
                        .addClass('ui-icon ui-icon-' + rowComponents.icon + ' ui-icon-shadow');
                }
            } else {
                $(parentElement).removeAttr('data-icon');
            }
            
            if (rowComponents.image) {
                var imgMarkup = $(mainLink).find('img[data-role="image"]');
                if (imgMarkup.length) {
                    imgMarkup.attr('src', rowComponents.image).show();
                } else {
                    mainLink.append($('<img />').attr({
                        'src' : rowComponents.image,
                        'data-role' : 'image'
                    }));
                }
            } else {
                $(mainLink).find('img[data-role="image"]').hide();
            }
            
            if (rowComponents.header) {
                var headerMarkup = mainLink.find('h3[data-role="header"]');
                if( Object.prototype.toString.call(rowComponents.header) == '[object String]' ) {
                    if (headerMarkup.length) {
                        headerMarkup.text(Helix.Utils.escapeQuotes(rowComponents.header)).show();
                    } else {
                        mainLink.append($('<h3 />')
                            .attr('data-role', 'header')
                            .text(Helix.Utils.escapeQuotes(rowComponents.header)));
                    }
                } else {
                    if (headerMarkup.length) {
                        headerMarkup.empty().append(rowComponents.header);
                    } else {
                        mainLink.append($('<h3 />')
                            .attr('data-role', 'header')
                            .append(rowComponents.header));
                    }
                }
            } else {
                mainLink.find('h3[data-role="header"]').hide();
            }
            
            if (rowComponents.subHeader) {
                var subheaderMarkup = mainLink.find('p[data-role="subheader"]');
                if (subheaderMarkup.length) {
                    subheaderMarkup.text(rowComponents.subHeader).show();
                } else {
                    mainLink.append($('<p />')
                        .attr('data-role', 'subheader')
                        .append($('<strong />')
                        .text(rowComponents.subHeader)));
                }
            } else {
                mainLink.find('p[data-role="subheader"]').hide();
            }
            
            if (rowComponents.body) {
                var bodyMarkup = null;
                if (rowComponents.header || rowComponents.subHeader) {
                    bodyMarkup = mainLink.find('p[data-role="body"]');
                    if (bodyMarkup.length) {
                        bodyMarkup.empty().append(rowComponents.body).show();
                    } else {
                        mainLink.append($('<p />').attr('data-role', 'body').append(rowComponents.body));
                    }
                } else {
                    bodyMarkup = mainLink.find('[data-role="body"]');
                    if (bodyMarkup.length) {
                        mainLink.empty();
                    }
                    $(rowComponents.body).attr('data-role', 'body');
                    mainLink.append(rowComponents.body);
                }
            } else {
                mainLink.find('[data-role="body"]').hide();
            }
            
            if (rowComponents.aside) {
                var asideMarkup = $('p.ui-li-aside');
                if (asideMarkup.length) {
                    asideMarkup.empty().append(rowComponents.aside).show();
                } else {
                    mainLink.append($('<p />').attr({
                        'class' : 'ui-li-aside'
                    }).append(rowComponents.aside));
                }
            } else {
                $('p.ui-li-aside').hide();
            }
            
            if (rowComponents.key) {
                $(parentElement).attr('data-key', rowComponents.key);
            }
            
            /* XXX: not supported for now. 
            if (rowComponents.splitLink) {
                if (isEnhanced) {
                    
                } else {
                    $(parentElement).append($('<a />').attr({
                        'href' : 'javascript:void(0)'
                    }).on(this.tapEvent, function(ev) {
                        rowComponents.splitLink(ev);
                    }));
                }
            }*/
        },
        selectItem: function(noSelectAction) {
            if (!this.selected) {
                if (this.options.grouped) {
                    this.setSelectedByIndex(0, 0);
                } else {
                    this.setSelectedByIndex(0);
                }
            }
            if (this.options.selectAction && !noSelectAction) {
                this.options.selectAction(this.selected, this.selectedGroup, this.strings);
            }          
        },
        selectNext: function() {
            if (!this.selectedLI) {
                this.setSelectedByIndex(0, 0);
            } else {
                var nxt = this.selectedLI.next('li[data-index]');
                if (nxt.length) {
                    this.setSelected(nxt);
                    this.selectItem();
                }
            }
        },
        selectPrev: function() {
            if (!this.selectedLI) {
                this.setSelectedByIndex(0, 0);
            } else {
                var nxt = this.selectedLI.prev('li[data-index]');
                if (nxt.length) {
                    this.setSelected(nxt);
                    this.selectItem();
                }
            }
        },
        holdItem: function() {
            if (!this.selected) {
                this.setSelectedByIndex(0, 0);
            }
            this.options.holdAction(this.selected, this.selectedGroup, this.strings);          
        },
        
        /* Display sort and filter menus. */
        displaySortMenu: function(selector) {
            this._sortContainer.popup('open', { positionTo: selector });
        },
        displayFilterMenu: function(selector) {
            this._filterContextMenu.open({
                positionTo: selector
            });
        },
        displayGlobalFilterMenu: function(selector) {
            this._globalFilterContainer.popup('open', { positionTo: selector });
        },
        
        setWrapperHeight: function(hgt) {
            this.$wrapper.height(hgt);
        },
        /**
         * Refresh the scroller surrounding the datalist contents.
         */
        refreshScroller: function() {
            //Helix.Layout.updateScrollers(this.$wrapper);
        },
        
        setHeaderText: function(txt) {
            this.options.headerText = txt;
        },
        
        openItemContextMenu: function() {
            this.options.itemContextMenu.open();
        },
        
        closeItemContextMenu: function() {
            this.options.itemContextMenu.close();
        },
        
        /* Puts the list in compact mode. Mostly this just adds the hx-listview-mini
         * style to the ul tag, which other parts of the code (or the user's code) can
         * use to render a more compact style using CSS.
         */
        setMiniView: function() {
           this.$parent.addClass('hx-listview-mini'); 
        },
        
        /* Puts the list in regular mode by removing hx-listview-mini.
         */
        setRegularView: function() {
           this.$parent.removeClass('hx-listview-mini'); 
        },
        
        /**
         * Returns true after the first time the list has been loaded and laid out.
         */
        getIsLoaded: function() {
            return this.isLoaded;
        },
        
        /**
         * Update the value of the 'noSelectOnPagination' option.
         */
        setNoSelectOnPagination: function(val) {
            this.options.noSelectOnPagination = val;
        },
        
        /**
         * Get the ul element of the list.
         */
        getListElement: function() {
            return this.$parent;
        },
        
        /**
         * Mark the list dirty. The dirty flag persists until the list is refreshed either
         * with refreshList or refreshData. This flag is primarily used for debugging.
         */
        markListDirty: function() {
            this.isDirty = true;
        },
        
        /**
         * Return the isDirty flag.
         */
        listIsDirty: function() {
            return this.isDirty;
        }
    });
})(jQuery);;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function($) {

    $.widget("helix.helixContextMenu", {

        options: {
            /**
             * Array of context menu items that are included in the popup menu. Each item
             * is an object that specifies a menu item delaratively as follows:
             *
             * display : String to display.
             * enabled : If false, the menu item is displayed but disabled
             * action : Function to execute when this item is tapped. This function is
             *          executed with this popup menu object as the 'this' object.
             * data: String to store in each item in the context menu and to pass to the action as
             *       the only argument when a tap occurs. This is optional. Null is passed to the action
             *       if data is not specified.
             */
            items: [],

            /**
             * Object mapping device types to a constant, true or false, which indicates
             * if the form layout should be in "mini" mode for that device type. Supported
             * device types are "tablet", "phablet", and "phone". The default is { "phone" : true }.
             */
            useMiniLayout : {
                "phone" : true
            },
            
            /**
             * Optional callback that is invoked before the context menu is opened. The 'this' variable
             * in the call is determined by the object that opens this context menu. If that object specifies
             * a 'this' object, then that specified object is relayed to the callback. Otherwise the context menu
             * object is 'this' in the callback.
             */
            beforeopen: null,
            
            /**
             * Optional name. Used to provide a unique ID for each menu item of the form <name>-<index>.
             * If no name is provided, one is generated. The getName method returns the name.
             */
            name: null
        },

        _create: function() {
            this.active = false;

            if (Helix.hasTouch) {
                this.tapEvent = 'touchstart';
            } else {
                this.tapEvent = 'click';
            }
            if (Helix.deviceType === 'phone') {
                this._maxHeight = 250;
            } else {
                this._maxHeight = 500;
            }
            
            if (!this.options.name) {
                this.options.name = Helix.Utils.getUniqueID();
            }
            
            this.optionsList = null;
            this.page = this.element.closest( ".ui-page" );
            this.id = Helix.Utils.getUniqueID();
            this.refresh();
        },
        
        // status = true or false
        enableItem: function(itemIndex, status) {
            if (itemIndex >= this.options.items.length) {
                return false;
            }
            
            var selected = this.options.items[itemIndex];
            var items = this.optionsList.find('[data-index="' + itemIndex + '"]');

            if (items.length == 0) {
                return false;
            }
            var target = items[0];

            if (status === true) {
                // Enable item
                if (selected.enabled === false) {
                    $(target).closest('li').removeClass('ui-disabled');
                }
            } else {
                // Disable item
                // 'enabled' may be true, false or null/undefined
                if (selected.enabled || (selected.enabled === undefined)) {
                    var li = $(target).closest('li');
                    $(li).addClass('ui-disabled');
                }   
            }

            selected.enabled = status;
            return true;
        },

        refresh: function() {
            var _self = this;
            
            $(this.element).empty();
            this._menuContainer = $('<div/>').attr({
                'data-role' : 'popup',
                'data-theme' : 'a',
                'id' : this.id,
                'data-history': 'false',
                'style' : 'max-height: ' + this._maxHeight + 'px; overflow-y: scroll'
            }).appendTo(this.element);
            this.optionsList = $('<ul />').attr({
                'data-role' : 'listview',
                'data-inset' : 'true',
                'id' : this.id + "-ul",
                'data-theme' : 'b'
            }).appendTo(this._menuContainer);
            for (var i = 0; i < this.options.items.length; ++i) {
                var nxtItem = this.options.items[i];
                var nxtLI = $('<li />');

                if (nxtItem.isDivider) {
                    nxtLI.attr('data-role', 'divider');
                    nxtLI.attr('data-theme', 'a');
                    nxtLI.append(nxtItem.display);
                } else {
                    var nxtLink = $('<a />').attr({
                        'href' : 'javascript:void(0)',
                        'data-index' : i,
                        'id' : this.options.name + '-' + (nxtItem.name ? nxtItem.name: i) 
                    }).append(nxtItem.display);
                    if (nxtItem.data) {
                        nxtLink.attr('data-field', nxtItem.data);
                    }
                    if (nxtItem.enabled === false) {
                        nxtLI.addClass('ui-disabled');
                    }
                    if (nxtItem.group) {
                        nxtLI.attr('data-group', nxtItem.group);
                    }
                    nxtLI.append(nxtLink);
                }
                this.optionsList.append(nxtLI);
            }

            this.optionsList.on(_self.tapEvent, 'a', function(evt) {
                if (!_self.active) {
                    return true;
                }
                evt.stopImmediatePropagation();
                
                var cbData = $(evt.target).attr('data-field');
                var cbIndex = $(evt.target).attr('data-index');

                var item = _self.options.items[cbIndex];
                if (item.action) {
                    var __runAction = function() {
                        if (_self._thisArg) {
                            item.action.call(_self._thisArg, cbData, evt);
                        } else {
                            item.action.call(_self, cbData, evt);
                        }
                        _self.close();
                    };
                    if (Helix.hasTouch) {
                        // See if the user scrolls before we see touchend. If they do,
                        // then do not fire the event.
                        var scrollTop =  $(_self._menuContainer).scrollTop();
                        $(evt.target).off('touchend').on('touchend', function(evt2) {
                            var cbIndex2 = $(evt2.target).attr('data-index');
                            if (cbIndex == cbIndex2 &&
                                Math.abs(scrollTop - $(_self._menuContainer).scrollTop()) < 10) {
                                __runAction();
                                return false;
                            }
                            return true;
                        });
                        setTimeout(function() {
                            $(evt.target).off('touchend');
                        }, 2500);
                        return true;
                    } else {
                        __runAction();
                        return false;
                    }
                }
                return false;
            });

            if (Helix.hasTouch) {
                // Prevent jQM touch events from propagating beyond the list items. Otherwise
                // if tapping a list item closes the list and puts something underneath the list
                // the tap will fall through.
                this.optionsList.on('tap vclick click', 'li', function(evt) {
                    evt.stopImmediatePropagation();
                    return false;
                });
                $(this._menuContainer).on('touchstart touchend tap vclick click', function(evt) {
                    // Prevent these events from reaching whatever is below the menu.
                    evt.stopImmediatePropagation();
                    return false;
                });
            }

            this.optionsList.listview();
            _self._menuContainer.popup({
                dismissible: !Helix.hasTouch, // We will explicitly close the popup when this is a touch device.
                afterclose: function() {
                    _self.active = false;
                }
            });
        },

        open: function(obj) {
            this._thisArg = (obj ? obj.thisArg : null);
            if (this.options.beforeopen) {
                if (this._thisArg) {
                    this.options.beforeopen.call(this._thisArg);
                } else {
                    this.options.beforeopen.call(this);
                }
            }
            
            if (obj) {
                this._menuContainer.popup("open", obj);
            } else {
                this._menuContainer.popup("open");
            }
            this.active = true;
            if (Helix.hasTouch) {
                $(this.page).find(PrimeFaces.escapeClientId(this.id + "-screen")).on( this.tapEvent, $.proxy( this, "_stopAndClose" ) );
                $(this.page).find(PrimeFaces.escapeClientId(this.id + "-screen")).on( 'tap', $.proxy( this, "_stop" ) );
            }
            
        },
        
        hideGroup: function(grp) {
            $(this.optionsList).find('[data-group="' + grp + '"]').hide();
            this.optionsList.listview("refresh");
        },
        
        showGroup: function(grp) {
            $(this.optionsList).find('[data-group="' + grp + '"]').show();
            this.optionsList.listview("refresh");
        },

        _stopAndClose: function(ev) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
            this.close();
            return false;
        },

        _stop: function(ev) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
            return false;
        },

        close: function() {
            this.active = false;
            this._menuContainer.popup("close");
            if (Helix.hasTouch) {
                $(this.page).find(PrimeFaces.escapeClientId(this.id + "-screen")).off( this.tapEvent );
                $(this.page).find(PrimeFaces.escapeClientId(this.id + "-screen")).off( 'tap' );
            }
        },
        
        getName: function() {
            return this.options.name;
        }
    });
}( jQuery ));;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function($) {
    
    $.widget("helix.helixFormLayout", {        
        
        options: {
            /**
             * Array of form layout items that are included in the form. Each item
             * is an object that specifies a field declaratively with the following
             * object fields:
             *      type: One of the supported field types.
             *      name: Name for the field. Used as the input name and id.
             *      fieldTitle: Title for the field. Can be text, markup, or omitted.
             *      value: Current value for the field. May be empty.
             *      styleClass: Styling for this form element.
             *      width: Width of this field.
             *      height: Height of this field (only used for images).
             *      style: CSS style attached to the field container.
             */
            items: [],
            
            /**
             * Supported modes. Can be 'view', 'edit', or 'all'.
             */
            modes: 'view',
            
            /**
             * Current mode. Can be 'view' or 'edit'. Cannot be a mode not specified
             * in the modes option.
             */
            currentMode: 'view',
            
            /**
             * True if a horizontal separator should be placed in between field.
             */
            separateElements: false,
            
            /**
             * Object mapping device types to a constant, true or false, which indicates
             * if the form layout should be in "mini" mode for that device type. Supported
             * device types are "tablet", "phablet", and "phone". The default is { "phone" : true }.
             */
            useMiniLayout : {
                "phone" : true
            },
            
            /**
             * Namespace. Used to prefix all names to all form elements to make sure we don't
             * get naming conflicts between different forms in the same applications. It is strongly
             * recommended that the namespace is non-empty.
             */
            namespace : ''
        },

        _create: function() {
            /* Initialize variables. */
            this._typeMap = [];
            this._fieldMap = [];
            
            this.page = $(this.element).closest('[data-role="page"]');
            
            /* Determine if we should use the mini layout based on the device
             * type
             */
            this.layoutMini = false;
            if (Helix.deviceType in this.options.useMiniLayout &&
                this.options.useMiniLayout[Helix.deviceType]) {
                $(this.element).addClass('hx-form-mini');
                this.layoutMini = true;
            }

            /* Attach a namespace to each element. Also create a mapping from field names (no namespace)
             * to types to make it easy to get the value of any field.
             */
            if (!this.options.namespace) {
                this.options.namespace = $(this.element).attr('id');
            }
            
            this._processItems(this.options.items);

            if (this.options.items.length > 0) {
                this.rendered = false;
                this.refresh();
            }
        },
        
        _processItems: function(itemsList) {
            for (var idx = 0; idx < itemsList.length; ++idx) {
                var formElem = itemsList[idx];
                this._typeMap[formElem.name] = formElem.type;
                this._fieldMap[formElem.name] = formElem;
                if (this.options.namespace) {
                    if (formElem.id) {
                        formElem.id = this.options.namespace + "_" + formElem.id;
                    }
                    formElem.name = this.options.namespace + "_" + formElem.name;
                }
                if (formElem.type === 'controlset') {
                    // Control set.
                    this._processItems(formElem.controls);
                } else if (formElem.items) {
                    // Sub panel.
                    this._processItems(formElem.items);
                }
            }
        },
    
        _stripNamespace: function(fldName) {
            return fldName.replace(this.options.namespace + "_", '');
        },
        
        _addNamespace : function(fldName) {
            if (this.options.namespace) {
                return this.options.namespace + "_" + fldName;
            }
            return fldName;
        },
    
        __computeOneHidden: function(formElem, valuesMap) {
            var fldName = this._stripNamespace(formElem.name);
            var oldHidden = formElem.hidden;
            if (valuesMap && fldName in valuesMap) {
                formElem.value = valuesMap[fldName];
            }
            if (formElem.condition) {
                if (valuesMap && formElem.condition in valuesMap) {
                    if (valuesMap[formElem.condition]) {
                        formElem.hidden = false;
                    } else {
                        formElem.hidden = true;
                    }
                } else  {
                    var fn = window[formElem.condition];
                    if(typeof fn === 'function') {
                        formElem.hidden = !(fn.call(this, (valuesMap ? valuesMap : null), fldName));
                    } else {
                        formElem.hidden = true;
                    }
                }
            } else {
                formElem.hidden = false;
            }
            if (oldHidden != formElem.hidden) {
                // Hidden changed.
                return true;
            }
            // Hidden did not change.
            return false;
        },
    
        _computeHidden : function(valuesMap) {
            var idx = 0;
            var i = 0;
            for (idx = 0; idx < this.options.items.length; ++idx) {
                var formElem = this.options.items[idx];
                
                // Process sub items.
                if (formElem.type in this._groupedTypes) {
                    for (i = 0; i < formElem.controls.length; ++i) {
                        var subItem = formElem.controls[i];
                        this.__computeOneHidden(subItem, valuesMap);
                    }
                } else if (formElem.type === 'subPanel') { 
                    for (i = 0; i < formElem.items.length; ++i) {
                        var subpItem = formElem.items[i];
                        this.__computeOneHidden(subpItem, valuesMap);
                    }
                }
                this.__computeOneHidden(formElem, valuesMap);
            }
        },
    
        updateItem: function(name, updatedProperties) {
            var idx = 0;
            for (idx = 0; idx < this.options.items.length; ++idx) {
                var formElem = this.options.items[idx];
                var fldName = this._stripNamespace(formElem.name);
                if (fldName === name) {
                    for (var prop in updatedProperties) {
                        formElem[prop] = updatedProperties[prop];
                    }
                }
            }
        },
    
        /**
         * Render the form using the form layout code. valuesMap is an optional
         * map from field names to field values.
         * 
         * @param valuesMap Map form field names to values.
         */
        refresh: function(valuesMap) { 
            this._computeHidden(valuesMap);
            
            if (!valuesMap) {
                this.__clearValues(this.options.items);
            } else {
                this.__copyValues(this.options.items, valuesMap);
            }
            Helix.Utils.layoutForm(this.element, this.options, this.page, this.layoutMini);
            this.rendered = true;
        },
        
        toggle: function(valuesMap) {
            if (this.options.currentMode === 'edit') {
                this.setView(valuesMap);
            } else {
                this.setEdit(valuesMap);
            }
        },
        
        setView: function (valuesMap) {
            if (this.options.modes !== 'all' &&
                this.options.modes !== 'view') {
                alert("Attempting to set a form to view mode when view mode is not supported.");
            }
            this.options.currentMode = 'view';
            
            if (this.rendered) {
                this.refreshValues(valuesMap ? valuesMap : {}, true);
            } else {
                this.refresh(valuesMap ? valuesMap : {});
            }
        },
        
        setEdit : function(valuesMap) {
            if (this.options.modes !== 'all' &&
                this.options.modes !== 'edit') {
                alert("Attempting to set a form to edit mode when view mode is not supported.");
            }
            this.options.currentMode = 'edit';
            
            if (this.rendered) {
                this.refreshValues(valuesMap ? valuesMap : {}, true);
            } else {
                this.refresh(valuesMap ? valuesMap : {});
            }
        },
        
        isEdit : function() {
            return (this.options.currentMode === 'edit');
        },
        
        isView: function() {
            return !(this.isEdit());
        },
        
        _serializeTypes : {
            "htmlarea" : true,
            "htmlframe" : true,
            "text" : true,
            "textarea" : true,
            "pickList" : true,
            "hidden" : true,
            "checkbox" : true,
            "tzSelector" : true,
            "radio" : true,
            "date" : true,
            "datetime" : true
        },
        
        _groupedTypes: {
            "controlset" : true
        },
        
        serializeItem: function(nxtItem, toSerialize) {
            var fieldID = nxtItem.name;
            var strippedFieldID = this._stripNamespace(fieldID);
            var fieldType = nxtItem.type;
            var selector = '[name="' + fieldID + '"]';
            var _self = this;
            
            var __serializeOneItem = function() {
                if (fieldType === "htmlarea" ||
                    fieldType === "htmlframe") {
                    var $editor = $(this).data('cleditor');
                    if ($editor) {
                        $editor.updateTextArea();
                    }
                    toSerialize.push({
                        name: strippedFieldID,
                        value: $(this).val()
                    });
                } else if (fieldType === "checkbox") {
                    if ($(this).is(":checked")) {
                        toSerialize.push({
                            name : strippedFieldID,
                            value: true
                        }); 
                    } else {
                        toSerialize.push({
                            name : strippedFieldID,
                            value: false
                        }); 
                    }
                } else if (fieldType === "radio") {
                    if ($(this).is(":checked")) {
                        toSerialize.push({
                            name : strippedFieldID,
                            value: $(this).attr('data-value')
                        });
                    }
                } else if (fieldType === "pickList" ||
                           fieldType === "tzSelector") {
                    var selected = $(this).find('option:selected');
                    toSerialize.push({
                            name : strippedFieldID,
                            value: selected.val()
                    });
                } else if (fieldType === "date" ||
                           fieldType === "datetime") {
                    var timeVal = _self._getDateTimeValue(nxtItem.DOM, this, nxtItem.name);
                    toSerialize.push({
                        name: strippedFieldID,
                        value: timeVal
                    });
                } else {
                    toSerialize.push({
                        name : strippedFieldID,
                        value: $(this).val()
                    });
                }
            }
            
            if ($(nxtItem.DOM).is(selector)) {
                __serializeOneItem.call(nxtItem.DOM);
            } else {
                $(nxtItem.DOM).find(selector).each(function() {
                    __serializeOneItem.call(this);
                });
            }
        },
        
        serialize: function() {
            var toSerialize = [];
            var i;
            var subItem;
            for (var idx = 0; idx < this.options.items.length; ++idx) {
                var nxtItem = this.options.items[idx];
                var fieldType = nxtItem.type;
                
                if (fieldType in this._groupedTypes) {
                    // Process sub items.
                    for (i = 0; i < nxtItem.controls.length; ++i) {
                        subItem = nxtItem.controls[i];
                        this.serializeItem(subItem, toSerialize);
                    }
                    // We don't serialize the controlset itself - just its component checkboxes
                    continue;
                } else if (fieldType === 'subPanel') {
                    // Process sub items.
                    for (i = 0; i < nxtItem.items.length; ++i) {
                        subItem = nxtItem.items[i];
                        this.serializeItem(subItem, toSerialize);
                    }
                    // We don't serialize the subPanel itself - just its components
                    continue;
                }
                if (fieldType in this._serializeTypes) {
                    this.serializeItem(nxtItem, toSerialize);
                }
                
                /* All other types are for display - they are not serialized. */
            }
            return $.param(toSerialize);
        },
        
        clear: function() {
            this.__clearValues(this.options.items);
            var mode = (this.options.currentMode === 'edit' ? 1 : 0);
            for (var idx = 0; idx < this.options.items.length; ++idx) {
                var nxtItem = this.options.items[idx];
                if (nxtItem.type === "subPanel") {
                    for (var subidx = 0; subidx < nxtItem.items.length; ++subidx) {
                        var subitem = nxtItem.items[subidx];
                        this.__updateValue(mode,this._stripNamespace(subitem.name),subitem,{});
                    }
                } else{
                    this.__updateValue(mode,this._stripNamespace(nxtItem.name),nxtItem,{});
                }
            }
        },
        
        __updateValue: function(mode, name, item, valuesMap) {
            var value = item.value;
            var thisField = null;
            if (this.rendered) {
                var fldType = item.type;
                var searchName = this._addNamespace(name);

                if (mode) {
                    // This element does not exist in edit mode.
                    if (!item.editDOM) {
                        if (item.DOM) {
                            item.DOM.hide();
                        }
                        if (item.SEPARATOR) {
                            item.SEPARATOR.hide();
                        }
                        return;
                    }
                    item.DOM = item.editDOM;
                    if (item.viewDOM) {
                        item.viewDOM.hide();
                    }
                } else {
                    // This element does not exist in view mode.
                    if (!item.viewDOM) {
                        if (item.DOM) {
                            item.DOM.hide();
                        }
                        if (item.SEPARATOR) {
                            item.SEPARATOR.hide();
                        }
                        return;
                    }
                    
                    item.DOM = item.viewDOM;
                    if (item.editDOM) {
                        item.editDOM.hide();
                    }
                }

                if (item.hidden) {
                    if (item.DOM) {
                        $(item.DOM).hide();
                        if (item.SEPARATOR) {
                            // Hide the HR.
                            $(item.SEPARATOR).hide();
                        }
                    }
                    return;
                } else {
                    $(item.DOM).show();
                    if (item.SEPARATOR) {
                        // Show the HR.
                        $(item.SEPARATOR).show();
                    }
                }
                
                if (item.readOnly) {
                    // No further updating required.
                    return;
                }

                if (fldType === 'date' ||
                    fldType === 'exactdate' ||
                    fldType === 'datetime') {
                    __refreshDate(mode, item);
                } else if (fldType === 'tzSelector') {
                    __refreshTZSelector(mode, item);
                } else if (fldType === 'pickList') {
                    if (mode) {
                        thisField = $(item.DOM).find('[name="' + searchName + '"]');
                        $(thisField).find('option:selected').each(function() {
                            $(this).prop({ selected : false });
                        });
                        $(thisField).find('option[value="' + value + '"]').each(function() {
                            $(this).prop({ selected : true });
                        });
                        $(thisField).selectmenu('refresh');                        
                    } else {
                        __refreshTextBox(mode, item);
                    }
                } else if (fldType === 'checkbox') {
                    __refreshControl(item, false, mode);
                } else if (fldType === 'radio') {
                    __refreshRadioButtons(item);
                } else if (fldType === 'htmlframe') {
                    __refreshHTMLFrame(item);
                } else if (fldType === 'buttonGroup') {
                    __refreshButtonGroup(item);
                } else if (fldType === 'pickList') {
                    __refreshSelectMenu(item);
                } else if (fldType === 'text') {
                    __refreshTextBox(mode, item);
                } else if (fldType === 'textarea') {
                    __refreshTextArea(mode, item);
                } else if (fldType === 'horizontalScroll') {
                    __refreshHorizontalScroll(item);
                } else if (fldType === 'subPanel') { 
                    if (item.panelMode) {
                        if (item.panelMode === 'reverse') {
                            // The sub-panel uses the opposite mode of the parent.
                            mode = (mode ? 0 : 1);
                        } else {
                            mode = (item.panelMode === 'edit' ? 1 : 0);
                        }
                    }
                    for (var idx = 0; idx < item.items.length; ++idx) {
                        var subpItem = item.items[idx];
                        this.__refreshOneValue(mode, subpItem, valuesMap);
                    }
                } else if (fldType === 'controlset') {
                    // Controlset
                    for (idx = 0; idx < item.controls.length; ++idx) {
                        var controlItem = item.controls[idx];
                        /*if (!controlItem.hidden) {
                            $(controlItem.DOM).closest('div.ui-checkbox').show();
                        } else {
                            $(controlItem.DOM).closest('div.ui-checkbox').hide();
                        }*/
                        
                        this.__refreshOneValue(mode, controlItem, valuesMap);
                    }
                } else if (fldType === 'htmlarea') {
                    __refreshHTMLArea(item);
                } else if (fldType === 'separator') {
                    return;
                } else {
                    if (value === undefined) {
                        value = "";
                    }
                    if (mode) {
                        thisField = $(item.DOM).find('[name="' + searchName + '"]');
                        thisField.val(value);
                    } else {
                        thisField = $(item.DOM).find('[data-name="' + searchName + '"]');
                        thisField.html(value);
                    }
                }
            }
        },
        
        __copyOneValue : function(item, valuesMap) {
            var fieldID = item.name;
            var strippedFieldID = this._stripNamespace(fieldID);
            if (!item.readOnly) {
                if (valuesMap[strippedFieldID] !== undefined ||
                    valuesMap['default'] !== undefined) {
                    var newValue = (valuesMap[strippedFieldID] !== undefined ? 
                                        valuesMap[strippedFieldID] : valuesMap['default']);
                    
                    var fldType = item.type;
                    if (fldType !== 'buttonGroup') {
                        item.value = newValue;
                    } else {
                        item.buttons = newValue;
                    }
                    // Value changed.
                    return true;
                }
            }
            // Value did not change.
            return false;
        },
        
        __refreshOneValue: function(mode, item, valuesMap, modeChanged) {
            var hiddenChanged = this.__computeOneHidden(item, valuesMap);
            var valueChanged = this.__copyOneValue(item, valuesMap);
            var visibilityChanged = 
                (mode == 0 && item.mode === 'edit') || 
                (mode == 1 && item.mode === 'view') || 
                (item.type === 'controlset') ||
                modeChanged;
            
            if (hiddenChanged || valueChanged || visibilityChanged) {
                this.__updateValue(mode, this._stripNamespace(item.name), item, valuesMap);
                return true;
            }
            return false;
        },
        
        refreshValues: function(valuesMap, modeChanged) {
            var mode = (this.options.currentMode === 'edit' ? 1 : 0);
            for (var idx = 0; idx < this.options.items.length; ++idx) {
                var nxtItem = this.options.items[idx];
                if (nxtItem.type === "subPanel") {
                    if (!this.__refreshOneValue(mode,nxtItem,valuesMap)) {
                        for (var subidx = 0; subidx < nxtItem.items.length; ++subidx) {
                            var subitem = nxtItem.items[subidx];
                            this.__refreshOneValue(mode,subitem,valuesMap,modeChanged);
                        }                        
                    }
                } else{
                    this.__refreshOneValue(mode, nxtItem, valuesMap,modeChanged);
                }
            }
        },
        
        __copyValues: function(items, valuesMap) {
            for (var idx = 0; idx < items.length; ++idx) {
                var nxtItem = items[idx];
                this.__copyOneValue(nxtItem, valuesMap);
                if (nxtItem.type === 'subPanel') {
                    this.__copyValues(nxtItem.items, valuesMap);
                }
            }
        },
        
        __clearOneValue : function(item) {
            if (!item.readOnly) {
                var fldType = item.type;
                if (fldType !== 'buttonGroup') {
                    item.value = null;
                } else {
                    item.buttons = null;
                }
            }
        },
        
        __clearValues: function(items) {
            for (var idx = 0; idx < items.length; ++idx) {
                var nxtItem = items[idx];
                this.__clearOneValue(nxtItem);
                if (nxtItem.type === 'subPanel') {
                    this.__clearValues(nxtItem.items);
                } else if (nxtItem.type === 'controlset') {
                    // controlset or radio
                    this.__clearValues(nxtItem.controls);
                }
            }
        },
        
        setValue: function(name, value) {
            var item;
            for (var idx = 0; idx < this.options.items.length; ++idx) {
                item = this.options.items[idx];
                var fieldID = item.name;
                var strippedFieldID = this._stripNamespace(fieldID);

                if (name === strippedFieldID) {
                    break;
                }
            }
            if (!item) {
                return;
            }
            
            var mode = (this.options.currentMode === 'edit' ? 1 : 0);
            var valuesObj = {};
            valuesObj[name] = value;
            this.__refreshOneValue(mode, item, valuesObj);
        },
        
        _getDateTimeValue: function(parentDOM, fld, searchName) {
            var dateObj = $(fld).datebox("get");
            if (!dateObj) {
                return 0;
            }
            
            dateObj = dateObj.clone();
            var timeElem = $(parentDOM).find('[name="' + searchName + '_time"]');
            if (timeElem.length > 0) {
                var timeObj = timeElem.data('mobile-datebox');
                dateObj.set({
                    hour : timeObj.theDate.getHours(),
                    minute: timeObj.theDate.getMinutes()
                });           
            }
            return dateObj.getTime();
        },
        
        getValue: function(name) {
            var fld = this._fieldMap[name];
            if (!fld) {
                return null;
            }
            if (!fld.name) {
                // Cannot get the value of name-less fields.
                return null;
            }
            
            var searchName = this._addNamespace(name);
            
            var fldSelector = '[name="' + searchName + '"]';
            var thisField;
            if ($(fld.DOM).is(fldSelector)) {
                thisField = $(fld.DOM);
            } else {
                thisField = $(fld.DOM).find(fldSelector);
            }
            var fldType = this._typeMap[name];
            
            // Checkboxes and radios are handled the same regardless of mode.
            if (fldType === 'checkbox') {
                if ($(thisField).is(":checked")) {
                    return true;
                }
                return false;
            } else if (fldType === 'radio') {
                var checked = $(fld.DOM).find(':checked');
                if (checked.length > 0) {
                    return checked.attr('data-value');
                }
                return null;
            }
            
            var mode = (this.options.currentMode === 'edit' ? 1 : 0);
            if (!mode) {
                return $(fld.DOM).find('[data-name="' + fld.name + '"]').html();
            }
            
            if (fldType === 'date' ||
                fldType === 'exactdate' ||
                fldType === 'datetime') {
                var timeVal = this._getDateTimeValue(fld.DOM, thisField, searchName);
                if (timeVal > 0) {
                    return new Date(timeVal);
                }
                return null;
            } else if (fldType === 'tzSelector' ||
                       fldType === 'pickList') {
                var selected = $(thisField).find('option:selected');
                if (selected.length > 0) {
                    return selected.val();
                }
            } else {
                return thisField.val();
            }
            
            return null;
        },
        
        getValues: function() {
            var obj = {};
            for (var fieldID in this._fieldMap) {
                obj[fieldID] = this.getValue(fieldID);
            }
            
            return obj;
        },
        
        getFieldElement: function(name) {
            var fld = this._fieldMap[name];
            var ret = null;
            if (fld) {
                if (!fld.name) {
                    return fld.DOM;
                }
                
                if (fld.type === 'radio') {
                    // The radio field is the container itself.
                    return fld.DOM;
                } 
                
                
                var nameAttribute = '[name="' + fld.name + '"]';
                ret = $(fld.DOM).find('input'+nameAttribute+",textarea"+nameAttribute);
                if (ret.length == 0) {
                    ret = $(fld.DOM).find('[data-name="' + fld.name + '"]');
                }
                if (ret.length == 0) {
                    ret = $(fld.DOM);
                }
                
                return ret;
            }
            return null;
        },
        
        disableField: function(name) {
            var fieldElem = this.getFieldElement(name);
            if (fieldElem && fieldElem.is('input')) {
                fieldElem.addClass('ui-disabled');
            }
        },
        
        enableField: function(name) {
            var fieldElem = this.getFieldElement(name);
            if (fieldElem && fieldElem.is('input')) {
                fieldElem.removeClass('ui-disabled');
            }
        },
        
        _checkNonEmpty: function(val) {
            if (val) {
                return true;
            }  
            
            return false;
        },
        
        _checkNotPast: function(val) {
            // Val should be a date object
            if (!val.getTime && isNaN(val)) {
                // Not a date object.
                return false;
            }
            
            if (!val.getTime) {
                val = new Date(parseInt(val));
            }
            return !(val.isBefore(new Date()));
        },
        
        save: function () {
            var idx = 0;
            for (idx = 0; idx < this.options.items.length; ++idx) {
                var nxtItem = this.options.items[idx];
                var fieldID = nxtItem.name;
                var fieldType = nxtItem.type;
                if (fieldType !== 'htmlarea') {
                    /* Other types don't require an explicit save. */
                    continue;
                }
                $(this.element).find('textarea[name="' + fieldID + '"]').each(function() {
                    var $editor = $(this).data('cleditor');
                    if ($editor) {
                        $editor.updateTextArea();
                    }
                });
            }
        },
        
        validate: function() {
            var idx = 0;
            var validationErrors = {};
            for (idx = 0; idx < this.options.items.length; ++idx) {
                var nxtItem = this.options.items[idx];
                var fieldID = nxtItem.name;
                var strippedFieldID = this._stripNamespace(fieldID);
                var fieldType = nxtItem.type;
                if (!(fieldType in this._serializeTypes)) {
                    /* All other types are unserializable. */
                    continue;
                }
                
                var validator = null;
                // Determine the validator function.
                if (nxtItem.validator) {
                    if (Helix.Utils.isString(nxtItem.validator)) {
                        if (nxtItem.validator === 'notempty') {
                            validator = this._checkNonEmpty;
                        } else if (nxtItem.validator === 'notpast') {
                            validator = this._checkNotPast;
                        }
                    } else {
                        validator = nxtItem.validator;
                    }
                } else {
                    continue;
                }
                
                $(this.element).find('[name="' + fieldID + '"]').each(function() {
                    var toValidate = "";
                    if (fieldType === "htmlarea") {
                        var $editor = $(this).data('cleditor');
                        if ($editor) {
                            $editor.updateTextArea();
                        }
                        toValidate = $(this).val();
                    } else if (fieldType === "checkbox") {
                        if ($(this).is(":checked")) {
                            toValidate = true;
                        } else {
                            toValidate = false;
                        }
                    } else if (fieldType === "pickList" ||
                               fieldType === "tzSelector") {
                        var selected = $(this).find('option:selected');
                        toValidate = selected.val();
                    } else {
                        toValidate = $(this).val();
                    }
                    if (!validator.call(this, toValidate)) {
                        // Validation failed.
                        validationErrors[strippedFieldID] = nxtItem;
                    }
                });
            }
            return validationErrors;
        }
    });
}( jQuery ));;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function($) {
    
    $.widget("helix.helixScrollingDiv", {        
        
        options: {
            
            /**
             * Direction we are scrolling - either 'vertical' (the default) or
             * 'horizontal.
             */
            orientation: "vertical",
            
            /**
             * Boolean value indicating if double-tab to zoom is available inside
             * of this scroller. Default is false.
             */
            isZoom: false,
            
            /**
             * Width of the scroller. Specify as a string, either indicating pixels
             * or a percentage. Default is to occupy the full width of the content
             * view (specified as either the page width or the parent element marked
             * with the hx-main-content class. Specify this behavior with 'full'.
             */
            width: "full",
            
            /**
             * Fixed height of the scroller. Content inside the scrolling div
             * will scroll within the boundaries specified by the width and height
             * parameters. Like width, specify as a string indicating the pixel
             * width or the percentage width. The default is to use the height
             * already attached to the wrapped element. Specify this behavior
             * with 'inherit'.
             */
            height: "inherit"
        },

        _create: function() {
            /* Insert the wrapper around this.element. The wrapper has fixed size, and
             * the transform styles are applied to this.element. 
             */
            this.element.wrap('<div/>');
            this._$wrapper = this.element.parent();
            
            /* Attach a unique ID to the wrapper. Our scroller framework requires that
             * elements have an ID.
             */
            this._$wrapper.attr('id', Helix.Utils.getUniqueID());
            
            this.refresh();
        },
    
        /**
         * Create the scrolling container and mark with the appropriate styles.
         * Attach an iScroll scroller to the div, or refresh the scroller if 
         * it already exists.
         */
        refresh: function() {    
            this._$parentView = $(this.element).closest(".hx-main-content");
            this._$page = $(this.element).closest('[data-role="page"]');
            if (this._$parentView.length == 0) {
                this._$parentView = this._$page;
            }
            
            /* Set the height/width of the scroller wrapper. */
            if (this.options.width === "full") {
                this._$wrapper.width(this._$parentView.width());
            } else if (this.options.width !== "auto") {
                this._$wrapper.width(this.options.width);
            }
            if (this.options.height === "inherit") {
                /* The height of this component is fixed and should be inherited
                 * according to the form layout scheme. If the wrapper has not
                 * yet had its height specified then we invoke layoutPage to
                 * do so.
                 */
                if (!this._$wrapper.hasClass('mh-layout-parent-height')) {
                    this._$wrapper.addClass('mh-layout-parent-height');
                    Helix.Layout.layoutPage(this._$page);
                }
            } else {
                this._$wrapper.height(this.options.height);
            }
            
            
            /* Determine the scroller type and add/refresh the scroller. */
            var scrollingClass;
            if (this.options.orientation === "vertical") {
                scrollingClass = "hx-scroller-nozoom hx-no-hscroll";
            } else if (this.options.orientation === "horizontal") {
                scrollingClass = "hx-horizontal-scroller-nozoom hx-no-vscroll";
            } else {
                console.log("Invalid scroller orientation " + this.options.orientation);
                return;
            }
            
            var zoomClass = "";
            if (this.options.zoom) {
                // Not supported at this moment.
                //zoomClass = "pm-scroller-nozoom";
            }
            
            if (this._$wrapper.hasClass(scrollingClass)) {
                /* Refresh the scroller. */
                //Helix.Layout.updateScrollers(this._$wrapper);
            } else {
                this._$wrapper.addClass(scrollingClass);
                if (zoomClass) {
                    this._$wrapper.addClass(zoomClass);
                }
                //Helix.Layout.addScrollers(this._$wrapper);
            }
        },
        
        /**
         * Call this function when the scroller contents have changed to just
         * refresh the iScroll scroller.
         */
        refreshScroller: function() {
            //Helix.Layout.updateScrollers(this._$wrapper);
        },
        
        /**
         * Call this function to remove this element from the DOM. Removes the
         * wrapper.
         */
        remove: function () {
            this._$wrapper.remove();
        },
        
        destroy: function() {
            //Helix.Layout.cleanupScrollers(this._$wrapper.parent());
        }
    });
}( jQuery ));;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function($) {
    
    $.widget("helix.helixSplitView", {        
        
        options: {
            /**
             * Left width. Specify an integer, which translates into the % of the full
             * width occupied by the left-hand pane.
             */
            leftWidth: 30,
            
            /**
             * Right width. Specify an integer, which translates into the % of the full
             * widht occupied by the right-hand pane.
             */
            rightWidth: 70,
            
            /**
             * Padding (in pixels) between the left and right sides of the split view.
             */
            splitPadding: 5,
            
            /**
             * Specify a threshold in width pixels, above which both panes of the split view
             * should be visible on the screen.
             */
            splitThreshold: 800,
            
            /**
             * Callback to invoke after each refresh. This allows the app using this component
             * to change the UI based on whether the split view is full screen or side-by-side.
             * The callback is passed a single string as an argument - either 'split' or 'full', 
             * depending on whether the split view is showing as a split view or as two full
             * screen views.
             */
            onRefresh: null,
            
            /**
             * Boolean flag that indicates if the split view should use header buttons to navigate
             * between the right and left panes in the single-pane view. A typical scenario is to have
             * a list in the left pane that, when an item is tapped, updates the right pane to show detail
             * of the selected item. In this scenario, you would use this flag to have the jQM header's 
             * left button say "Close" and toggle from the right pane back to the left. The default value
             * is true.
             */
            useHeaderToToggle: true,
            
            /**
             * A string that is used for the text in the toggle button when useHeaderToToggle is set to true.
             * The default is 'Close'.
             */
            headerToggleText: "Close"
        },

        _create: function() {
            // Setup styling of the parent element.
            $(this.element).addClass('pm-layout-full-height');
        
            // Get the left/right.
            this.__left = $(this.element).children()[0];
            this.__right = $(this.element).children()[1];
            
            if (this.options.useHeaderToToggle) {
                // Get the enclosing page.
                this.__page = $(this.element).closest('[data-role="page"]');
            
                // Get the header element in the enclosing page, if it exists.
                this.__pageHeader = $(this.__page).find('[data-role="header"]')
            }
            
            if (!this.__left || !this.__right) {
                alert("A split view must have two children, representing the left and right portions of the split.");
            }
            
            if (Helix.hasTouch) {
                this.__clickEvent = 'tap';
            } else {
                this.__clickEvent = 'click';
            }
            
            this.__restoreMarkup = null;
            this.__current = null;
            this.refresh();
            var _self = this;
            $( document ).on( "orientationchange", function( event ) {
                _self.refresh();
                // In case we were viewing the right pane of the split when we
                // rotated back to a split view with 2 panes.
                _self._restoreLeftHeaderButton();
            });
        },
        
        _restoreLeftHeaderButton: function() {
            if (this.options.useHeaderToToggle && this.__pageHeader.length > 0 && this.__restoreMarkup) {
                // Remove or restore the left button depending on whether or
                // not there was a left button before we toggled.
                var curLeftBtn = $(this.__pageHeader).find('.ui-btn-left');
                if (curLeftBtn.length > 0) {
                    $(curLeftBtn).remove();
                }

                // Insert or update the left button.
                $(this.__pageHeader).prepend(this.__restoreMarkup);
                this.__restoreMarkup = null;
            }
        },
    
        /**
         * Render the form using the form layout code. valuesMap is an optional
         * map from field names to field values.
         * 
         * @param valuesMap Map form field names to values.
         */
        refresh: function() {            
            var curWidth = $(window).width();
            var curLeftBtn = null;
            var __self = this;
            if (curWidth > this.options.splitThreshold) {
                var leftWidth = Math.floor((this.options.leftWidth / 100) * curWidth);
                var rightWidth = Math.floor((this.options.rightWidth / 100) * curWidth) - this.options.splitPadding;
               
                $(this.element).addClass('hx-split-master');
            
                $(this.__left).addClass('hx-split-left-area').addClass('pm-layout-full-height');
                $(this.__left).width(leftWidth);
                $(this.__right).addClass('hx-split-right-area').addClass('pm-layout-full-height');
                $(this.__right).width(rightWidth);
                
                $(this.__left).show();
                $(this.__right).show();
                
                this.__current = null;
            } else {
                if (!this.__current) {
                    this.__current = "left";
                }
                
                if (this.__current === "left") {
                    $(this.__left).removeClass('hx-split-left-area');
                    $(this.__left).addClass('hx-split-full');
                    $(this.__left).addClass('pm-layout-full-height');
                    $(this.__left).css('width', '');
                    $(this.__left).show();
                    $(this.__right).hide();
                    
                    this._restoreLeftHeaderButton();
                } else {
                    $(this.__right).removeClass('hx-split-right-area');
                    $(this.__right).addClass('hx-split-full');
                    $(this.__right).addClass('pm-layout-full-height');
                    $(this.__right).css('width', '');
                    $(this.__right).show();
                    $(this.__left).hide();
                    
                    if (this.options.useHeaderToToggle && this.__pageHeader.length > 0) {
                        // Capture the current left button so that we can restore it.
                        var theme;
                        curLeftBtn = $(this.__pageHeader).find('.ui-btn-left');
                        if (curLeftBtn.length > 0) {
                            this.__restoreMarkup = $(curLeftBtn);
                            theme = $(curLeftBtn).attr('data-theme');
                            $(curLeftBtn).remove();
                        }
                        if (!theme) {
                            theme = 'a';
                        }
                        
                        // Insert or update the left button.
                        $(this.__pageHeader).prepend($('<a/>').attr({
                            'href' : 'javascript:void(0)',
                            'class' : 'ui-btn-left',
                            'data-theme' : theme,
                            'data-icon' : 'back'
                        }).append(this.options.headerToggleText).on(this.__clickEvent, function(ev) {
                            __self.toggle();
                            return false;
                        }).button());
                    }
                }
            }
            if (this.options.onRefresh) {
                this.options.onRefresh((this.__current) ? "full" : "split");
            }
        },
        
        toggle: function() {
            if (!this.__current) {
                return;
            }
            if (this.__current === "left") {
                this.__current = "right";
            } else {
                this.__current = "left";
            }
            this.refresh();
            
            Helix.Layout.refresh();
            Helix.Layout.layoutPage($.mobile.activePage, true);
        },
        
        showRight: function() {
            if (!this.__current) {
                return;
            }
            if (this.__current === "left") {
                this.__current = "right";
                
                this.refresh();
            
                Helix.Layout.refresh();
                Helix.Layout.layoutPage($.mobile.activePage, true);
            } else {
                /* Do nothing. We are already on the right. */
            }
        },
        
        showLeft: function() {
            if (!this.__current) {
                return;
            }
            if (this.__current === "right") {
                this.__current = "left";
                
                this.refresh();
            
                Helix.Layout.refresh();
                Helix.Layout.layoutPage($.mobile.activePage, true);
            } else {
                /* Do nothing. We are already on the right. */
            }
        },
        
        isSplitView: function() {
            return (this.__current == null);
        },
        
        getLeft: function() {
            return $(this.__left);
        },
        
        getRight: function() {
            return $(this.__right);
        }
    });
}( jQuery ));;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Utility functions.
 * 
 * @author Seth Hallem
 */
Helix.Utils =  {
    currentUniqueID : 0,
    
    getPosition : function (element) {
        var xPosition = 0;
        var yPosition = 0;

        while(element) {
            xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
            element = element.offsetParent;
        }
        return { x: xPosition, y: yPosition };
    },
    
    growl : function(summary, msg, severity, lifetime) {
        if (!lifetime) {
            lifetime = 10000;
        }
        
        var growlContainer = $('<div/>');
        var growl = growlContainer.helixGrowl({
            msgs: [
                { summary : summary, detail: msg, severity: severity }
            ],
            life : lifetime
        }).data('helix-helixGrowl');
        $(growlContainer).on('tap', function() {
            growl.removeAll(); 
        });
        return growl;
    },
    
    statusMessage : function(summary, msg, severity, lifetime) {
        if (Helix.Utils.errorGrowl) {
            Helix.Utils.errorGrowl.show([
                { summary : summary, detail: msg, severity: severity }
                ]);
        } else {
            Helix.Utils.errorGrowl = Helix.Utils.growl(summary, msg, severity, lifetime);
        }
        if (severity == 'error') {
            console.log('[ERROR] ' + msg);
        }
    },
    paginator: {
        
        PAGINATOR_PREV_PAGE_LINK_CLASS : "ui-paginator-prev ui-state-default ui-corner-all",
        PAGINATOR_PREV_PAGE_ICON_CLASS : "ui-icon ui-icon-back",
        PAGINATOR_NEXT_PAGE_LINK_CLASS : "ui-paginator-next ui-state-default ui-corner-all",
        PAGINATOR_NEXT_PAGE_ICON_CLASS : "ui-icon ui-icon-forward",
        PAGINATOR_TOP_CONTAINER_CLASS : "ui-paginator ui-paginator-top ui-widget-header",
        PAGINATOR_CURRENT_CLASS : "ui-paginator-current",
        
        currentPageDefaultTemplate : "({currentPage} of {totalPages})",
        
        renderers: {
            '{CurrentPageReport}' : function(obj, params) {
                if (!params.template) {
                    params.template = Helix.Utils.paginator.currentPageDefaultTemplate;
                }
                
                var startItem = 1;
                var totalPages = params.totalPages;
                var endItem = params.itemsPerPage;
                if (params.page >= 0) {
                    startItem = (params.itemsPerPage * params.page) + 1;
                    endItem = startItem + params.itemsPerPage;
                }
                if (endItem > params.totalItems) {
                    endItem = params.totalItems;
                }
                var output = params.template.replace("{currentPage}", params.page + 1)
                    .replace("{totalPages}", totalPages)
                    .replace("{totalRecords}", params.totalItems)
                    .replace("{startRecord}", startItem)
                    .replace("{endRecord}", endItem);

                obj.append($('<span />').attr({ 
                        'class' : Helix.Utils.paginator.PAGINATOR_CURRENT_CLASS 
                    }).append(output)
                );
            },
            '{PreviousPageLink}' : function(obj, params) {
                var output = $('<span />')
                    .attr({
                        'class' : Helix.Utils.paginator.PAGINATOR_PREV_PAGE_LINK_CLASS
                    }).append($('<div />')
                        .attr({
                            'class' : Helix.Utils.paginator.PAGINATOR_PREV_PAGE_ICON_CLASS
                        }).append("&nbsp;")
                    );
                $(output).on(Helix.clickEvent, function(ev) {
                    ev.stopImmediatePropagation();
                    params.prevPage.apply(params.owner);
                    return false;
                });
                obj.append(output);
            },
            '{NextPageLink}' : function(obj, params) {
                var totalPages = Math.floor(params.totalItems / params.itemsPerPage) + 1;
                var output = $('<span />')
                    .attr({
                        'class' : Helix.Utils.paginator.PAGINATOR_NEXT_PAGE_LINK_CLASS
                    }).append($('<div />')
                        .attr({
                            'class' : Helix.Utils.paginator.PAGINATOR_NEXT_PAGE_ICON_CLASS
                        }).append("&nbsp;")
                    );
                $(output).on(Helix.clickEvent, function(ev) {
                    ev.stopImmediatePropagation();
                    params.nextPage.apply(params.owner, [ totalPages ]);
                    return false;
                });
                obj.append(output);
            }
        },
        render: function(renderer, obj, params) {
            // Compute total pages if it is not supplied.
            if (!params.totalPages) {
                if ((params.totalItems % params.itemsPerPage) == 0) {
                    params.totalPages = params.totalItems / params.itemsPerPage;
                } else {
                    params.totalPages = Math.floor(params.totalItems / params.itemsPerPage) + 1;
                }
            }
            if (Helix.Utils.paginator.renderers[renderer]) {
                Helix.Utils.paginator.renderers[renderer](obj, params);
            }
        }
    },
    getUniqueID : function() {
        ++Helix.Utils.currentUniqueID;
        return "pm_idt" + Helix.Utils.currentUniqueID;
    },
    escapeQuotes : function(str) {
        return str.replace(/"/g, "&quot;");
    },
    isString: function(x) {
        return typeof x == "string" || (typeof x == "object" && x.constructor === String);
    },
    objectsEqual: function(obj1, obj2) {
        for (var x in obj1) {
            if (!(x in obj2)) {
                return false;
            }
            if (obj1[x] != obj2[x]) {
                return false;
            }
        }
        
        // At this point, all properties in obj1 are in obj2 and all are equivalent
        // We need to make sure obj2 doesn't have any fields not in obj1.
        for (x in obj2) {
            if (!(x in obj1)) {
                return false;
            }
        }
        
        return true;
    },
    endsWith: function(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    },
    sizeIFrameToFit: function(frameID, parentID, sizeContentsToFit) {
        // Rewrite all links in the message body to open a new tab.
        var frame = document.getElementById(frameID);
        if (!frame) {
            return;
        }
        var frameHeight = null;
        var screenWidth = null;
        
        if (parentID) {
            var parent = document.getElementById(parentID);
            frameHeight = parent.clientHeight;
            screenWidth = parent.clientWidth;
        } else {
            frameHeight = frame.contentWindow.document.body.scrollHeight;
            screenWidth = screen.width;
        }

        // First resize the iframe.
        var frameWidth = frame.contentWindow.document.body.scrollWidth;

        // Now scale it if the width is greater than the screen width.
        if (frameWidth > screen.width && sizeContentsToFit) {
            var scalingFactor = screen.width / frameWidth;
            $(frame.contentWindow.document.body).closest('html')
                .css('-webkit-transform-origin', '0 0')
                .css('-webkit-transform', 'scale(' + scalingFactor + ')');
            frame.height = (frameHeight * scalingFactor * 1.01) + "px";
        } else {
            frame.height= (frameHeight) + "px";
        }
        frame.width= (screenWidth) + "px";
    },
    isPhone: function() {
        if (Helix.Utils._isPhone === undefined) {
            if (navigator.userAgent.toLowerCase().match(/iphone/)) {
                Helix.Utils._isPhone = true;
            } else {
                // XXX: need to extend to more phones as we support them.
                Helix.Utils._isPhone = false;
            }
        }
        
        return Helix.Utils._isPhone;
    }
};/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Ajax functions.
 * 
 * @author Seth Hallem
 */

/**
 * Override the existing AJAX request handler to add a new pre-request trigger.
 */
(function() {
    if (!PrimeFaces || !PrimeFaces.ajax) {
        return;
    }
    PrimeFaces.ajax.origRequest = PrimeFaces.ajax.AjaxRequest;
    PrimeFaces.ajax.AjaxRequest = function(cfg, ext) {
        $(document).trigger('prerequest', cfg);

        /**
         * Override the existing AJAX oncomplete handler to add a new post-request trigger.
         * This allows us to trigger the event after ALL updates and callbacks are done.
         */
        var origComplete;
        if (ext) {
            origComplete = ext.oncomplete;        
        } else {
            ext = {};
        }
        ext.oncomplete = function(xhr, status, args) {
            if (origComplete) {
                origComplete.call(this, xhr, status, args);
            }
            $(document).trigger('postrequest', xhr);
        };
        PrimeFaces.ajax.origRequest.call(this, cfg, ext);
    }
})();

/**
 * Show a loader pre-request.
 */
$(document).bind('prerequest', function() {
    $.mobile.loading( 'show', Helix.Ajax.loadOptions);
    if (window.CordovaInstalled) {
        window.HelixSystem.suspendSleep();
    }
    Helix.Ajax.loadCt++;
});

/**
 * Hide the loader post-request.
 */
$(document).bind('postrequest', function() {
    if (!Helix.Ajax.loadOptions.pin) {
        /* Hide the loader. */
        $.mobile.loading( "hide" );
        if (window.CordovaInstalled) {
            window.HelixSystem.allowSleep();
        }
    }

    /* Clear out the load options - this is meant as a per-load set of options. */
    Helix.Ajax.loadOptions = {};
    Helix.Ajax.loadCt--;
});

/**
 *
 */
$(document).ready(function() {
    if (Helix.Ajax.loadCt > 0) {
        $.mobile.loading( 'show', Helix.Ajax.loadOptions);    
    }
});

/**
 * Capture offline/online transitions driven by the Cordova container.
 */
$(document).on('__hxOnline', function() {
    window.__hxOnLine = true;
});

$(document).on('__hxOffline', function() {
    window.__hxOnLine = false;
});

/**
* Execute an AJAX load from a backing bean. This command is specifically used to
* load a JSON-serialized object using the new PrimeFaces "ClientData" annotations.
* These objects, once loaded, are synchronized to local storage. If the browser
* is offline when this function is invoked, then the objects are automatically
* loaded from local storage rather than going back to the server.
*/
Helix.Ajax = {
    /**
     * Error codes
     */
    ERROR_OFFLINE_ACCESS : { code: 0, msg: "Cannot load this object while offline." },
    ERROR_INVALID_PARAMS : { code : 1, msg: "Parameters to an AJAX bean load must be an array of objects, each of the form { name:'<name>', value:<value> }." },
    ERROR_AJAX_LOAD_FAILED : { code : 2, msg : "AJAX load error." },

    /**
     * Count of on-going loads.
     */
    loadCt : 0,

    /**
     * Options specifying the appearance of the loading message, which is displayed
     * automatically during all AJAX loads.
     */
    loadOptions: {
        pin : false
    },
    
    /**
     * Global map that maintains all config for each load command. This allows us to
     * easily create aggregate load commands.
     */
    loadCommands: {
        
    },
    
    isDeviceOnline : function() {
        if (Helix.Ajax.forceDeviceOffline) {
            return false;
        }
        if (Helix.Ajax.forceDeviceOnline) {
            return true;
        }
        
        //alert("ONLINE2: " + window.__hxOnLine);
        if (window.__hxOnLine !== undefined) {
            return window.__hxOnLine;
        }
        
        return navigator.onLine;
    },
    
    /**
     * Show a loader with a text message.
     * 
     * @param msg Text message to show.
     * @param theme jQuery Mobile theme (optional, defaults to "a")
     */
    showLoader: function(msg, theme) {
        if (!theme) {
            theme = "a";
        }
        $.mobile.loading('show', {
            text: msg, 
            textVisible: true,
            theme: theme,
            textonly: false
        });
    },
    
    /**
     * Helper companion to showLoader. Hides the loader.
     */
    hideLoader: function() {
        $.mobile.loading('hide');
    },
    
    /*
     * Helper used to set loader options.
     */
    setLoaderOptions: function(loadingOptions) {
        if (!loadingOptions.theme) {
            loadingOptions.theme = "a";
        }
        if (loadingOptions.message) {
            Helix.Ajax.loadOptions= {
                text: loadingOptions.message, 
                textVisible: true,
                theme: loadingOptions.theme,
                textonly: false
            };
        } else {
            Helix.Ajax.loadOptions = {
                textVisible: false,
                theme: loadingOptions.theme
            };
        }
    },
    
    defaultOnError: function(errorObj) {
        Helix.Utils.statusMessage("Load Failed", errorObj.msg, "error");  
    },
    
    /**
     * Used to run a single load command that turns the results of multiple other load commands.
     * 
     * @param loadCommandOptions Parameters for this load command, including request options, loading
     * options, and commands - an array of objects each of which has a 'name' and an optional 'key' field.
     * The name is the name of the load command. The key is the itemKey used to synchronize this particular
     * item when the browser is offline.
     */
    ajaxAggregateLoad : function(loadCommandOptions) {
        var nObjsToSync = loadCommandOptions.commands.length;
        var nSchemasReady = 0;
        var schemaDone = function(schema, cfg) {
            cfg.schema = schema;
            if (nSchemasReady == nObjsToSync) {
                Helix.Ajax._executeAggregateLoad(loadCommandOptions);
            }
        };
        
        // Make sure we have schema objects for each load command.
        for (var i = 0; i < nObjsToSync; ++i) {
            var commandToLaunch = loadCommandOptions.commands[i].name;
            var commandConfig = Helix.Ajax.loadCommands[commandToLaunch];
            if (!commandConfig.schema) {
                commandConfig.schemaFactory(function(schema, cfg) {
                    ++nSchemasReady;
                    schemaDone(schema, cfg);
                }, [commandConfig]);
            } else {
                ++nSchemasReady;
                schemaDone(commandConfig.schema, commandConfig);
            }
        }
    },
    
    _executeAggregateLoad: function(loadCommandOptions) {
        // Execute the aggregate load.
        var nObjsToSync = loadCommandOptions.commands.length;
        var keyMap = {};
        
        loadCommandOptions.oncomplete = function(finalKey, name, obj) {
            for (var syncComponent in obj) {
                if (syncComponent == "__hx_schema") {
                    continue;
                }
                
                var config = Helix.Ajax.loadCommands[syncComponent];
                window[config.name] = obj[syncComponent];
                if (config.oncomplete) {
                    config.oncomplete(keyMap[config.name], config.name, obj[syncComponent], true);
                }
            }
        };
        if (Helix.Ajax.isDeviceOnline()) {
            loadCommandOptions.syncOverrides = {};
            loadCommandOptions.syncOverrides.schemaMap = {};
            for (var i = 0; i < nObjsToSync; ++i) {
                var commandToLaunch = loadCommandOptions.commands[i].name;
                keyMap[commandToLaunch] = loadCommandOptions.commands[i].key;
                
                var commandConfig = Helix.Ajax.loadCommands[commandToLaunch];
                loadCommandOptions.syncOverrides.schemaMap[commandToLaunch] = commandConfig;
            }
            Helix.Ajax.ajaxBeanLoad(loadCommandOptions);
        } else {
            var completions = [];
            
            // Run each item individually and synchronously.
            var syncComplete = function(idx) {
                if (idx < nObjsToSync) {
                    commandToLaunch = loadCommandOptions.commands[idx].name;
                    commandConfig = Helix.Ajax.loadCommands[commandToLaunch];
                    var itemKey = loadCommandOptions.commands[idx].key;
                    var completeObj = {
                        fn: loadCommandOptions.oncomplete,
                        thisArg: loadCommandOptions
                    };
                    loadCommandOptions.oncomplete = function(finalKey, name, finalObj) {
                        completeObj.args = [ finalKey, name, finalObj ];
                        completions.push(completeObj);
                        loadCommandOptions.oncomplete = completeObj.fn;
                    };
                    Helix.Ajax.synchronousBeanLoad(commandConfig,itemKey,syncComplete,++idx);
                } else {
                    for (var i = 0; i < nObjsToSync; ++i) {
                        if (completions[i].fn) {
                            completions[i].fn.apply(completions[i].thisArg, completions[i].args);                        
                        }
                    }
                }
            };

            syncComplete(0);
        }
    },
    
    synchronousBeanLoad: function(loadCommandOptions, itemKey, onComplete, opaque) {
        var origOncomplete = loadCommandOptions.oncomplete;
        loadCommandOptions.oncomplete = function(finalKey, name, finalObj) {
            if (origOncomplete) {
                origOncomplete(finalKey, name, finalObj);
            }
            onComplete(opaque);
            loadCommandOptions.oncomplete = origOncomplete;
        };
        Helix.Ajax.ajaxBeanLoad(loadCommandOptions, itemKey);
    },
    
    ajaxBeanLoad : function(loadCommandOptions,itemKey,nRetries) {        
        // Set a default error handler if we do not have one.
        if (!loadCommandOptions.onerror) {
            loadCommandOptions.onerror = Helix.Ajax.defaultOnError;
        }
        if (loadCommandOptions.onstart) {
            loadCommandOptions.onstart(loadCommandOptions.name);
        }
        
        // Setup loader options and show the loader.
        Helix.Ajax.setLoaderOptions(loadCommandOptions.loadingOptions);
        //$.mobile.loading( 'show', Helix.Ajax.loadOptions);
        
        // Make sure the DB is ready. If not, wait 5 seconds.
        if (!Helix.DB.persistenceIsReady()) {
            if (!nRetries) {
                nRetries = 1;
            }
            // Wait 2s and try again.
            if (nRetries > 3) {
                alert("Failed to prepare the synchronization layer. Please contact your administrator.");
                return;
            }
            setTimeout(function() {
                Helix.Ajax.ajaxBeanLoad(loadCommandOptions,itemKey,nRetries+1);
            }, 1000);
            return;
        }
        
        if (!loadCommandOptions.requestOptions.params) {
            loadCommandOptions.requestOptions.params = [];
        }
        if (!loadCommandOptions.requestOptions.params.push) {
            // the request options are not an array ...
            loadCommandOptions.onerror(Helix.Ajax.ERROR_INVALID_PARAMS)
            return;
        }
        loadCommandOptions.requestOptions.params.push({
            name: "__hxLoadKey",  
            value: loadCommandOptions.requestOptions.loadKey
        });

        if (!Helix.Ajax.isDeviceOnline()) {
            // Use the key to sync from the local DB.
            if (itemKey) {
                Helix.DB.synchronizeObjectByKey(itemKey,loadCommandOptions.schema,function(widget) {
                    window[loadCommandOptions.name] = widget;
                    loadCommandOptions.oncomplete(itemKey, loadCommandOptions.name, widget);
                },loadCommandOptions.syncOverrides);
            } else if (itemKey == null) {
                /* An explicit null means load all objects. */
                Helix.DB.loadAllObjects(loadCommandOptions.schema, function(widgetList) {
                    window[loadCommandOptions.name] = widgetList;
                    loadCommandOptions.oncomplete(null, loadCommandOptions.name, widgetList);
                });
            } else {
                /* itemKey is undefined. Nothing we can do when we are offline. */
                loadCommandOptions.onerror(Helix.Ajax.ERROR_OFFLINE_ACCESS)
            }
            return;
        }

        $(document).trigger('prerequest');
        /* Give the browser a change to handle the event and show the loader. */
        setTimeout(function() {
            $.ajax({
                type: "POST",
                url: loadCommandOptions.requestOptions.postBack,
                dataType: "json",
                data: $.param(loadCommandOptions.requestOptions.params),
                success: function(data, status, xhr) {
                    var responseObj = data;
                    if (responseObj.error) {
                        var error = Helix.Ajax.ERROR_AJAX_LOAD_FAILED;
                        if (responseObj.error) {
                            error.msg = responseObj.error;
                        }
                        loadCommandOptions.onerror(error);
                        return;
                    }
                    
                    Helix.Ajax.loadOptions.pin = true;
                    if (loadCommandOptions.schema || responseObj.__hx_type == 1003) {
                        if (loadCommandOptions.syncingOptions) {
                            Helix.Utils.statusMessage("Sync in progress", loadCommandOptions.syncingOptions.message, "info");                            
                        }
                        // Add setTimeout to allow the message to display
                        setTimeout(Helix.DB.synchronizeObject(responseObj, loadCommandOptions.schema, function(finalObj, finalKey) {
                            $.mobile.loading( "hide" );
                            window[loadCommandOptions.name] = finalObj;
                            Helix.Ajax.loadOptions.pin = false;
                            loadCommandOptions.oncomplete(finalKey, loadCommandOptions.name, finalObj);
                            if (window.CordovaInstalled) {
                                window.HelixSystem.allowSleep();
                            }
                        }, itemKey, loadCommandOptions.syncOverrides), 0);
                    } else {
                        loadCommandOptions.oncomplete(itemKey, "success");
                    }
                },
                error: function(xhr, status, errorThrown) {
                    var error = Helix.Ajax.ERROR_AJAX_LOAD_FAILED;
                    error.msg = status;
                    loadCommandOptions.onerror(error);
                },
                complete: function(xhr) {
                    $(document).trigger('postrequest', xhr);
                }
            });
        }, 0);
    },
    
    ajaxFormSubmit: function(url, formSelector, statusTitle, successMsg, pendingMsg, errorMsg, actions) {
        $(document).trigger('prerequest');
        if (actions && actions.beforeSubmit) {
            actions.beforeSubmit();
        }
        $.ajax({
            type: "POST",
            url: url,
            dataType: "json",
            contentType: "application/x-www-form-urlencoded",
            data: $(PrimeFaces.escapeClientId(formSelector)).serialize(),
            statusCode: {
                200: function(data, textStatus, jqXHR) {
                    // Show success message.
                    if (successMsg) {
                        Helix.Utils.statusMessage(statusTitle, successMsg, "info");
                    }
                    if (actions && actions.success) {
                        actions.success(data, textStatus, jqXHR);
                    }
                },
                999: function() {
                    // Container has told us we are offline.
                    if (pendingMsg) {
                        Helix.Utils.statusMessage(statusTitle, pendingMsg, "info");
                    }
                }
            },
            error: function(jqXHR,textStatus,errorThrown) {
                if (jqXHR.status != 999) {
                    // Display failMsg
                    if (errorMsg) {
                        Helix.Utils.statusMessage(statusTitle, errorMsg, "error");
                    }
                }
                if (actions && actions.error) {
                    actions.error(jqXHR,textStatus,errorThrown);
                }
            },
            complete: function(xhr) {
                $(document).trigger('postrequest', xhr);
            }
        });
    },
    
    ajaxJSONLoad: function(url,key,widgetVar,oncomplete,offlineSave) {
        url = url.replace("{key}", key);
        $.mobile.showPageLoadingMsg();
        $.ajax({
            url: url,
            type: "GET",
            dataType: "json",
            success: function(data,status,jqXHR) {
                if (data.__mh_error) {
                    Helix.Utils.statusMessage("AJAX Error", data.__mh_error, "severe");
                    jqXHR.__mh_failed = true;
                    return;
                }
                
                window[widgetVar] = data;
                if (offlineSave) {
                // Save non-array types in the key-value store.
                // Save array types in their own tables.
                // Let all values remain encrypted. In the future we can add
                // a parameter that specifies which fields are decrypted.
                }
            },
            complete: function(jqXHR,textStatus) {
                $.mobile.hidePageLoadingMsg();
                if (oncomplete && !jqXHR.__mh_failed) {
                    oncomplete(jqXHR, textStatus);
                }
            }
        });
    },
    
    ajaxPost: function(params, callbacks) {
        $(document).trigger('prerequest', params.url);
        var didSucceed = false;
        if (Helix.Ajax.isDeviceOnline()) {
            $.ajax({
                url: params.url,
                type: 'POST',
                data: params.body,
                contentType: 'application/x-www-form-urlencoded',
                success: function(returnObj,textStatus,jqXHR) {
                    if (returnObj.status == 0) {
                        didSucceed = true;
                        if (params.success) {
                            Helix.Utils.statusMessage("Success", params.success, "info");
                        }

                        if (callbacks.success) {
                            callbacks.success.call(window, returnObj);                    
                        }
                    } else {
                        if (params.error) {
                            Helix.Utils.statusMessage("Error", params.error + ": " + returnObj.msg, "severe");
                        } else {
                            Helix.Utils.statusMessage("Error", returnObj.msg, "severe");
                        }
                        if (callbacks.error) {
                            callbacks.error.call(window, returnObj);
                        }
                    }
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    if (params.fatal) {
                        Helix.Utils.statusMessage("Error", params.fatal + ": " + errorThrown, "severe");
                    } else {
                        Helix.Utils.statusMessage("Error", errorThrown, "severe");
                    }
                    if (callbacks.fatal) {
                        callbacks.fatal.call(window, textStatus, errorThrown);
                    }
                },
                complete: function() {
                    if (callbacks.complete) {
                        callbacks.complete.call(window);
                    }
                    $(document).trigger('postrequest', [{ 'url': params.url, 'success' : didSucceed }]);
                },
                dataType: 'json'
            });                
        } else {
            // Queue a post for the next time the container is online.
            if (!window.CordovaInstalled) {
                alert("This device is offline and the browser does not support JavaScript extensions. Please try save this contact when you are online.");
            } else {
                // Collect the data we will need to continue this offline draft. Not always used or applicable.
                var refreshValues = null;
                if (params.form) {
                    refreshValues = params.form.getValues();
                    if (params.type) {
                        refreshValues['__type'] = params.type;
                    }
                }

                window.OfflinePost.savePost(params.url, 
                    'application/x-www-form-urlencoded', 
                    params.body, 
                    refreshValues ? JSON.stringify(refreshValues) : '', 
                    function() {
                        if (params.offlineSuccess) {
                            Helix.Utils.statusMessage("Action Queued", params.offlineSuccess, "info");
                        } else {
                            Helix.Utils.statusMessage("Action Queued", 
                                "This action will be completed the next time you login to Link online.", "info");                    
                        }
                        if (callbacks.offlineSuccess) {
                            callbacks.offlineSuccess.call(window);
                        }
                        if (callbacks.complete) {
                            callbacks.complete.call(window);
                        }
                    }, 
                    function(msg) {
                        if (callbacks.fatal) {
                            callbacks.fatal.call(window, "Action Save Error", msg);
                        }
                        if (callbacks.complete) {
                            callbacks.complete.call(window);
                        }
                    }
                );
            }
            Helix.Ajax.hideLoader();
        }
    }
};;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Client-side layout functions.
 * 
 * @author Seth Hallem
 */

Helix.Layout = {
    /**
     * Selectors used to identify scrollers.
     */
    scrollerSel : '.pm-scroller,.pm-scroller-nozoom,.pm-scroller-zoomonly,.pm-scroller-horizontal',

    /**
     * Selectors used to identify full height components.
     */
    fullHeightClasses: [
        '.pm-layout-full-height',
        '.hx-layout-full-height',
        '.mh-layout-parent-height',
        '.hx-overlay-full-height',
        '.hx-layout-parent-height',
        /* Include built-in jQM wrapper classes. These classes are inserted in between
         * two elements with a user-controllable class list. If the parent has a recursive 
         * layout class then we want to layout the child, even though it will not have any
         * layout classes attached to it. If the parent does no have a recursive layout class
         * attached then the class' presence here means nothing.
         */
        '.ui-panel-inner'
    ],
    
    /**
     * Selectors used to identify components that should be recursively laid out.
     */
    recurseLayoutClasses: [
        '.pm-layout-full-height',
        '.hx-layout-full-height',
        '.hx-overlay-full-height',
        '.hx-layout-recurse',
        '.ui-panel-inner'
    ],

    /**
     * List of all scrollers in the application.
     */
    allScrollers : {},
    
    /**
     * Content height, excluding headers and footers.
     */
    contentHeight : 0,
    
    /**
     * Determine if an element is a scrolling element.
     */
    isScroller : function(elem) {
        if (elem && $(elem).is(Helix.Layout.scrollerSel)) {
            return true;
        }
        return false;
    },

    /**
     * Determine if an element is contained within a scrolling element.
     */
    isInScroller : function(elem) {
        if (elem && ($(elem).closest(Helix.Layout.scrollerSel).length !== 0)) {
            return true;
        }
        return false;
    },
        
    /**
     * Layout a component that should have height maxHeight. This function also
     * recursively lays out the children of the parent component such that the 
     * aggregated height of all child components is equal to maxHeight. It does so
     * by extending the length of the last child to equal the remaining vertical 
     * distance when the height of all children except the last are subtracted from
     * maxHeight.
     * 
     * @param maxHeight
     *      The target height for the supplied component.
     * @param component
     *      The target component whose height should be set to maxHeight.
     */
    layoutFullHeightComponent: function(maxHeight, component) {
        var paddingPixels = $(component).outerHeight(true) - $(component).height();
        var offsetPixels = 0;
        var fullHeightSelector = Helix.Layout.fullHeightClasses.join(",");
        var recurseSelector = Helix.Layout.recurseLayoutClasses.join(",");
        
        if ($(component).css('top') !== 'auto') {
            // Doesn't handle all unit types.
            var cssAuto = $(component).css('top');
            offsetPixels = parseInt(cssAuto, 10);
        }
        
        var totHeight = paddingPixels + offsetPixels;
        $(component).height(maxHeight - totHeight);
        
        if (!$(component).is(recurseSelector)) {
            /* Set the layout to the parent height and do
             * not recurse any further.
             */
            return;
        }
        
        var children = $(component).children();
        var remainingHeight = offsetPixels;
        for (var i = 0; i < children.length; ++i) {
            if ($(children[i]).is("style,script")) {
                // Skip style and script tags - see note at http://api.jquery.com/height/
                continue;
            }
            if ($(children[i]).is(fullHeightSelector)) {
                // These items must be side-by-side, otherwise the proposed layout is fully overlapping ...
                continue;
            }
            if (!$(children[i]).is(":visible")) {
                continue;
            }

            var child_i_height = $(children[i]).outerHeight(true);
            totHeight += child_i_height;
            if (i < (children.length - 1)) {
                remainingHeight += child_i_height;
            }
        }
        
        var childrenToRecurse = $(component).children(fullHeightSelector);
        
        /* If there are no elements to recurse over, set the last child of this element to full the 
         * rest of the screen.
         */
        if (childrenToRecurse.length == 0) {
            var $fullHeightChild = $(children[children.length - 1]);
            $fullHeightChild.height(maxHeight - remainingHeight);
        } else {
            childrenToRecurse.each(function() {
                if ($(this).is('.hx-overlay-full-height')) {
                    Helix.Layout.layoutFullHeightComponent(maxHeight, this);
                } else {
                    Helix.Layout.layoutFullHeightComponent(maxHeight - totHeight, this);
                }
            });
        }
    },
    resizePages: function(page) {
        var height = $(window).height();
        var width = $(window).width();

        /* In our mobile framework we never let pages scroll. Elements inside can scroll
         * using the scrollingDiv. jQuery Mobile lays out headers and footers by attaching
         * an appropriately sized padding to the page. This means that to prevent any
         * scrolling by the browser we need to size the page contents to be the difference
         * between the viewport height and the combined header/footer height. 
         */
        var $header = page.find('[data-role="header"]');
        var headerHeight = Helix.Layout.headerHeight = 0;
        if ($header.is(':visible')) {
            headerHeight = Helix.Layout.headerHeight = $header.outerHeight(true);
        }
        
        var $footer = page.find('[data-role="footer"]');
        var footerHeight = Helix.Layout.footerHeight = 0;
        if ($footer.is(':visible')) {
            footerHeight = Helix.Layout.footerHeight = $footer.outerHeight(true);
        }
        var pageHeight = height;
        var contentHeight = height - footerHeight - headerHeight;
        if ($header.is('[data-position="fixed"]')) {
            pageHeight -= headerHeight;
        }
        if ($footer.is('[data-position="fixed"]')) {
            pageHeight -= footerHeight;
        }
        page.height(pageHeight);
        
        var content = page.find('.hx-main-content');
        content.css('height', contentHeight);
        if (!$(content).parent().is('.ui-page')) {
            $(content).parent().height(pageHeight);
        }
        
        content.each(function() {
            //var innerWidth = width - (this.offsetWidth - this.clientWidth);
            $(this).css('width', width);
        });
        
        /* Fixed position panels need to have a padding at the top equal to the header height.
         * Otherwise the top of the panel slides under the header.
         */
        $('.ui-panel-fixed').css('padding-top', Helix.Layout.headerHeight + 'px');
        
        return contentHeight;
    },
    
    layoutPageFullScreen: function(page) {
        var contentHeight = Helix.Layout.resizePages(page);
        var fullContentHeight = contentHeight;
        
        Helix.Layout.contentHeight = contentHeight;
        $('[data-role="content"]', page).children().each(function() {
            if ($(this).is("style,script")) {
                // Skip style and script tags - see note at http://api.jquery.com/height/
                return;
            }
            
            if ($(this).is('.pm-layout-full-height,.hx-layout-full-height,.mh-layout-parent-height,.hx-layout-parent-height')) {
                Helix.Layout.layoutFullHeightComponent(contentHeight, this);
            } else if ($(this).is('.hx-overlay-full-height')) {
                Helix.Layout.layoutFullHeightComponent(fullContentHeight, this);
            } else {
                contentHeight = contentHeight - $(this).outerHeight(true);
            }
        });        
    },
    
    renderer: function(page, id, fn) {
        if (!Helix.Utils.isString(id)) {
            fn = id;
            id = null;
        }
        
        if (id) {
            var renderersMap = $(page).data('hxrendermap');
            if (!renderersMap) {
                renderersMap = {};
                $(page).data('hxrendermap', renderersMap);
            }
            if (id in renderersMap) {
                // Already installed this named renderer
                return;
            }
            renderersMap[id] = true;
        }
        
        var renderers = $(page).data('hxrender');
        if (!renderers) {
            renderers = [];
            $(page).data('hxrender', renderers);
        } 
        renderers.push(fn);
    },
    
    postRenderer: function(page, fn) {
        var postRenderers = $(page).data('hxpostrender');
        if (!postRenderers) {
            postRenderers = [];
            $(page).data('hxpostrender', postRenderers);
        } 
        postRenderers.push(fn);
    },
    
    refresh: function(page, noTrigger) {
        if (!page) {
            page = $.mobile.activePage;
        }
        
        var renderers = $(page).data('hxrender');
        if (renderers) {
            for (var i = 0; i < renderers.length; ++i) {
                renderers[i].call(this);
            }
        }
        
        //Helix.Layout.layoutPage($(page), noTrigger);
    },
    
    postRefresh: function(page) {
        if (!page) {
            page = $.mobile.activePage;
        }
        
        var prenderers = $(page).data('hxpostrender');
        if (prenderers) {
            for (var i = 0; i < prenderers.length; ++i) {
                prenderers[i].call(this);
            }
        }
    }
};

/**
 * Prior to any AJAX request, track the height of the items we are updating with that
 * request. When the response is received, we set a timeout handler that we try 3 times 
 * at 200ms intervals to wait for the height to update after the DOM is updated. When 
 * the height has updated, we refresh the scrollers to ensure that the scroller covers
 * the full scrolling area. The 3 retries prevent us from infinitely trying and 
 * retrying in the event that the downloaded update has the exact same height as the 
 * current html.
 */
$(document).bind('prerequest', function(ev, cfg) {
    if (cfg && cfg.update) {
        var updatedIDs = cfg.update.split(" ");
        for (var i = 0; i < updatedIDs.length; ++i) {
            /* Escape colons because primefaces use the colon character in its naming scheme ... */
            var updateSel = PrimeFaces.escapeClientId(updatedIDs[i]);
            
            /* 
             * Clean up all scrollers that may be deleted when this item is updated.
             *
            $(updateSel).find(Helix.Layout.scrollerSel).each(function(index, element) {
                var scrollerID = $(this).attr('id');
                Helix.Layout.deleteScroller(scrollerID);
            });*/
        }
    }
});

$(document).bind('postrequest', function(ev, xhr) {
    if (!xhr.responseXML) {
        return;
    }
    
    var responseXML = xhr.responseXML;
    var xmlDoc = $(responseXML.documentElement),
    updates = xmlDoc.find('update'),
    nUpdated = 0;
    
    if (!updates) {
        return;
    }
    for(var i=0; i < updates.length; i++) {
        var updateID = updates.eq(i).attr('id');
        
        /* Escape colons because primefaces use the colon character in its naming scheme ... */
        var updateSel = PrimeFaces.escapeClientId(updateID);

        if ($(updateSel).length == 0) {
            /* This update selector is not in the DOM ...*/
            continue;
        }
        ++nUpdated;

        /* Determine if the item we have updated has children that are scrollers. If
         * so, make sure we create those scrollers from scratch. Otherwise we may end
         * up with bogus scrollers added by the pageshow event that are then overwritten
         * by an AJAX update that happens when the page is first loading.
         *
        $(updateSel).find(Helix.Layout.scrollerSel).each(function() {
            var scrollerID = $(this).attr('id');
            Helix.Layout.deleteScroller(scrollerID);
        });*/
        
        /*
         * Trigger JQM enhancement and our own enhancement on the updated markup.
         */
        $(updateSel).trigger("create");
        
        /*
         * Trigger our own enhancement event.
         */
        $(document).trigger('pmcreate', updateSel);
    }
    
    if (nUpdated > 0) {
        /* Reset the full screen layout of the page. */
        Helix.Layout.layoutPage();
    }
});

/**
 * In general, apps should use the pagebeforeshow event to layout the DOM. When
 * the page load is done, they should call this function.
 */
Helix.Layout.layoutPage = function(page, noTrigger) {
    if (!page) {
        page = $.mobile.activePage;
        if (!page) {
            /* Nothing to do. */
            return;
        }
    } else {
        page = $(page);
    }
    
    /* Reset the full screen layout of the page. */
    Helix.Layout.layoutPageFullScreen(page);
    
    /* Trigger an event indicating that the page layout is done. */
    if (!noTrigger) {
        $(page).trigger("hxLayoutDone");
    }
}

/**
 * Do an initial layout on before show. This mostly gets rid of the snapping
 * effect. However, the heights of the different elements are not quite right. 
 * So we do it again on show.
 */
$(document).on('pagebeforeshow', function(ev, data) {
    /**
     * Layout the page based on the Mobile Helix styles unless this is an async page, in which case
     * we wait for the app to explicitly trigger the final render actions on the page.
     */
    if (!$.mobile.activePage.is('[data-async="true"]')) {
        Helix.Layout.refresh(ev.target, true);
    }
    
    /**
     * Fix .ui-header-fixed, per
     * 
     * http://stackoverflow.com/questions/13514163/header-jump-to-the-middle-of-screen-jquerymobile
     */
    $('.ui-header-fixed').css('position', 'fixed');
});

$(document).on('pageshow', function(ev) {
    /**
     * Trigger the layout done event unless this is an async page, in which case
     * we wait for the app to explicitly trigger the final render actions on the page.
     */
    if (!$.mobile.activePage.is('[data-async="true"]')) {
        Helix.Layout.layoutPage($.mobile.activePage);
        Helix.Layout.postRefresh(ev.target, true);
    }
});

$(document).on('keyboardHide', function(ev) {
    Helix.Layout.layoutPage();
});

$(document).on('orientationchange', function(ev) {
    Helix.Layout.refresh();
    Helix.Layout.layoutPage();
});

Helix.deviceType = (function() {
    if (window.screen.width <= 500) {
        return "phone";
    } else if (window.screen.width <= 767) {
        return "phablet";
    } else {
        return "tablet";
    }
})();

Helix.hasTouch = (function() {
    return !!('ontouchstart' in window) // works on most browsers 
        || !!('onmsgesturechange' in window); // works on ie10
})();

Helix.clickEvent = (function() {
    return (Helix.hasTouch ? 'vclick' : 'click');
})();

Helix.contextEvent = (function() {
    return (Helix.hasTouch ? 'taphold' : 'contextmenu');
})();

Helix.browser = (function() {
    if (navigator.userAgent.indexOf("AppleWebKit") != -1) {
        // Safari or mobile safari.
        if (navigator.userAgent.indexOf("Mobile") != -1) {
            return "iOS";
        } else {
            return "MacOS";
        }
    }
    return "Standard";
})();;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Layout a single form element.
 */

/**
 * Private helper functions.
 */
function __mkTZOption(tzOffsetHours, curTime, text, val) {
    // Determine if the current time is in this time zone.
    var selected = false;
    if (Helix.Utils.isString(curTime)) {
        selected = (curTime === val);    
    } else {
        var tzOffset = tzOffsetHours * 60;
        if ((-tzOffset) == curTime.getTimezoneOffset()) {
            selected = true;
        }        
    }

    var tzO = $('<option />').attr({
        value: val,
        'data-offset' : tzOffsetHours
    }).append(text);
    if (selected) {
        tzO.attr("selected", true);
    }
    
    return tzO;
}

/**
 * Return true if we are in daylight savings time. False if not.
 */
function __isCurrentTZ(stdOffsetHours) {
    var today = new Date();
    var offsetMinutes = today.stdTimezoneOffset();
    if (offsetMinutes == (-stdOffsetHours * 60)) {
        return true;
    }
    return false;
}

function __getTZSelect(tabIndex, name, id, curTime) {
    var date = null;
    if (!curTime) {
        date = new Date();
    } else if (!Helix.Utils.isString(curTime)) {
        date = new Date(curTime);
    }
    
    var tzSelect = $('<select />').attr({
        'name' : name,
        'id' : id,
        'tabIndex' : tabIndex
    });
    __mkTZOption(-12.0, date, "(GMT -12:00) Eniwetok, Kwajalein", "ENIWETOK").appendTo(tzSelect);
    __mkTZOption(-11.0, date, "(GMT -11:00) Midway Island, Samoa", "MIDWAY_ISLAND").appendTo(tzSelect);
    __mkTZOption(-10.0, date, "(GMT -10:00) Hawaii", "HAWAII").appendTo(tzSelect);
    
    if (date.dst()) {
        __mkTZOption(-8.0, date, "(GMT -8:00) Alaska Daylight Time", "ALASKA").appendTo(tzSelect);
        __mkTZOption(-7.0, date, "(GMT -7:00) Pacific Daylight Time (US &amp; Canada)", "PACIFIC").appendTo(tzSelect);
        __mkTZOption(-6.0, date, "(GMT -6:00) Mountain Daylight Time (US &amp; Canada)", "MOUNTAIN").appendTo(tzSelect);              
        __mkTZOption(-5.0, date, "(GMT -5:00) Central Daylight Time (US &amp; Canada), Mexico City", "CENTRAL").appendTo(tzSelect);
        __mkTZOption(-4.5, date, "(GMT -4:30) Venezuela Standard Time, Caracas", "CARACAS").appendTo(tzSelect);
        __mkTZOption(-4.0, date, "(GMT -4:00) Eastern Daylight Time (US &amp; Canada), Bogota, Lima", "EASTERN").appendTo(tzSelect);
        __mkTZOption(-3.0, date, "(GMT -3:00) Atlantic Daylight Time (Canada), La Paz", "ATLANTIC_CANADA").appendTo(tzSelect);
        __mkTZOption(-2.5, date, "(GMT -2:30) Newfoundland Daylight Time", "NEWFOUNDLAND").appendTo(tzSelect);
        __mkTZOption(-2.0, date, "(GMT -2:00) Brazil, Buenos Aires, Georgetown", "BUENOS_AIRES").appendTo(tzSelect);
    } else {
        __mkTZOption(-9.0, date, "(GMT -9:00) Alaska", "ALASKA").appendTo(tzSelect);
        __mkTZOption(-8.0, date, "(GMT -8:00) Pacific Time (US &amp; Canada)", "PACIFIC").appendTo(tzSelect);
        __mkTZOption(-7.0, date, "(GMT -7:00) Mountain Time (US &amp; Canada)", "MOUNTAIN").appendTo(tzSelect);        
        __mkTZOption(-6.0, date, "(GMT -6:00) Central Time (US &amp; Canada), Mexico City", "CENTRAL").appendTo(tzSelect);
        __mkTZOption(-5.0, date, "(GMT -5:00) Eastern Time (US &amp; Canada), Bogota, Lima", "EASTERN").appendTo(tzSelect);
        __mkTZOption(-4.5, date, "(GMT -4:30) Venezuela Standard Time, Caracas", "CARACAS").appendTo(tzSelect);
        __mkTZOption(-4.0, date, "(GMT -4:00) Atlantic Time (Canada), La Paz", "ATLANTIC_CANADA").appendTo(tzSelect);
        __mkTZOption(-3.5, date, "(GMT -3:30) Newfoundland", "NEWFOUNDLAND").appendTo(tzSelect);
        __mkTZOption(-3.0, date, "(GMT -3:00) Brazil, Buenos Aires, Georgetown", "BUENOS_AIReS").appendTo(tzSelect);
        __mkTZOption(-2.0, date, "(GMT -2:00) Mid-Atlantic", "MID_ATLANTIC").appendTo(tzSelect);
    }
    __mkTZOption(-1.0, date, "(GMT -1:00 hour) Azores, Cape Verde Islands", "AZORES").appendTo(tzSelect);
    __mkTZOption(0.0, date, "(GMT) Western Europe Time, London, Lisbon, Casablanca", "GMT").appendTo(tzSelect);
    __mkTZOption(1.0, date, "(GMT +1:00 hour) Brussels, Copenhagen, Madrid, Paris", "PARIS").appendTo(tzSelect);
    __mkTZOption(2.0, date, "(GMT +2:00) Cairo, South Africa", "CAIRO").appendTo(tzSelect);
    __mkTZOption(3.0, date, "(GMT +3:00) Baghdad, Riyadh, Moscow, St. Petersburg", "MOSCOW").appendTo(tzSelect);
    __mkTZOption(3.5, date, "(GMT +3:30) Tehran", "TEHRAN").appendTo(tzSelect);
    __mkTZOption(4.0, date, "(GMT +4:00) Abu Dhabi, Muscat, Baku, Tbilisi", "ABU_DHABI").appendTo(tzSelect);
    __mkTZOption(4.5, date, "(GMT +4:30) Kabul", "KABUL").appendTo(tzSelect);
    __mkTZOption(5.0, date, "(GMT +5:00) Ekaterinburg, Islamabad, Karachi, Tashkent", "ISLAMABAD").appendTo(tzSelect);
    __mkTZOption(5.5, date, "(GMT +5:30) Bombay, Calcutta, Madras, New Delhi", "BOMBAY").appendTo(tzSelect);
    __mkTZOption(5.75, date, "(GMT +5:45) Kathmandu", "NEPAL").appendTo(tzSelect);
    __mkTZOption(6.0, date, "(GMT +6:00) Almaty, Dhaka, Colombo", "DHAKA").appendTo(tzSelect);
    __mkTZOption(7.0, date, "(GMT +7:00) Bangkok, Hanoi, Jakarta", "BANGKOK").appendTo(tzSelect);
    __mkTZOption(8.0, date, "(GMT +8:00) Beijing, Perth, Singapore, Hong Kong", "HONG_KONG").appendTo(tzSelect);
    __mkTZOption(9.0, date, "(GMT +9:00) Tokyo, Seoul, Osaka, Sapporo, Yakutsk", "TOKYO").appendTo(tzSelect);
    __mkTZOption(9.5, date, "(GMT +9:30) Adelaide, Darwin", "ADELAIDE").appendTo(tzSelect);
    __mkTZOption(10.0, date, "(GMT +10:00) Eastern Australia, Guam, Vladivostok", "VLADIVOSTOK").appendTo(tzSelect);
    __mkTZOption(11.0, date, "(GMT +11:00) Magadan, Solomon Islands, New Caledonia", "MAGADAN").appendTo(tzSelect);
    __mkTZOption(12.0, date, "(GMT +12:00) Auckland, Wellington, Fiji, Kamchatka", "WELLINGTON").appendTo(tzSelect);
    return tzSelect;
}

function __refreshDate(mode, formElem) {
    if (formElem.value) {
        if (Helix.Utils.isString(formElem.value) && formElem.value.toLowerCase() === 'now') {
            formElem.value = new Date();
        } else if (Object.prototype.toString.call(formElem.value) !== '[object Date]') {
            formElem.value = new Date(Number(formElem.value));
        }
    }
    
    if (mode) {
        var thisField = $(formElem.DOM).find('[name="' + formElem.name + '"]');
        $(thisField).trigger('datebox', { method: 'set', value : formElem.value });
        $(thisField).trigger('datebox', { method: 'doset' });

        var timeElem = $(formElem.DOM).find('[name="' + formElem.name + '_time"]');
        if (timeElem.length > 0) {
            $(timeElem).trigger('datebox', { method: 'set', value: formElem.value });
            $(timeElem).trigger('datebox', { method: 'doset' });
        }
    } else {
        var dataNameAttr = '[data-name="' + formElem.name + '"]';
        var selector = 'span' + dataNameAttr + ',div' + dataNameAttr;
        $(formElem.DOM).find(selector).remove();
        if (formElem.value) {
            var dateMarkup;
            if (formElem.type === 'date' ||
                formElem.type === 'exactdate') {
                if (formElem.type === 'date') {
                    var dateValue = new Date(Number(formElem.value));
                    dateMarkup = $('<a />').attr({
                        'title': dateValue.toISOString()
                    }).prettyDate();
                } else {
                    dateMarkup = $('<a />').append(formElem.value.toLocaleDateString());
                }
                if (formElem.fieldTitle) {
                    formElem.DOM.append($('<span/>').attr({
                        'style' : formElem.computedStyle,
                        'class' : formElem.computedStyleClass,
                        'data-name' : formElem.name
                    }).append("&nbsp;" + $(dateMarkup).text())); 
                } else {
                    formElem.DOM.append($('<div />').attr({
                        'data-name' : formElem.name
                    }).append($(dateMarkup).text()));
                }
            } else {
                var dateSpan = $('<span/>').attr('data-name', formElem.name).append("&nbsp;" + formElem.value.toLocaleString());
                if (formElem.computedStyle) {
                    dateSpan.attr('style', formElem.computedStyle);
                }
                if (formElem.computedStyleClass) {
                    dateSpan.addClass(formElem.computedStyleClass); 
                }
                if (formElem.fieldTitle) {
                    dateSpan.attr('data-name', formElem.name);
                    formElem.DOM.append(dateSpan);
                } else {
                    formElem.DOM.append($('<div />').attr({
                        'data-name' : formElem.name
                    }).append(dateSpan));
                }
            }
        }
    }
}

function __appendDate(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    if (!formElem.name) {
        console.log("Cannot add a date field with no name to a form layout.");
        return;
    }
    if (mode) {
        var defaultValue = Date.now();
        if (formElem.value) {
            defaultValue = Number(formElem.value);
        }

        /* Edit */
        var dateDiv = $('<div />').attr({
            'style' : formLayout.computedFieldStyle,
            'class' : 'ui-field-contain ui-body ui-br ' + formLayout.computedFieldStyleClass + (useMiniLayout ? 'hx-mini-fieldcontain' : '')
        })
        .append($('<label />').attr({
            'for' : formElem.name,
            'class' : 'ui-input-text ' + (formLayout.titleStyleClass ? formLayout.titleStyleClass : '') + (useMiniLayout ? ' hx-full-width' : '')
            })
            .append(formElem.fieldTitle)
        );
        /*var inputWrapper = $('<div />').attr({ 
            'style' : formElem.computedStyle,
            'class' : formElem.computedStyleClass
        }).appendTo(dateDiv);*/
        var inputWrapper = dateDiv;
        var inputID = Helix.Utils.getUniqueID();
        var dateInput = $('<input />').attr({
            'name': formElem.name,
            'id': inputID,
            'data-role' : 'none',
            'style' : 'font-size: 16px'
        }).appendTo(inputWrapper);
        var timeInput = null;
        if (formElem.type === 'datetime') {
            /* Add a time box. */
            timeInput = $('<input />').attr({
                'name': formElem.name + "_time",
                'id': inputID + "_time",
                'data-role' : 'none',
                'style' : 'font-size: 16px'
            }).appendTo(inputWrapper);
        }
        
        // 'value' : defaultValueText,
        $fieldContainer.append(dateDiv);
        dateDiv.fieldcontain();
        dateInput.datebox({"mode" : "flipbox", 
            "useNewStyle":false, 
            "defaultValue": defaultValue, 
            "openCallback" : (formElem.onfocus ? formElem.onfocus : false),
            "closeCallback" : (formElem.onchange ? formElem.onchange : false),
            "displayInline" : (timeInput ? true : false)
        });
        if (timeInput) {
            var minuteStep = 1;
            if (formElem.options && formElem.options.minuteStep) {
                minuteStep = formElem.options.minuteStep;
            }
            timeInput.datebox({"mode" : "timeflipbox", 
                "overrideTimeFormat" : 12, 
                "overrideTimeOutput" : "%l:%M %p", 
                "defaultValue": defaultValue,
                "openCallback" : (formElem.onfocus ? formElem.onfocus : false),
                "closeCallback" : (formElem.onchange ? formElem.onchange : false),
                "displayInline" : (timeInput ? true : false),
                "minuteStep" : minuteStep
            });
        }
    } else {
        __refreshDate(mode, formElem);
    }
}

function __refreshTZSelector(mode, formElem) {
    if (!formElem.value) {
        // Use the current time zone.
        var curTime = new Date();
        var tzOffsetHours = -(curTime.getTimezoneOffset() / 60.0);
        formElem.value = $(formElem.DOM).find('option[data-offset="' + tzOffsetHours + '"]').attr('value');
    }
    
    if (mode) {
        $(formElem.DOM).find('option').prop({ selected : false });
        $(formElem.DOM).find('option[value="' + formElem.value + '"]').prop({ selected : true });
        $(formElem.DOM).find('select').selectmenu('refresh');
    } else {
        $('p[data-name="'+ formElem.name + '"]').empty().append(formElem.value);
    }
}

function __appendTZSelector(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    if (!formElem.name) {
        /* No field name. We cannot render this field. */
        console.log("Cannot add a TZ selector with no name to a form layout.");
        return;
    }
    if (mode) {
        var defaultValue = Date.now();
        if (formElem.value) {
            defaultValue = formElem.value;
        }

        /* Edit */
        var labelWidthOverride = '';
        if (useMiniLayout) {
            // On small devices force the label on to a full line.
            labelWidthOverride = ';width: 100%';
        }
        var inputID = Helix.Utils.getUniqueID();
        var dateDiv = $('<div />').attr({
            'data-role' : 'fieldcontain',
            'style' : formLayout.computedFieldStyle,
            'class' : formLayout.computedFieldStyleClass
        })
        .append($('<label />').attr({
            'for' : inputID,
            'style' : 'vertical-align: middle' + labelWidthOverride,
            'class' : 'ui-input-text ' + formLayout.titleStyleClass
            })
            .append(formElem.fieldTitle)
        );
        
        var tzSelect = __getTZSelect(formLayout.__tabIndex++, formElem.name, inputID, defaultValue).appendTo(dateDiv);
        if (formElem.onchange) {
            $(tzSelect).change(function() {
                var newVal = $(this).find("option:selected");
                formElem.onchange.call(this, newVal.val(), newVal);
            });
        }
        
        // 'value' : defaultValueText,
        $fieldContainer.append(dateDiv);
        tzSelect.selectmenu();
        dateDiv.fieldcontain();
        if (formElem.computedStyle || formElem.computedStyleClass) {
            var uiSelect = $(dateDiv).find('div.ui-select');
            if (formElem.computedStyle) {
                uiSelect.attr('style', formElem.computedStyle);
            }
            if (formElem.computedStyleClass) {
                uiSelect.addClass(formElem.computedStyleClass); 
            }
        }

    } else {
        $fieldContainer.append($('<p />').attr('data-name', formElem.name).append(formElem.value));
    }
}

function __refreshTextArea(mode, formElem) {
    if (mode) {
        var $input = $(formElem.DOM).find('textarea[name="'+formElem.name+'"]');
        $input.val(formElem.value);
    } else {
        var dataNameAttr = '[data-name="' + formElem.name + '"]';
        var selector = 'span' + dataNameAttr + ',p' + dataNameAttr;
        var $span = $(formElem.DOM).find(selector);
        if ($span.is('span')) {
            $span.html("&nbsp;" + formElem.value);
        } else {
            /* Should be a 'p' tag. */
            $span.html(formElem.value);
        }
    }
}

function __appendTextArea(mode, formLayout, formElem, $fieldContainer) {
    if (!formElem.value) {
        formElem.value = "";
    }
    
    if (!formElem.name) {
        /* No field name. We cannot use this field in a form layout. */
        console.log("Cannot use a text area field with no name in a form layout.");
        return;
    }
    
    if (mode) {
        /* Edit */
        // Use the mini style to set font size to 'small'
        var inputID = Helix.Utils.getUniqueID();
        var inputMarkup = $('<textarea />').attr({
            'name': formElem.name,
            'id' : inputID,
            'style': formElem.computedStyle,
            'class' : formElem.computedStyleClass,
            'tabindex' : formLayout.__tabIndex++
        }).append(formElem.value);

        var textContainer = $('<div />').attr({
            'data-role' : 'fieldcontain',
            'style' : formLayout.computedFieldStyle,
            'class' : 'hx-mini-fieldcontain ' + formLayout.computedFieldStyleClass
        })
        .append($('<label />').attr({
            'for' : inputID
            })
            .append(formElem.fieldTitle)
        )
        .append(inputMarkup);
        $fieldContainer.append(textContainer);
        textContainer.fieldcontain();
        $(inputMarkup).textinput();
        if (formElem.fieldTitleType === 'button') {
            $(formElem.fieldTitle).button();
        }
        if (formElem.onblur) {
            $(inputMarkup).blur(function() {
                formElem.onblur.apply(this);
            });
        }
    } else {
        if (formElem.fieldTitle && (typeof formElem.fieldTitle == "string")) {
            $fieldContainer.append($('<span />').attr('data-name', formElem.name).append("&nbsp;" + formElem.value));
        } else {
            $fieldContainer.append($('<p />').attr('data-name', formElem.name).append(formElem.value));
        }
    }
}

function __refreshSelectMenu(formElem) {
    var $fieldContainer = formElem.DOM;
    if ($fieldContainer) {
        $fieldContainer.empty();
    }
    
    var inputID = Helix.Utils.getUniqueID();
    var inputMarkup = $('<select />').attr({
        'name': formElem.name,
        'id' : inputID,
        'tabindex' : formElem.tabIndex
    });
    if (formElem.selectWidth) {
        $(inputMarkup).attr('width', formElem.selectWidth);
    }

    var i;
    for (i = 0; i < formElem.options.length; ++i) {
        // If not independent label is specified, make it the same as the value.
        if (!formElem.options[i].label) {
            formElem.options[i].label = formElem.options[i].value;
        }
        var option = $('<option />').attr({
            'value': formElem.options[i].value
        }).append(formElem.options[i].label).appendTo(inputMarkup);

        if (formElem.value && formElem.options[i].value == formElem.value) {
            // This item is selected.
            option.attr('selected', true);
        }
    }

    var selectContainer = $('<div />').attr({
        'data-role' : 'fieldcontain',
        'style' : formElem.computedStyle
    })
    .append($('<label />').attr({
        'for' : inputID
        })
        .append(formElem.fieldTitle)
    )
    .append(inputMarkup);
    $fieldContainer.append(selectContainer);
    selectContainer.fieldcontain();
    $(inputMarkup).selectmenu();
}

function __appendSelectMenu(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    if (!formElem.name) {
        /* No field name. We cannot edit this field. */
        console.log("Invalid select menu in form layout. No field name specified.");
        return;
    }
    if (mode) {
        /* Edit */
        if (!formElem.options) {
            return;
        }
        
        formElem.tabIndex = formLayout.__tabIndex++;
            
        __refreshSelectMenu(formElem, $fieldContainer);
    } else {
        __appendTextBox(mode, formLayout, formElem, $fieldContainer, useMiniLayout);
    }
}

function __refreshTextBox(mode, formElem) {
    if (mode) {
        var $input = $(formElem.DOM).find('input[name="'+formElem.name+'"]');
        $input.val(formElem.value);
    } else {
        var dataNameAttr = '[data-name="' + formElem.name + '"]';
        var selector = 'span' + dataNameAttr + ',p' + dataNameAttr;
        var $span = $(formElem.DOM).find(selector);
        if ($span.is('span')) {
            $span.text(formElem.value);
        } else {
            /* Should be a 'p' tag. */
            $span.text(formElem.value);
        }
    }
}

function __appendTextBox(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    if (!formElem.value) {
        formElem.value = "";
    }
    
    if (mode) {
        /* Edit */
        if (mode && !formElem.name) {
            /* No field name. We cannot edit this field. */
            return;
        }

        if (!formElem.dataType) {
            formElem.dataType = "text";
        }

        var inputID = Helix.Utils.getUniqueID();
        var inputMarkup = $('<input />').attr({
            'name': formElem.name,
            'id' : inputID,
            'type': formElem.dataType,
            'value': (formElem.value),
            'tabindex' : formLayout.__tabIndex++
        });
        
        // WE always use the mini style. Otherwise the fonts are too large even on tablets.
        var textContainer = $('<div />').attr({
            'data-role' : 'fieldcontain',
            'style' : formLayout.computedFieldStyle,
            'class' : 'hx-mini-fieldcontain ' + formLayout.computedFieldStyleClass
        })
        .append($('<label />').attr({
            'for' : inputID,
            'class' : formLayout.titleStyleClass
            })
            .append(formElem.fieldTitle)
        )
        .append(inputMarkup);
        $fieldContainer.append(textContainer);
        textContainer.fieldcontain();
        $(inputMarkup).textinput();
        if (formElem.fieldTitleType === 'button') {
            $(formElem.fieldTitle).button();
        }
        if (formElem.onblur) {
            $(inputMarkup).blur(function() {
                if (!formElem.__noblur) {
                    formElem.onblur.apply(this);
                }
            });
        }
        if (formElem.onspace) {
            $(inputMarkup).on("keydown", function (e) {
                if (e.which == 32) {
                    formElem.onspace.apply(this);
                }
            });
        }
        if (formElem.onenter) {
            $(inputMarkup).on("keydown", function (e) {
                if (e.which == 13) {
                    formElem.onenter.apply(this);
                }
            });
        }
        
        // Apply styling to the input text div ...
        if (formElem.computedStyle || formElem.computedStyleClass) {
            var uiInputText = textContainer.find('div.ui-input-text');
            if (formElem.computedStyle) {
                $(uiInputText).attr('style', formElem.computedStyle);
            }
            if (formElem.computedStyleClass) {
                $(uiInputText).addClass(formElem.computedStyleClass);
            }
        }
        
        // Add in autocomplete.
        if (formElem.autocomplete && formElem.autocompleteSelect) {
            if (!formElem.autocompleteThreshold) {
                formElem.autocompleteThreshold = 2;
            }
            // To get this to hover, we must make it a 'positioned' element. position: relative does
            // nothing on the iPad. position: absolute yields proper hovering.
            var autoCompleteList = $('<ul/>').css('z-index', 10000)
                                             .css('width', '100%')
                                             .css('position', 'absolute')
                                             .appendTo($fieldContainer).listview({ inset : true });
            $(inputMarkup).on('input', function() {
                if (formElem.__autocompleteTimeout) {
                    clearTimeout(formElem.__autocompleteTimeout);
                }
                
                var text = $(this).val();
                if (text.length < formElem.autocompleteThreshold) {
                    autoCompleteList.empty();
                    autoCompleteList.listview("refresh");
                } else {
                    var __doAutocomplete = function() {
                        formElem.autocomplete(text, function(LIs) {
                            // Set __noblur to prevent the user's clicking on an autocomplete list
                            // item from triggering a blur event, which doesn't make sense because
                            // the value supplied to the blur event should be the value clicked upon,
                            // not the value in the input text box.
                            formElem.__noblur = true;
                            autoCompleteList.empty();
                            if (LIs && LIs.length) {
                                for (var i = 0; i < LIs.length; ++i) {
                                    $("<li/>").append(LIs[i]).on('vclick', function() {
                                        formElem.autocompleteSelect($(this).text());
                                        autoCompleteList.empty();
                                        $(inputMarkup).val('');
                                        formElem.__noblur = false;
                                        return false;
                                    }).appendTo(autoCompleteList);
                                }
                                autoCompleteList.listview("refresh");
                            } else {
                                formElem.__noblur = false;
                            }
                        });
                    };
                    
                    // Wait 1 second for the user to pause typing before we do anything.
                    formElem.__autocompleteTimeout = setTimeout(function() {
                        __doAutocomplete();
                    }, 1500);                    
                }
            });
        }
    } else {
        if (formElem.fieldTitle && (typeof formElem.fieldTitle == "string")) {
            var valSpan = $('<span/>').attr({
                'data-name' : formElem.name,
                'class' : 'ui-input-text'
            }).text(formElem.value)
            if (formElem.computedStyle) {
                valSpan.attr('style', formElem.computedStyle);
            }
            if (formElem.computedStyleClass) {
                valSpan.addClass(formElem.computedStyleClass);
            }
            $fieldContainer.append(valSpan);
        } else {
            $fieldContainer.append($('<p />').attr({
                'data-name' : formElem.name,
                'class' : formElem.computedStyleClass + ' ui-input-text'
            }).text(formElem.value));
        }
    }
}

function __appendCheckBox(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    if (!formElem.name) {
        /* No field name. We cannot edit this field. */
        console.log("Invalid checkbox in form layout. No field name specified.");
        return null;
    }
    
    var type = 'checkbox';
    if (formElem.type === 'radio') {
        type = 'radio';
    }
    
    var inputID = Helix.Utils.getUniqueID();
    var inputMarkup = $('<input/>').attr({
        'name': formElem.name,
        'id' : inputID,
        'type' : type,
        'tabindex' : -1
    });
    __refreshControl(formElem, true);
    $('<label />').attr('for', inputID).append(formElem.fieldTitle).appendTo($fieldContainer);
    $(inputMarkup).appendTo($fieldContainer);
    $(inputMarkup).checkboxradio({ mini: useMiniLayout });
    if (formElem.onchange) {
        $(inputMarkup).change(function() {
            formElem.onchange.call(this);
        });
    }
    if (!mode) {
        /* View */
        $(inputMarkup).checkboxradio("disable");
    }        
    return inputMarkup;
}

function __refreshControl(subElem, noRefresh, mode) {
    var DOM;
    if ($(subElem.DOM).is('input')) {
        DOM = subElem.DOM;
    } else {
        DOM = $(subElem.DOM).find('input');
    }
    
    if (subElem.value) {
        if (typeof subElem.value === "boolean" &&
            subElem.value) {
            $(DOM).prop('checked', true);
        } else if (subElem.value === "true") {
            $(DOM).prop('checked', true);
        }
    } else if (subElem.value !== undefined) {
        $(DOM).prop('checked', false);
    }
    if (!noRefresh) {
        $(DOM).checkboxradio("refresh");
        if (!mode) {
            /* View */
            $(DOM).checkboxradio("disable");
        } else {
            /* Edit */
            $(DOM).checkboxradio("enable");
        }
    }
}

function __refreshRadioButtons(formElem) {
    // Clear out all selections.
    $(formElem.DOM).find('input').removeAttr('checked').prop('checked', false);
    $(formElem.DOM).find('input[data-value="' + formElem.value + '"]').attr('checked', true).prop('checked', true);
    $(formElem.DOM).find('fieldset').controlgroup('refresh');
}

function __appendRadioButtons(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    if (!formElem.name) {
        console.log("Skipping radio buttons because it has no name.");
        return;
    }
    
    var fieldMarkup = $('<div />').attr({
        'style' : 'width: ' + (formElem.computedWidth ? formElem.computedWidth : 'auto')
    }).appendTo($fieldContainer);

    var formMarkup = $("<form />").appendTo(fieldMarkup);
    var wrapperMarkup = $('<fieldset/>').appendTo(formMarkup);
    /*
     *.attr({
        'data-role' : 'fieldcontain'
    })
     *.attr({
        'data-role' : 'controlgroup',
        'data-type' : 'horizontal',
        'data-mini' : (useMiniLayout ? 'true' : 'false')
    })*/

    if (formElem.fieldTitle) {
        wrapperMarkup.append($('<legend/>').attr({
            'class' : formLayout.titleStyleClass
        }).append(formElem.fieldTitle));
    }

    var i = 0;
    for (i = 0; i < formElem.controls.length; ++i) {
        var subElem = formElem.controls[i];
        __preprocessFormElement(formLayout, subElem);
        if (subElem.hidden || subElem.disabled) {
            continue;
        }
        subElem.name = formElem.name;
        subElem.type = 'radio';
        var inputMarkup = __appendCheckBox(mode, formLayout, subElem, wrapperMarkup, useMiniLayout);
        if (mode) {
            subElem.editDOM = inputMarkup;
        } else {
            subElem.viewDOM = inputMarkup;
        }
        if (formLayout.currentMode === 'edit') {
            subElem.DOM = subElem.editDOM;
        } else {
            subElem.DOM = subElem.viewDOM;
        }
        if (subElem.defaultValue !== undefined) {
            $(inputMarkup).attr('data-value', subElem.defaultValue);
        }
        if (subElem.defaultValue === formElem.defaultValue) {
            $(inputMarkup).attr('checked', 'true');
        }
        if (formElem.onchange) {
            $(inputMarkup).change(function() {
                if ($(this).attr('checked') !== 'true') {
                    formElem.onchange($(this).attr('data-value'));
                }
            });
        }
    }
    $(wrapperMarkup).controlgroup({ 
        mini : useMiniLayout,
        type: (formElem.direction ? formElem.direction : "horizontal")
    });
    $(fieldMarkup).fieldcontain();
}

function __appendControlSet(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    var fieldMarkup = $('<div />').attr({
        'style' : 'width: auto'
        /*'data-role' : 'fieldcontain'*/
    }).appendTo($fieldContainer);

    var wrapperMarkup = $('<fieldset/>').attr({
    /*    'data-role' : 'controlgroup',
        'data-type' : 'horizontal',
        'data-mini' : (useMiniLayout ? 'true' : 'false') */
    }).appendTo(fieldMarkup);

    if (formElem.fieldTitle) {
        wrapperMarkup.append($('<legend/>').attr({
            'class' : formLayout.titleStyleClass
        }).append(formElem.fieldTitle));
    }

    var i = 0;
    for (i = 0; i < formElem.controls.length; ++i) {
        var subElem = formElem.controls[i];
        __preprocessFormElement(formLayout, subElem);
        if (subElem.disabled) {
            continue;
        }
        if (!subElem.name) {
            console.log("Skipping controlset checkbox because it has no name.");
            continue;
        }
        var inputMarkup = __appendCheckBox(mode, formLayout, subElem, wrapperMarkup, useMiniLayout);
        subElem.DOM = inputMarkup;
    }
    $(wrapperMarkup).controlgroup({ 
        mini : useMiniLayout,
        type: "horizontal" 
    });
    $(fieldMarkup).fieldcontain();
    
    // After enhancement, hide any hidden controls
    for (i = 0; i < formElem.controls.length; ++i) {
        subElem = formElem.controls[i];
        subElem.DOM = subElem.viewDOM = subElem.editDOM = $(subElem.DOM).closest('div.ui-checkbox');
        if (subElem.hidden) {
            $(subElem.DOM).hide();
        }
        if (subElem.mode === 'edit') {
            /* No view. */
            subElem.viewDOM = null;
        }
        if (subElem.mode === 'view') {
            /* No edit. */
            subElem.editDOM = null;
        }
    }
}

function __appendButton(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    var $buttonLink;
    if (!formElem.fieldTitle) {
        formElem.fieldTitle = "";
    }
    if (formElem.iconClass) {
        $buttonLink = $('<a />').attr({
            'data-role' : 'button',
            'data-iconpos' : 'bottom',
            'data-icon' : formElem.iconClass,
            'data-iconshadow' : true,
            'class' : 'iconbutton'
        }).append(formElem.fieldTitle).button();            
    } else {
        $buttonLink = $('<a />').attr({
            'data-role' : 'button',
            'data-inline' : true,
            'data-theme' : 'b'
        }).append(formElem.fieldTitle).button();
    }
    if (formElem.href) {
        $buttonLink.attr('href', formElem.href);
    } else {
        $buttonLink.attr('href', 'javascript:void(0);');
    }
    $buttonLink.appendTo($fieldContainer);
    $buttonLink.buttonMarkup({ mini : useMiniLayout });
    if (formElem.onclick) {
        $buttonLink.on('tap', function(ev) {
            formElem.onclick.call(this, ev);
        });
    }
}

function __refreshIFrame(formElem) {
    var frameID = formElem.name;
    var $frame = formElem.DOM.find(PrimeFaces.escapeClientId(frameID));
    $frame.hide();
    
    // Load the iframe document content
    var contentWindow = $frame[0].contentWindow;
    //contentWindow.scrollTo(0, 0);
    
    var doc = contentWindow.document;
    doc.open();
    if (!formElem.noHTML) {
        doc.write('<html>');
    }
    if (!formElem.noHead) {
        doc.write('<head>');
        doc.write('<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1"/>');
        doc.write('</head>');
    }
    if (!formElem.noBody) {
        doc.write('<body style="height: 100%;">');
    }
    /*if (formElem.isScroller) {
        $(doc.body).css('overflow-y', 'scroll');
    }*/
    doc.write(formElem.value);
    if (!formElem.noBody) {
        doc.write('</body>');
    }
    if (!formElem.noHTML) {
        doc.write('</html>');
    }
    doc.close();
    if (!formElem.isScroller) {
        $(doc.body).parent().css('overflow', 'hidden');
    }
    
    $frame.show();
}

function __refreshHTMLFrame(formElem) {
    if ($(formElem.editDOM).is(':visible')) {
        var elem = $(formElem.DOM).find('[name="' + formElem.name + '"]');
        var $editor = $(elem).data('cleditor');
        if (!formElem.value) {
            $editor.update(''); 
        } else {
            $editor.update(formElem.value);
        }        
    } else if ($(formElem.viewDOM).is(':visible')) {
        __refreshIFrame(formElem);
    }
}

function __appendIFrame(mode, formLayout, formElem, $fieldContainer, useMiniLayout, page, parentDiv) {
    if (formElem.height === 'full') {
        $fieldContainer.addClass('hx-layout-full-height');
    }
    if (formElem.computedStyle) {
        var combinedStyle = $fieldContainer.attr('style') + ' ' + formElem.computedStyle;
        $fieldContainer.attr('style', combinedStyle);
    }
    if (formElem.computedStyleClass) {
        $fieldContainer.addClass(formElem.computedStyleClass);
    }
    if (formElem.computedWidth) {
        $fieldContainer.width(formElem.computedWidth);
    }
    
    if (!mode) {
        var frameID = formElem.name;
        if (!frameID) {
            console.log("Each IFrame form element must have a name. Cannot specify an IFrame form element without either.");
            return;
        }
        var extraStyle = '';
        if (formElem.isScroller) {
            extraStyle = 'overflow-y: scroll; -webkit-overflow-scrolling: touch;';
            $fieldContainer.css('overflow-y', 'scroll').css('-webkit-overflow-scrolling', 'touch');
        }
        
        var iFrameMarkup = null;
        var iFrameStyle = ' style="border:0px; ' + extraStyle + '"';
        var iFrameWidth = ' width="' + formElem.computedWidth + '"';
        var onloadAttr = (formElem.onload ? (' onload="' + formElem.onload + '(\'' + frameID + '\')"') : '');
        
        if (!formElem.height || (formElem.height === 'full')) {
            iFrameMarkup = '<iframe id="' + frameID + 
                '" src="javascript:true;"' +
                iFrameWidth +
                onloadAttr +
                iFrameStyle + '>';
        } else {
            iFrameMarkup = '<iframe id="' + frameID + '" src="javascript:true;" height="' + formElem.height + '"' +
                iFrameWidth +
                onloadAttr +
                iFrameStyle + '>';
        }
        
        $(iFrameMarkup).appendTo($fieldContainer).hide();
        __refreshIFrame(formElem);
    } else {
        __appendCLEditor(mode, formLayout, formElem, $fieldContainer, useMiniLayout, page, parentDiv);
    }
}

function __refreshButtonGroup(formElem) {
    if (!formElem.buttons) {
        return;
    }
    var $buttonBar = $(formElem.DOM).find('.buttonBarMaster').empty();
    
    var formButton;
    var formButtonIdx;
    for (formButtonIdx = 0; formButtonIdx < formElem.buttons.length; ++formButtonIdx) {
        formButton = formElem.buttons[formButtonIdx];
        if (!formButton.iconPos && formButton.iconPos !== 'none') {
            formButton.iconPos = 'bottom';
        }
        if (!formButton.computedStyleClass && 
            formButton.iconClass &&
            formButton.iconPos !== 'none') {
            formButton.computedStyleClass = 'iconbutton';
        }
        if (!formButton.theme) {
            formButton.theme = 'b';
        }
        if (!formButton.iconClass) {
            formButton.iconClass = '';
        }
        var $buttonBarLink = $('<a />').attr({
            'data-iconpos' : formButton.iconPos,
            'data-icon' : formButton.iconClass,
            'data-iconshadow' : false,
            'data-theme' : formButton.theme,
            'class' : formButton.computedStyleClass
        });
        if (formButton.mini) {
            $buttonBarLink.attr('data-mini', 'true');
        }
        if (formButton.fieldTitle) {
            $buttonBarLink.append(formButton.fieldTitle);
        } 
        if (formButton.href) {
            $buttonBarLink.attr('href', formButton.href);
        } else {
            $buttonBarLink.attr('href', 'javascript:void(0);');
        }
        if (formButton.onclick) {
            $buttonBarLink.on('tap', formButton.onclick);
        }
        $buttonBarLink.appendTo($buttonBar);
        $buttonBarLink.button();
    }
    $buttonBar.controlgroup({ type: (formElem.orientation ? formElem.orientation : "horizontal") });
}

function __refreshHTMLArea(formElem) {
    if ($(formElem.editDOM).is(':visible')) {
        var elem = $(formElem.DOM).find('[name="' + formElem.name + '"]');
        var $editor = $(elem).data('cleditor');
        if (!formElem.value) {
            $editor.clear(); 
        } else {
            $editor.update(formElem.value);
        }        
    } else if ($(formElem.viewDOM).is(':visible')) {
        var viewContainer = $(formElem.viewDOM).find('div[data-name="' + formElem.name + '"]').empty();
        viewContainer.append(formElem.value);
    }
}

function __appendCLEditor(mode, formLayout, formElem, $fieldContainer, useMiniLayout, page, parentDiv) {
    var isFullWidth = false;
    if (formElem.computedWidth) {
        if (formElem.computedWidth === "100%") {
            isFullWidth = true;
        }            
    }

    if (!formElem.name) {
        /* No field name. We cannot edit this field. */
        console.log("Cannot layout an HTML area in edit mode without an element name.");
        return;
    }

    var editorID = Helix.Utils.getUniqueID();
    var editorInput = $('<textarea />').attr({
        'name' : formElem.name,
        'id' : editorID,
        'tabIndex' : -1
    }).val(formElem.value);
    $fieldContainer.append($('<div />')
        .append($('<label />').attr({
            'for' : editorID
            })
            .append(formElem.fieldTitle)
        )
        .append(editorInput)
    );
    $(editorInput).cleditor({
        'widget' : editorID + "_widget",
        'width' : (formElem.computedWidth ? formElem.computedWidth : $(parentDiv).width()),
        'isFullWidth' : isFullWidth,
        'height' : (formElem.height ? formElem.height : 350),
        'page' : page,
        'tabIndex' : formLayout.__tabIndex++
    });    
}

function __appendHTMLArea(mode, formLayout, formElem, $fieldContainer, useMiniLayout, page, parentDiv) {
    if (mode) {
        __appendCLEditor(mode, formLayout, formElem, $fieldContainer, useMiniLayout, page, parentDiv);
    } else {
        var isFullWidth = false;
        if (formElem.computedWidth) {
            if (formElem.computedWidth === "100%") {
                isFullWidth = true;
            }            
        }
        
        var width = "98%";
        if (isFullWidth) {
            width = "100%";
        } else if (formElem.computedWidth) {
            width = formElem.computedWidth;
        }
        if (!formElem.name) {
            formElem.name = Helix.Utils.getUniqueID();
        }
        
        var htmlDiv = $('<div />').attr('data-name', formElem.name).append(formElem.value);
        if (formElem.computedStyle) {
            htmlDiv.attr('style', formElem.computedStyle);
        }
        if (formElem.computedStyleClass) {
            htmlDiv.addClass(formElem.computedStyleClass); 
        }
        $fieldContainer.append(htmlDiv);
        if (formElem.isScroller) {
            $fieldContainer.helixScrollingDiv({ width: width });
        } else {
            $fieldContainer.css('overflow', 'none');
            $fieldContainer.width(width);
        }
    }
}

function __appendButtonGroup(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    var $buttonBar = $('<div />').attr({
        'class' : 'buttonBarMaster buttonbar'
    }).appendTo($fieldContainer);
    if (formElem.name) {
        $buttonBar.attr('id', formElem.name);
    }
    __refreshButtonGroup(formElem);
}

function __refreshHorizontalScroll(formElem) {
    var hscroll = $(formElem.DOM).find('div[data-name="' + formElem.name + '"]');
    $(hscroll).empty();
    if (formElem.value) {
        $(hscroll).append(formElem.value);
    }
}

function __appendHorizontalScroll(mode, formLayout, formElem, $fieldContainer, useMiniLayout) {
    var hscroll = $('<div />').attr({
        'class' : 'hx-horizontal-scroller-nozoom hx-full-width',
        'data-name' : formElem.name
    }).appendTo($fieldContainer);
    if (formElem.value) {
        hscroll.append(formElem.value);
    }
}

function __appendSubPanel(mode, formLayout, formElem, $fieldContainer, useMiniLayout, page) {
    var subPanelObj = formElem;
    
    // The panelMode field determines if the subPanel is in a fixed mode (edit or view), or it is the same/reverse
    // of the main form.
    if (!subPanelObj.panelMode) {
        // Render in the same mode as the enclosing form.
        subPanelObj.modes = formLayout.modes;
        subPanelObj.currentMode = formLayout.currentMode;
    } else if (subPanelObj.panelMode === 'reverse') {
        // Opposite of the parent.
        subPanelObj.currentMode = (formLayout.currentMode === 'edit' ? 'view' : 'edit');
        subPanelObj.modes = subPanelObj.panelMode;
    } else {
        // Fixed value.
        subPanelObj.currentMode = subPanelObj.panelMode;
        subPanelObj.modes = subPanelObj.panelMode;
    }
    
    
    ++Helix.Utils.nSubPanels;
    var subPanelID = formElem.id;
    if (!subPanelID) {
        subPanelID = 'subpanel' + Helix.Utils.nSubPanels;
    }
    var subPanelDiv = $('<div />').attr({
        'id' : subPanelID
    }).appendTo($fieldContainer);

    // Layout the elements in the sub-panel add a separator between elements
    // but not between items in each element.
    Helix.Utils.layoutForm(subPanelDiv, subPanelObj, page, useMiniLayout);

    // Prepend here rather than appending before the layoutForm call because layoutForm
    // empties the parent div.
    subPanelDiv.prepend($('<h3 />').append(formElem.fieldTitle));

    // Make sure we have a dynamic page used to create new items in this 
    // subpanel.
    //var dialogId;
    if (subPanelObj.dialog &&
        (subPanelObj.dialog.activeMode == -1 ||
            mode == subPanelObj.dialog.activeMode )) {
        var dialogObj = Helix.Utils.createDialog(subPanelObj.dialog, subPanelObj.dialog.uniqueID, formElem.fieldTitle, page);

        // Add a button to open the dialog.
        $('<a />').attr({
            'href' : 'javascript:void(0)',
            'data-role' : 'button',
            'data-inline' : 'true',
            'data-theme' : 'b'
        })
        .append(subPanelObj.dialog.dialogTitle)
        .appendTo(subPanelDiv)
        .on('tap', function() {
            $.mobile.changePage(PrimeFaces.escapeClientId(dialogObj.id), {});
        })
        .button();
    }

    // Create the collapsible content.
    subPanelDiv.collapsible({
        collapsed: !subPanelObj.noCollapse,
        mini: (subPanelObj.mini ? subPanelObj.mini : (formLayout.mini ? true : false))
    });
    
    // Determine if the sub-panel is visible based on the 'mode' field.
    if (subPanelObj.mode && subPanelObj.mode !== 'all') {
        if (subPanelObj.mode !== formLayout.currentMode) {
            // Not visible.
            $(subPanelDiv).hide();
            return;
        }
    }
    $(subPanelDiv).show();
    
    subPanelObj.DOM = subPanelObj.editDOM = subPanelObj.viewDOM = subPanelDiv;
}

function __preprocessFormElement(formLayout, formElem) {
    if (formElem.styleClass) {
        if (!Helix.Utils.isString(formElem.styleClass)) {
            formElem.computedStyleClass = 
                (formElem.styleClass[Helix.deviceType] ?  formElem.styleClass[Helix.deviceType] : formElem.styleClass['default']);
        } else {
            formElem.computedStyleClass = formElem.styleClass;
        }
    }
    
    formElem.computedStyle = '';
    if (formElem.style) {
        if (!Helix.Utils.isString(formElem.style)) {
            formElem.computedStyle = 
                (formElem.style[Helix.deviceType] ?  formElem.style[Helix.deviceType] : formElem.style['default']) + ";";
        } else {
            formElem.computedStyle = formElem.style + ";";
        }
    }

    if (formElem.width) {
        if (!Helix.Utils.isString(formElem.width)) {
            /* Mapping from device type to width. */
            formElem.computedWidth = (formElem.width[Helix.deviceType] ?  formElem.width[Helix.deviceType] : formElem.width['default']);
        } else {
            formElem.computedWidth = (formElem.width === 'full' ? "100%" : formElem.width);
        }
    } else {
        formElem.computedWidth = '90%';
    }
    if (!formElem.computedStyle) {
        formElem.computedStyle = formElem.computedStyle + 'width: ' + formElem.computedWidth;
    }
    
    if (!formElem.mode) {
        formElem.mode = 'all';
    }
    
    if (!formElem.value) {
        // Set to the default.
        formElem.value = formElem.defaultValue;
    }
    
    /**
     * Check if this element is disabled on this device.
     */
    if (formElem.deviceType && formElem.deviceType !== 'all') {
        if (formElem.deviceType !== Helix.Utils.deviceType) {
            formElem.disabled = true;
            return;
        }
    }
    
    formElem.disabled = false;
}

Helix.Utils.noTitleLayouts = {
    "button" : true,
    "controlset" : true,
    "radio" : true,
    "subPanel" : true
};

Helix.Utils.fieldContainers = {
    'text' : true,
    'date' : true,
    'exactdate' : true,
    'datetime' : true,
    'pickList' : true
};

Helix.Utils.oneContainerLayouts = {
    'controlset' : true,
    'checkbox' : true
};

Helix.Utils.layoutFormElement = function(formLayout, formElem, parentDiv, page, useMiniLayout) {
    var supportedModes = formLayout.modes;
    var currentMode = formLayout.currentMode;
    var renderFn = null;
    var oneContainer = false;
    
    var separateElements = formLayout.separateElements;
    
    __preprocessFormElement(formLayout, formElem);
    
    if (formElem.disabled) {
        return;
    }
    
    if (formElem.type == 'separator') {
        if (formElem.mode === 'all') {
            formElem.viewDOM = $('<hr />').appendTo(parentDiv);
            formElem.editDOM = $('<hr />').appendTo(parentDiv);
        } else if (formElem.mode === 'view') {
            formElem.viewDOM = $('<hr />').appendTo(parentDiv);
        } else {
            formElem.editDOM = $('<hr />').appendTo(parentDiv);
        }

        if (formLayout.currentMode === 'view') {
            formElem.DOM = formElem.viewDOM;
        } else {
            formElem.DOM = formElem.editDOM;
        }

        return;
    } 
    
    var $viewFieldContainer, $editFieldContainer;
    var containerID = null;    
    if (formElem.id) {
        containerID = formElem.id + "_container";
    } else if (formElem.name) {
        containerID = formElem.name + "_container";
    } else {
        containerID = Helix.Utils.getUniqueID();
    }
    
    if (supportedModes !== 'edit' &&
        formElem.mode !== 'edit') {
        /* View mode. */
        formElem.viewDOM = $viewFieldContainer = $('<div />')
        .css("clear", "both")
        .css('-webkit-user-select', 'none')
        .attr('id', containerID + "_view")
        .appendTo(parentDiv);
        if (formLayout.computedFieldStyleClass) {
            $viewFieldContainer.attr('class', formLayout.computedFieldStyleClass);
        }
        if (formLayout.computedFieldStyle) {
            $viewFieldContainer.attr('style', formLayout.computedFieldStyle);
        }
        if (formElem.fieldTitle && !(formElem.type in Helix.Utils.noTitleLayouts)) {
            if (formElem.titleStyleClass) {
                $viewFieldContainer.append($('<span />').attr({
                    'class' : formElem.titleStyleClass + ' ui-input-text'
                }).append(formElem.fieldTitle));
            } else if (formLayout.titleStyleClass) {
                $viewFieldContainer.append($('<span />').attr({
                    'class' : formLayout.titleStyleClass + ' ui-input-text'
                }).append(formElem.fieldTitle));
            } else {
                $viewFieldContainer.append(formElem.fieldTitle);
            }
            if (formElem.type in Helix.Utils.fieldContainers) {
                if (formElem.mini) {
                    $viewFieldContainer.addClass('hx-mini-fieldview'); 
                } else {
                    $viewFieldContainer.addClass('hx-fieldview'); 
                }
                
                $viewFieldContainer.addClass('ui-fieldcontain'); 
                $viewFieldContainer.addClass('ui-body'); 
                $viewFieldContainer.addClass('ui-br');
            }
        }
    } 
    
    if (supportedModes !== 'view' &&
        formElem.mode !== 'view') {
        if ((formElem.type in Helix.Utils.oneContainerLayouts) &&
                $viewFieldContainer) {
            formElem.editDOM = $editFieldContainer = $viewFieldContainer;
            oneContainer = true;
        } else {
            /* Edit mode. */
            formElem.editDOM = $editFieldContainer = $('<div />').attr({
                'id' : containerID + "_edit"
            }).appendTo(parentDiv);            
        }
    }
    if (currentMode === 'view') {
        formElem.DOM = $viewFieldContainer;
    } else {
        formElem.DOM = $editFieldContainer;
    }
    
    if (formElem.type == "text") {
        renderFn = __appendTextBox;
    } else if (formElem.type == 'textarea') {
        renderFn = __appendTextArea;
    } else if (formElem.type == 'pickList') {
        renderFn = __appendSelectMenu;
    } else if (formElem.type == 'checkbox') {
        renderFn = __appendCheckBox;
    } else if (formElem.type === 'controlset') {
        renderFn = __appendControlSet;
    } else if (formElem.type === 'radio') {
        renderFn = __appendRadioButtons;
    } else if (formElem.type === 'htmlarea') {
        renderFn = __appendHTMLArea;
    } else if (formElem.type === 'htmlframe') {
        renderFn = __appendIFrame;
    } else if (formElem.type === 'button') {
        renderFn = __appendButton;
    } else if (formElem.type === 'buttonGroup') {
        renderFn = __appendButtonGroup;
    } else if (formElem.type === 'date' ||
               formElem.type === 'exactdate' ||
               formElem.type === 'datetime') {
        renderFn = __appendDate;
    } else if (formElem.type === 'tzSelector') {
        renderFn = __appendTZSelector;
    } else if (formElem.type == 'dialog') {        
        var elemIdx;
        for (elemIdx = 0; elemIdx < formElem.controls.length; ++elemIdx) {
            var subElem = formElem.controls[elemIdx];
            Helix.Utils.layoutFormElement(formLayout, subElem, parentDiv, page, useMiniLayout);
        }

        /* Add a button to submit the dialog. */
        var buttonTitle = formElem.dialogSubmitTitle;
        if (!buttonTitle) {
            buttonTitle = formElem.dialogTitle;
        }
        
        $('<div />').attr({
            'class' : 'ui-block-b'
        }).append($('<button />').attr({
            'data-theme' : 'b',
            'type' : 'submit'
            }).append(buttonTitle)
              .button()
              .on('tap', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    if (formElem.dialogSubmit) {
                        formElem.dialogSubmit(parentDiv);
                    }
                    $.mobile.changePage(formElem.doneLink, {});
                })
        )
        .appendTo(parentDiv);
        separateElements = false;
    } else if (formElem.type == 'hidden') {
        if ($editFieldContainer) {
            /* Edit. */
            if (!formElem.name) {
                /* No field name. We cannot include this field in the form. */
                return;
            }
            
            $editFieldContainer.append($('<input />').attr({
                    'name': formElem.name,
                    'type': 'hidden',
                    'value': formElem.value
            }));
        }
        separateElements = false;
    } else if (formElem.type == 'upload') {
        if ($editFieldContainer) {
            /* For desktop use only! Create an HTML5 uploader. */
            var styleClass = formElem.computedStyleClass;
            if (!styleClass) {
                styleClass = '';
            }

            /* Append a span with a message indicating what the user should do. */
            $('<span/>').attr({
                'class' : styleClass
            }).append(formElem.fieldTitle)
                .appendTo($editFieldContainer);   

            var uploadId = Helix.Utils.getUniqueID();
            var uploadDiv= $('<div/>').attr({
                'id' : uploadId,
                'class' : "mh-uploads"
            }).appendTo($editFieldContainer);


            $(page).on('pagecreate', function() {
               var dropbox = $editFieldContainer;
               dropbox.filedrop(uploadDiv, {
                    // The name of the $_FILES entry:
                    paramname:'file',

                    maxfiles: 1,
                    maxfilesize: 20, // in mb
                    url: formElem.options.url,
                    headers: formElem.options.headers,
                    
                    /* '/clientws/sharepoint/upload' */
                    /*
                     * {
                        'listUUID' : currentList.uuidName,
                        'siteURL' : currentSite.siteURL
                        }
                     */

                    uploadFinished:function(i,file,response){
                        Helix.Utils.statusMessage("Upload Complete", response.msg, "info");
                    },

                    error: function(err, file) {
                        switch(err) {
                            case 'BrowserNotSupported':
                                Helix.Utils.statusMessage('Unsupported Operation', 'Your browser does not support HTML5 file uploads!', 'severe');
                                break;
                            case 'TooManyFiles':
                                Helix.Utils.statusMessage('Error', 'Too many files! Please select 1 at most!', 'severe');
                                break;
                            case 'FileTooLarge':
                                Helix.Utils.statusMessage(file.name+' is too large! Please upload files up to 2mb.');
                                break;
                            default:
                                break;
                        }
                    },

                    // Called before each upload is started
                    beforeEach: function(file){
                        if (!formElem.name) {
                            this.headers['fileName'] = file.name;
                        } else {
                            this.headers['fileName'] = formElem.name;
                        }
                    }
                });           
            });
        }   
    } else if (formElem.type == "image") {
       if ($viewFieldContainer) {
           styleClass = "";
           if (formElem.computedStyleClass) {
               styleClass = formElem.computedStyleClass;
           }
           if (!formElem.target) {
               formElem.target = "";
           }
           
           /* Only show images in view mode. */
           var surroundingDiv = $('<div/>').attr({
               'class' : styleClass
           }).appendTo($viewFieldContainer);
           
           var imgTag = $('<img/>').attr({
               'src': formElem.src,
               'width' : formElem.computedWidth,
               'height' : formElem.height,
               'style' : formElem.computedStyle,
               'alt' : formElem.name,
               'title' : formElem.name,
               'target' : formElem.target
           });
           var txtElem = $('<span/>').attr({ 'style' : 'float:left' }).append('Tap to open ' + formElem.name);
           if (formElem.link) {
               surroundingDiv.append($('<a/>').attr({
                   'href' : formElem.link
               }).append(imgTag).append(txtElem));
           } else if (formElem.click) {
               $(imgTag).on('tap', function(e) {
                   formElem.click.apply(this, [e]);
               });
               surroundingDiv.append(imgTag).append(txtElem);
           } else {
               surroundingDiv.append(imgTag).append(txtElem);
           }
           $(imgTag).load(function() {
               $(txtElem).hide();
           });
       }
    } else if (formElem.type == 'horizontalScroll') {
        renderFn = __appendHorizontalScroll;
    } else if (formElem.type === 'subPanel') {
        // Subpanels should be attached directly to the parent div, not to a surrounding
        // container. Otherwise the full screen styling won't work with subpanels because
        // the margin around the collapsible container is masked by the surrounding div.
        if ($viewFieldContainer) {
            $viewFieldContainer.remove();
        }
        if ($editFieldContainer) {
            $editFieldContainer.remove();
        }
        $viewFieldContainer = $editFieldContainer = null;
        
        __appendSubPanel.call(formElem, 0, formLayout, formElem, parentDiv, useMiniLayout, page, parentDiv);
    } else {
        separateElements = false;
    }
    
    if ($viewFieldContainer) {
        if (renderFn) {
            renderFn.call(formElem, 0, formLayout, formElem, $viewFieldContainer, useMiniLayout, page, parentDiv);
        }
        if (currentMode === 'edit' && !oneContainer) {
            $viewFieldContainer.hide();
        }
    }
    if ((!oneContainer && $editFieldContainer)) {
        if (renderFn) {
            renderFn.call(formElem, 1, formLayout, formElem, $editFieldContainer, useMiniLayout, page, parentDiv);
        }
        if (currentMode === 'view' && !oneContainer) {
            $editFieldContainer.hide();
        }
    }
    
    if (separateElements && !formElem.noSeparator) {
        formElem.SEPARATOR = $('<hr />').insertAfter(formElem.editDOM ? formElem.editDOM : formElem.viewDOM);
    }
    if (formElem.hidden && formElem.DOM) {
        $(formElem.DOM).hide();
        if (formElem.SEPARATOR) {
            // Hide the HR.
            $(formElem.SEPARATOR).hide();
        }
    } else if (formElem.DOM) {
        $(formElem.DOM).show();
        if (formElem.SEPARATOR) {
            $(formElem.SEPARATOR).show();
        }
    }
}

function __preprocessFormLayout(formLayout) {
   formLayout.computedFieldStyleClass = '';
    if (formLayout.fieldStyleClass) {
        if (!Helix.Utils.isString(formLayout.fieldStyleClass)) {
            formLayout.computedFieldStyleClass = 
                (formLayout.fieldStyleClass[Helix.deviceType] ?  formLayout.fieldStyleClass[Helix.deviceType] : formLayout.fieldStyleClass['default']);
        } else {
            formLayout.computedFieldStyleClass = formLayout.fieldStyleClass;
        }
    }
    
    formLayout.computedFieldStyle = '';
    if (formLayout.fieldStyle) {
        if (!Helix.Utils.isString(formLayout.fieldStyle)) {
            formLayout.computedFieldStyle = 
                (formLayout.fieldStyle[Helix.deviceType] ?  formLayout.fieldStyle[Helix.deviceType] : formLayout.fieldStyle['default']);
        } else {
            formLayout.computedFieldStyle = formLayout.fieldStyle + ";";
        }
    }
    
    formLayout.__tabIndex = 1;
}

/**
 * 0 for view mode; 1 for edit mode.
 */
Helix.Utils.nSubPanels = 0;
Helix.Utils.dynamicDialogs = {};
Helix.Utils.layoutForm = function(parentDiv, formLayout, page, useMiniLayout) {
    __preprocessFormLayout(formLayout);
    if (!page) {
        page = $.mobile.activePage;
    }
    
    // Clear out whatever is currently inside of the parent div.
    $(parentDiv).empty();
    
    var formElem;
    var elemIdx;
    var formElements = formLayout.items;
    for (elemIdx = 0; elemIdx < formElements.length; ++elemIdx) {
        formElem = formElements[elemIdx];
        Helix.Utils.layoutFormElement(formLayout, formElem, parentDiv, page, useMiniLayout);
    }
}

Helix.Utils.createDialog = function(dialogFields, dialogName, dialogTitle, page, useMiniLayout) {
    var dialogId = Helix.Utils.getUniqueID();
    var dialogObj = Helix.Utils.dynamicDialogs[dialogName];
    var isCreated = false;
    if (!dialogObj) {
        dialogObj = Helix.Utils.dynamicDialogs[dialogName] = {
            'id' : dialogId,
            'page' : $('<div />').attr({
                'data-role' : 'page',
                'id' : dialogId,
                'data-history' : false
            }).append($('<div />').attr({
                'data-role' : 'header',
                'data-position' : 'fixed'
                }).append($('<h1 />')
                    .append(dialogTitle)
                ).append($('<a />').attr({
                    'data-iconpos' : 'left',
                    'data-icon' : 'back',
                    'class' : 'ui-btn-left',
                    'href' : PrimeFaces.escapeClientId($(page).attr('id'))
                    }).append('Back')
                ).append($('<a />').attr({
                    'data-iconpos' : 'right',
                    'data-icon' : 'check',
                    'data-theme' : 'b',
                    'class' : 'ui-btn-right' 
                }).on(Helix.clickEvent, function(ev) {
                    dialogFields.saveButton.onclick(ev);
                }).append(dialogFields.saveButton.title))
            ).append($('<div />').attr({
                'data-role' : 'content',
                'style' : 'overflow-y: auto;',
                'class' : 'hx-main-content'
                }).append($('<form />'))
            ),
            'fields' : dialogFields
        };
        isCreated = true;
    }
    
    if (!isCreated) {
        Helix.Utils.refreshDialogValues(dialogFields, dialogObj, null);
    } else {
        var dialogForm = $(dialogObj.page).find('form'); 
        $(dialogForm).empty();
        $(dialogForm).data("DIALOG", dialogFields);
        $(dialogForm).width($.mobile.activePage.width());
        dialogFields.doneLink = PrimeFaces.escapeClientId($.mobile.activePage.attr('id'));
        dialogFields.mode = true; /* Edit mode. */
        dialogFields.separateElements = false; /* Do not separate elements. */
        $(dialogObj.page).appendTo($.mobile.pageContainer);

        //initialize the new page 
        //$.mobile.initializePage();

        $(dialogObj.page).page();
        //$(dialogObj.page).trigger("pagecreate");

        Helix.Utils.layoutForm(dialogForm, dialogFields, dialogObj.page, useMiniLayout);
    }
    
    return dialogObj;
}

Helix.Utils.refreshDialogValues = function(dialogFields, dialogObj, refreshDone) {
    var dialogForm = $(dialogObj.page).find('form');
    
    var idx = 0;
    for (idx = 0; idx < dialogFields.items.length; ++idx) {
        var formElem = dialogFields.items[idx];
        var inputElem = $(dialogForm).find("[name='" + formElem.name + "']");
        if (inputElem) {
            if (formElem.type === "htmlarea") {
                $(inputElem).val(formElem.value);
                $(inputElem).data("cleditor").updateFrame();
            } else if (formElem.type === "date") {
                //$(inputElem).datebox('setDate', new Date(parseInt(formElem.value)));
                var dateValue;
                if (!formElem.value) {
                    dateValue = Date.now();
                } else {
                    dateValue = parseInt(formElem.value);
                    dateValue = new Date(dateValue);
                }
                $(inputElem).trigger('datebox', {'method':'set', 'value': dateValue}).trigger('datebox', {'method':'doset'});
            } else if (formElem.type === "text" ||
                       formElem.type === "hidden") {
                $(inputElem).val(formElem.value);
            }
        }
    }
    if (refreshDone) {
        refreshDone();
    }
}

Helix.Layout.createConfirmDialog = function(options) {
    if (options.onclick && !options.onclick()) {
        return;
    }
    
    var popupId = (options.name ? options.name : Helix.Utils.getUniqueID());
    var popup = $('<div/>').attr({
        'data-role' : 'popup',
        'id' : popupId,
        'data-overlay-theme' : 'a',
        'data-theme' : 'c',
        'data-position-to' : 'window',
        'data-history' : 'false',
        'style' : 'max-width: 300px'
    });
    
    var closebtn = $('<a/>').attr({
        'href' : 'javascript:void(0)',
        'data-role' : 'button',
        'data-inline' : 'true',
        'data-theme' : 'c',
        'id' : popupId + "-cancel"
    });
    if (options.dismissText) {
        $(closebtn).append(options.dismissText);
    } else {
        $(closebtn).append("Dismiss");
    }
    if (options.ondismiss) {
        $(document).on('tap', PrimeFaces.escapeClientId(popupId + "-cancel"), function(e) {
            e.preventDefault();
            options.ondismiss();
            $(popup).popup("close");
            return false;
        });
    } else {
        $(document).on('tap', PrimeFaces.escapeClientId(popupId + "-cancel"), function(e) {
            e.preventDefault();
            $(popup).popup("close");
            return false;
        });
    }
    
    var confirmbtn = $('<a/>').attr({
        'href' : 'javascript:void(0)',
        'data-role' : 'button',
        'data-inline' : 'true',
        'data-theme' : 'b',
        'id' : popupId + "-confirm"
    });
    if (options.confirmText) {
        $(confirmbtn).append(options.confirmText);
    } else {
        $(confirmbtn).append("Confirm");
    }
    if (options.onconfirm) {
        $(document).on('tap', PrimeFaces.escapeClientId(popupId + "-confirm"), function(e) {
            e.preventDefault();
            options.onconfirm();
            $(popup).popup("close");
            return false;
        });
    } else {
        $(document).on('tap', PrimeFaces.escapeClientId(popupId + "-confirm"), function(e) {
            e.preventDefault();
            $(popup).popup("close");
            return false;
        });
    }
    
    var titleStyleClass = options.titleStyleClass ? options.titleStyleClass : 'dialog-title';
    var header = $("<div/>").attr({
        'data-role' : 'header',
        'class' : titleStyleClass
    }).append($('<h1/>').append(options.title));
    
    
    $(popup)
        .append(header)
        .append($('<div/>').attr({
            'data-role' : 'content',
            'data-theme' : 'd',
            'class' : 'ui-corner-bottom ui-content'
        })
            .append($('<p/>').append(options.message))
            .append(closebtn)
            .append(confirmbtn)
    );
    
    $(document).on("popupafterclose", PrimeFaces.escapeClientId(popupId), function() {
        $(this).remove();
    });				

    // Create the popup. Trigger "pagecreate" instead of "create" because currently the framework doesn't bind the enhancement of toolbars to the "create" event (js/widgets/page.sections.js).
    $.mobile.activePage.append( popup ).trigger( "pagecreate" );
    $(popup).popup("open");
    $(window).on('navigate.popup', function (e) {
        e.preventDefault();
        $(window).off('navigate.popup');
    });
};/**
 * Hook
 * Version: 1.1
 * Author: Jordan Singer, Brandon Jacoby, Adam Girton
 * Copyright (c) 2013 - Hook.  All rights reserved.
 * http://www.usehook.com
 */

;(function ( $, window, document, undefined ) {
    var win = $(this),
            st = win.scrollTop() || window.pageYOffset,
            called = false;

    var hasTouch = function() {
              return !!('ontouchstart' in window) || !!('onmsgesturechange' in window);
            };

      var handlers = {};

      var addHandler = function(tgt, name, fn) {
        tgt.on(name, fn);
        handlers[name] = { 'fn': fn, 'tgt': tgt };
      };
      var removeHandler = function(name, fn) {
        handlers[name].tgt.off(name, handlers[name].fn);
        delete handlers[name];
      };
      var removeHandlers = function() {
        for (var name in handlers) {
          removeHandler(name);
        }
      };

      var methods = {

        init: function(options) {

                return this.each(function() {
                    var $this = $(this),
                        settings = $this.data('hook');

                        if(typeof(settings) === 'undefined') {

                                var defaults = {
                                    reloadPage: true, // if false will reload element
                                    dynamic: true, // if false Hook elements already there
                                    textRequired: false, // will input loader text if true
                                    scrollWheelSelected: false, // will use scroll wheel events
                                    swipeDistance: 50, // swipe distance for loader to show on touch devices
                                    loaderClass: 'hook-loader',
                                    spinnerClass: 'hook-spinner',
                                    loaderTextClass: 'hook-text',
                                    loaderText: 'Reloading...',
                                    scrollTarget: win, // Default to detecting overflow scrolls on the full window
                                    reloadEl: function() {}
                                };

                                settings = $.extend({},  defaults, options);

                                $this.data('hook', settings);
                        } else {

                                settings = $.extend({}, settings, options);
                        }

                        if(settings.dynamic === true) {
                             var loaderElem = '<div class=' + settings.loaderClass + '>';
                                     loaderElem += '<div class='+ settings.spinnerClass + '/>';
                                     loaderElem += '</div>';
                             var spinnerTextElem = '<span class='+ settings.loaderTextClass + '>' + settings.loaderText + '</span>';

                             $this
                                     .append(loaderElem);

                             if (settings.textRequired === true) {
                                  $this.addClass('hook-with-text');
                                  $this.append(spinnerTextElem);
                             }
                        }

                        if(!hasTouch()) {
                            if(settings.scrollWheelSelected === true){
                              addHandler(settings.scrollTarget, 'mousewheel', function(event, delta) {
                                  methods.onScroll($this, settings, delta);
                              })
                            } else {
                              addHandler(settings.scrollTarget, 'scroll', function() {
                                  methods.onScroll($this, settings);
                              });
                            }
                        }  else {
                            var lastY = 0,
                                 swipe = 0,
                                 lastScroll = 0;
                            addHandler(settings.scrollTarget, 'touchstart', function(e){
                                //lastY = e.originalEvent.touches[0].pageY;
                                lastY = settings.scrollTarget.scrollTop();
                            });

                            addHandler(settings.scrollTarget, 'touchmove', function(e) {
                                swipe = e.originalEvent.touches[0].pageY + lastY;
                                st = $(this).scrollTop();
                                
                                if (1) {
                                    // Remove when we are sure the scroll method is working.
                                    return;
                                }
                                
                                if(swipe < settings.swipeDistance) {
                                  e.preventDefault();
                                }

                                if(swipe > settings.swipeDistance /*&& lastY <= (elTop + 100)*/) {
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    methods.onSwipe($this, settings);
                                }
                            });

                            addHandler(settings.scrollTarget, 'touchend', function(e){
                                swipe = 0;
                                if (lastY >= 0 && lastScroll < 0) {
                                    // The user was previously in positive territory and has pulled
                                    // down into negative territory. Refresh.
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    e.preventDefault();
                                    methods.onSwipe($this, settings);
                                }
                            });
                            
                            addHandler(settings.scrollTarget, 'scroll', function() {
                                lastScroll = settings.scrollTarget.scrollTop();
                            });
                        }

                });
        },

        onScroll: function(el, settings, delta) {
          st = settings.scrollTarget.scrollTop();

          if(settings.scrollWheelSelected === true && (delta >= 150 && st <= 0)) {
              if(called === false) {
                  methods.reload(el, settings);
                  called = true;
              }
          }

          if(settings.scrollWheelSelected === false && /*SAH: st <= 0*/ st < 0) {
            if(called === false) {
                methods.reload(el, settings);
                called = true;
            }
          }
        },

        onSwipe: function(el, settings) {
            if(/*SAH: st <= 0*/ st < 0) {
                methods.reload(el, settings);
            }
        },

        reload: function(el, settings) {
                el.show();
                el.animate({
                    "marginTop": "0px"
                }, 200);
                el.delay(500).slideUp(200, function () {
                    if(settings.reloadPage) {
                        window.location.reload(true);
                    }

                    called = false;
                });

                if(!settings.reloadPage) {
                    settings.reloadEl();
                }
        },

        destroy: function() {
            removeHandlers();
            return $(this).each(function(){
                var $this = $(this);

                $this.empty();
                $this.removeData('hook');
            });
        }
    };

    $.fn.hook = function () {
        var method = arguments[0];

        if(methods[method]) {
            method = methods[method];
            arguments = Array.prototype.slice.call(arguments, 1);
        } else if (typeof(method) === 'object' || !method) {
            method = methods.init;
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.pluginName' );
                        return this;
        }

        return method.apply(this, arguments);
    };

})( jQuery, window, document );
;/*
 * Copyright 2013 Mobile Helix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(function() {
    var bottomPadding = 0;
    
    /**
     * When a fixed position footer is showing, the keyboard will pop up the footer
     * and the footer will sit on top of the keyboard. This is both bizarre looking and
     * wrong. Instead, we hide the footer and then restore it when the keyboard 
     * appears/disappears.
     */
    $(document).on('helixinit', function() {
        $(document).on('keyboardHide', function() {
            var fixedFooters = $.mobile.activePage.find('.ui-footer[data-position="fixed"]');
            if (fixedFooters.length == 0) {
                return;
            }
            
            $.mobile.activePage.css('padding-bottom', bottomPadding + 'px');
            fixedFooters.show();
        });
        
        $(document).on('keyboardShow', function() {
            var fixedFooters = $.mobile.activePage.find('.ui-footer[data-position="fixed"]');
            if (fixedFooters.length == 0) {
                return;
            }
            
            bottomPadding = $.mobile.activePage.css('padding-bottom');
            fixedFooters.hide();
            $.mobile.activePage.css('padding-bottom', '0px'); 
        });
    });
})();
;/**
 * Within Viewport
 *
 * @description Determines whether an element is completely
 *              within the browser viewport
 * @author      Craig Patik, http://patik.com/
 * @version     0.0.3
 * @date        2014-03-03
 */
;(function() {
    
    var withinViewportConfig = function _getConfig(options) {
        var config = {};
        var settings = {};
        
        // Settings argument may be a simple string (`top`, `right`, etc)
        if (typeof options === 'string') {
            settings = {sides: options};
        }
        else {
            settings = options || {};
        }
        
        // Build configuration from defaults and given settings
        config.container = settings.container || withinViewport.defaults.container || document.body;
        config.sides = settings.sides || withinViewport.defaults.sides || 'all';
        config.top = settings.top || withinViewport.defaults.top || 0;
        config.right = settings.right || withinViewport.defaults.right || 0;
        config.bottom = settings.bottom || withinViewport.defaults.bottom || 0;
        config.left = settings.left || withinViewport.defaults.left || 0;
        
        return config;
    };
    
    /**
     * withinViewport
     * @param  {Object} [elem]      DOM Element, required
     * @param  {Object} [config]   Optional settings
     * @param  {Object} [scrollOffset]   Scroll offset obtained from scrollOffset call
     * @return {Boolean}            Whether the element was completely within the viewport
    */
    var withinViewport = function _withinViewport(elem, config, scrollOffset) {
        var result = false, isWithin, elemOffset, arr, i, side;

        if (elem instanceof jQuery) {
            elem = elem.get(0);
        }

        if (typeof elem !== 'object' || elem.nodeType !== 1) {
            throw new Error('First argument must be an element');
        }

        // Element testing methods
        isWithin = {
            // Element is below the top edge of the viewport
            top: function _isWithin_top() {
                return elemOffset[1] >= scrollOffset[1] + config.top;
            },

            // Element is to the left of the right edge of the viewport
            right: function _isWithin_right() {
                var container = (config.container === document.body) ? window : config.container;

                return elemOffset[0] + elem.offsetWidth <= container.clientWidth + scrollOffset[0] - config.right;
            },

            // Element is above the bottom edge of the viewport
            bottom: function _isWithin_bottom() {
                var container = (config.container === document.body) ? window : config.container;

                return elemOffset[1] + elem.offsetHeight <= scrollOffset[1] + container.clientHeight - config.bottom;
            },

            // Element is to the right of the left edge of the viewport
            left: function _isWithin_left() {
                return elemOffset[0] >= scrollOffset[0] + config.left;
            },

            all: function _isWithin_all() {
                return (isWithin.top() && isWithin.right() && isWithin.bottom() && isWithin.left());
            }
        };

        elemOffset = (function _elemOffset() {
            var el = elem,
                x = 0,
                y = 0;

            if (el.parentNode) {
                x = el.offsetLeft;
                y = el.offsetTop;

                el = el.parentNode;
                while (el) {
                    if (el == config.container) {
                        break;
                    }

                    x += el.offsetLeft;
                    y += el.offsetTop;

                    el = el.parentNode;
                }
            }

            return [x, y];
        })();

        // Test the element against each side of the viewport that was requested
        arr = config.sides.split(' ');
        i = arr.length;
        while (i--) {
            side = arr[i].toLowerCase();
            if (/top|right|bottom|left|all/.test(side)) {
                if (isWithin[side]()) {
                    result = true;
                }
                else {
                    result = false;
                    // Quit as soon as the first failure is found
                    break;
                }
            }
        }

        return result;
    }; // end of `withinViewport()`

    var scrollOffset = function _scrollOffset(config) {
        // Whether we can use the `<html`> element for `scrollTop`
        // Unfortunately at the moment I can't find a way to do this without UA-sniffing
        var useHtmlElem = !/Chrome/.test(navigator.userAgent);
        
        var x = $(config.container).scrollLeft(),
            y = $(config.container).scrollTop();

        if (y === 0) {
            if (config.container.pageYOffset) {
                y = config.container.pageYOffset;
            }
            else if (window.pageYOffset) {
                y = window.pageYOffset;
            }
            else {
                if (config.container === document.body) {
                    if (useHtmlElem) {
                        y = (config.container.parentElement) ? $(config.container.parentElement).scrollTop() : 0;
                    }
                    else {
                        y = (config.container.parentElement) ? $(config.container.parentElement).scrollTop() : 0;
                    }
                }
                else {
                    y = (config.container.parentElement) ? $(config.container.parentElement).scrollTop() : 0;
                }
            }
        }

        if (x === 0) {
            if (config.container.pageXOffset) {
                x = config.container.pageXOffset;
            }
            else if (window.pageXOffset) {
                x = window.pageXOffset;
            }
            else {
                if (config.container === document.body) {
                    x = (config.container.parentElement) ? $(config.container.parentElement).scrollLeft() : 0;
                }
                else {
                    x = (config.container.parentElement) ? $(config.container.parentElement).scrollLeft() : 0;
                }
            }
        }

        return [x, y];
    };

    // Default settings
    withinViewport.prototype.defaults = {
        container: document.body,
        sides: 'all',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };

    withinViewport.defaults = withinViewport.prototype.defaults;

    // Make function available globally
    window.withinViewport = withinViewport;
    window.viewportScrollOffset = scrollOffset;
    window.withinViewportConfig = withinViewportConfig;

    /**
     * Optional enhancements and shortcuts
     *
     * @description Uncomment or comment these pieces as they apply to your project and coding preferences
     */

    // Shortcut methods for each side of the viewport
    // Ex: withinViewport.top(elem) is the same as withinViewport(elem, 'top')
    withinViewport.prototype.top = function _withinViewport_top(element) {
        return withinViewport(element, 'top');
    };

    withinViewport.prototype.right = function _withinViewport_right(element) {
        return withinViewport(element, 'right');
    };

    withinViewport.prototype.bottom = function _withinViewport_bottom(element) {
        return withinViewport(element, 'bottom');
    };

    withinViewport.prototype.left = function _withinViewport_left(element) {
        return withinViewport(element, 'left');
    };
})();
;/**
 * Within Viewport jQuery Plugin
 *
 * @description Companion plugin for withinViewport.js
 * @author      Craig Patik, http://patik.com/
 * @version     0.0.3
 * @date        2014-03-03
 */

(function($) {
    /**
     * $.withinViewport()
     * @description          jQuery method
     * @param  {Object}      [settings] optional settings
     * @return {Collection}  Contains all elements that were within the viewport
    */
    $.fn.withinViewport = function(settings) {
        if (typeof settings === "string") { settings = {sides: settings}; }

        var opts = $.extend({}, {sides: "all"}, settings), elems = [];
        var config = withinViewportConfig(opts);
        var scrollOffset = viewportScrollOffset(config);
        
        this.each(function() {
            if (withinViewport(this, config, scrollOffset)) {
              elems.push(this);
            }
        });

        return $(elems);
    };

    // Main custom selector
    $.extend($.expr[":"], {
        "within-viewport": function(element) {
            return withinViewport(element, "all");
        }
    });

    /**
     * Optional enhancements and shortcuts
     *
     * @description Uncomment or comment these pieces as they apply to your project and coding preferences
     */

    // Shorthand jQuery methods
    //
    $.fn.withinViewportTop = function(settings) {
        var opts;

        if (typeof settings === "string") { settings = {sides: settings}; }

        opts = $.extend({}, settings, {sides: "top"}), elems = [];

        this.each(function() {
            if (withinViewport(this, opts)) {
                elems.push(this);
            }
        });

        return $(elems);
    };

    $.fn.withinViewportRight = function(settings) {
        var opts;

        if (typeof settings === "string") { settings = {sides: settings}; }

        opts = $.extend({}, settings, {sides: "right"}), elems = [];

        this.each(function() {
            if (withinViewport(this, opts)) {
              elems.push(this);
            }
        });

        return $(elems);
    };

    $.fn.withinViewportBottom = function(settings) {
        var opts;

        if (typeof settings === "string") { settings = {sides: settings}; }

        opts = $.extend({}, settings, {sides: "bottom"}), elems = [];

        this.each(function() {
            if (withinViewport(this, opts)) {
                elems.push(this);
            }
        });

        return $(elems);
    };

    $.fn.withinViewportLeft = function(settings) {
        var opts;

        if (typeof settings === "string") { settings = {sides: settings}; }

        opts = $.extend({}, settings, {sides: "left"}), elems = [];

        this.each(function() {
            if (withinViewport(this, opts)) {
                elems.push(this);
            }
        });

        return $(elems);
    };

    // Custom jQuery selectors
    $.extend($.expr[":"], {
        "within-viewport-top": function(element) {
            return withinViewport(element, "top");
        },
        "within-viewport-right": function(element) {
            return withinViewport(element, "right");
        },
        "within-viewport-bottom": function(element) {
            return withinViewport(element, "bottom");
        },
        "within-viewport-left": function(element) {
            return withinViewport(element, "left");
        }
        // Example custom selector:
        //,
        // "within-viewport-top-left-45": function(element) {
        //     return withinViewport(element, {sides:'top left', top: 45, left: 45});
        // }
    });
}(jQuery));
;/*
 * jPlayer Plugin for jQuery JavaScript Library
 * http://www.jplayer.org
 *
 * Copyright (c) 2009 - 2014 Happyworm Ltd
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 *
 * Author: Mark J Panaghiston
 * Version: 2.6.0
 * Date: 2nd April 2014
 */

/* Code verified using http://www.jshint.com/ */
/*jshint asi:false, bitwise:false, boss:false, browser:true, curly:true, debug:false, eqeqeq:true, eqnull:false, evil:false, forin:false, immed:false, jquery:true, laxbreak:false, newcap:true, noarg:true, noempty:true, nonew:true, onevar:false, passfail:false, plusplus:false, regexp:false, undef:true, sub:false, strict:false, white:false, smarttabs:true */
/*global define:false, ActiveXObject:false, alert:false */

/* Support for Zepto 1.0 compiled with optional data module.
 * For AMD support, you will need to manually switch the 2 lines in the code below.
 * Search terms: "jQuery Switch" and "Zepto Switch"
 */

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['jquery'], factory); // jQuery Switch
		// define(['zepto'], factory); // Zepto Switch
	} else {
		// Browser globals
		if(root.jQuery) { // Use jQuery if available
			factory(root.jQuery);
		} else { // Otherwise, use Zepto
			factory(root.Zepto);
		}
	}
}(this, function ($, undefined) {

	// Adapted from jquery.ui.widget.js (1.8.7): $.widget.bridge - Tweaked $.data(this,XYZ) to $(this).data(XYZ) for Zepto
	$.fn.jPlayer = function( options ) {
		var name = "jPlayer";
		var isMethodCall = typeof options === "string",
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		// prevent calls to internal methods
		if ( isMethodCall && options.charAt( 0 ) === "_" ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
				var instance = $(this).data( name ),
					methodValue = instance && $.isFunction( instance[options] ) ?
						instance[ options ].apply( instance, args ) :
						instance;
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $(this).data( name );
				if ( instance ) {
					// instance.option( options || {} )._init(); // Orig jquery.ui.widget.js code: Not recommend for jPlayer. ie., Applying new options to an existing instance (via the jPlayer constructor) and performing the _init(). The _init() is what concerns me. It would leave a lot of event handlers acting on jPlayer instance and the interface.
					instance.option( options || {} ); // The new constructor only changes the options. Changing options only has basic support atm.
				} else {
					$(this).data( name, new $.jPlayer( options, this ) );
				}
			});
		}

		return returnValue;
	};

	$.jPlayer = function( options, element ) {
		// allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this.element = $(element);
			this.options = $.extend(true, {},
				this.options,
				options
			);
			var self = this;
			this.element.bind( "remove.jPlayer", function() {
				self.destroy();
			});
			this._init();
		}
	};
	// End of: (Adapted from jquery.ui.widget.js (1.8.7))

	// Zepto is missing one of the animation methods.
	if(typeof $.fn.stop !== 'function') {
		$.fn.stop = function() {};
	}

	// Emulated HTML5 methods and properties
	$.jPlayer.emulateMethods = "load play pause";
	$.jPlayer.emulateStatus = "src readyState networkState currentTime duration paused ended playbackRate";
	$.jPlayer.emulateOptions = "muted volume";

	// Reserved event names generated by jPlayer that are not part of the HTML5 Media element spec
	$.jPlayer.reservedEvent = "ready flashreset resize repeat error warning";

	// Events generated by jPlayer
	$.jPlayer.event = {};
	$.each(
		[
			'ready',
			'setmedia', // Fires when the media is set
			'resize', // Occurs when the size changes through a full/restore screen operation or if the size/sizeFull options are changed.
			'repeat', // Occurs when the repeat status changes. Usually through clicks on the repeat button of the interface.
			'click', // Occurs when the user clicks on one of the following: poster image, html video, cordova video.
			'error', // Event error code in event.jPlayer.error.type. See $.jPlayer.error
			'warning', // Event warning code in event.jPlayer.warning.type. See $.jPlayer.warning

			// Other events match HTML5 spec.
			'loadstart',
			'progress',
			'suspend',
			'abort',
			'emptied',
			'stalled',
			'play',
			'pause',
			'loadedmetadata',
			'loadeddata',
			'waiting',
			'playing',
			'canplay',
			'canplaythrough',
			'seeking',
			'seeked',
			'timeupdate',
			'ended',
			'ratechange',
			'durationchange',
			'volumechange'
		],
		function() {
			$.jPlayer.event[ this ] = 'jPlayer_' + this;
		}
	);

	$.jPlayer.htmlEvent = [ // These HTML events are bubbled through to the jPlayer event, without any internal action.
		"loadstart",
		// "progress", // jPlayer uses internally before bubbling.
		// "suspend", // jPlayer uses internally before bubbling.
		"abort",
		// "error", // jPlayer uses internally before bubbling.
		"emptied",
		"stalled",
		// "play", // jPlayer uses internally before bubbling.
		// "pause", // jPlayer uses internally before bubbling.
		"loadedmetadata",
		"loadeddata",
		// "waiting", // jPlayer uses internally before bubbling.
		// "playing", // jPlayer uses internally before bubbling.
		"canplay",
		"canplaythrough"
		// "seeking", // jPlayer uses internally before bubbling.
		// "seeked", // jPlayer uses internally before bubbling.
		// "timeupdate", // jPlayer uses internally before bubbling.
		// "ended", // jPlayer uses internally before bubbling.
		// "ratechange" // jPlayer uses internally before bubbling.
		// "durationchange" // jPlayer uses internally before bubbling.
		// "volumechange" // jPlayer uses internally before bubbling.
	];

	$.jPlayer.pause = function() {
		$.each($.jPlayer.prototype.instances, function(i, element) {
			if(element.data("jPlayer").status.srcSet) { // Check that media is set otherwise would cause error event.
				element.jPlayer("pause");
			}
		});
	};

	// Default for jPlayer option.timeFormat
	$.jPlayer.timeFormat = {
		showHour: false,
		showMin: true,
		showSec: true,
		padHour: false,
		padMin: true,
		padSec: true,
		sepHour: ":",
		sepMin: ":",
		sepSec: ""
	};
	var ConvertTime = function() {
		this.init();
	};
	ConvertTime.prototype = {
		init: function() {
			this.options = {
				timeFormat: $.jPlayer.timeFormat
			};
		},
		time: function(s) { // function used on jPlayer.prototype._convertTime to enable per instance options.
			s = (s && typeof s === 'number') ? s : 0;

			var myTime = new Date(s * 1000),
				hour = myTime.getUTCHours(),
				min = this.options.timeFormat.showHour ? myTime.getUTCMinutes() : myTime.getUTCMinutes() + hour * 60,
				sec = this.options.timeFormat.showMin ? myTime.getUTCSeconds() : myTime.getUTCSeconds() + min * 60,
				strHour = (this.options.timeFormat.padHour && hour < 10) ? "0" + hour : hour,
				strMin = (this.options.timeFormat.padMin && min < 10) ? "0" + min : min,
				strSec = (this.options.timeFormat.padSec && sec < 10) ? "0" + sec : sec,
				strTime = "";

			strTime += this.options.timeFormat.showHour ? strHour + this.options.timeFormat.sepHour : "";
			strTime += this.options.timeFormat.showMin ? strMin + this.options.timeFormat.sepMin : "";
			strTime += this.options.timeFormat.showSec ? strSec + this.options.timeFormat.sepSec : "";

			return strTime;
		}
	};
	var myConvertTime = new ConvertTime();
	$.jPlayer.convertTime = function(s) {
		return myConvertTime.time(s);
	};

	// Adapting jQuery 1.4.4 code for jQuery.browser. Required since jQuery 1.3.2 does not detect Chrome as webkit.
	$.jPlayer.uaBrowser = function( userAgent ) {
		var ua = userAgent.toLowerCase();

		// Useragent RegExp
		var rwebkit = /(webkit)[ \/]([\w.]+)/;
		var ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/;
		var rmsie = /(msie) ([\w.]+)/;
		var rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/;

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	};

	// Platform sniffer for detecting mobile devices
	$.jPlayer.uaPlatform = function( userAgent ) {
		var ua = userAgent.toLowerCase();

		// Useragent RegExp
		var rplatform = /(ipad|iphone|ipod|android|blackberry|playbook|windows ce|webos)/;
		var rtablet = /(ipad|playbook)/;
		var randroid = /(android)/;
		var rmobile = /(mobile)/;

		var platform = rplatform.exec( ua ) || [];
		var tablet = rtablet.exec( ua ) ||
			!rmobile.exec( ua ) && randroid.exec( ua ) ||
			[];

		if(platform[1]) {
			platform[1] = platform[1].replace(/\s/g, "_"); // Change whitespace to underscore. Enables dot notation.
		}

		return { platform: platform[1] || "", tablet: tablet[1] || "" };
	};

	$.jPlayer.browser = {
	};
	$.jPlayer.platform = {
	};

	var browserMatch = $.jPlayer.uaBrowser(navigator.userAgent);
	if ( browserMatch.browser ) {
		$.jPlayer.browser[ browserMatch.browser ] = true;
		$.jPlayer.browser.version = browserMatch.version;
	}
	var platformMatch = $.jPlayer.uaPlatform(navigator.userAgent);
	if ( platformMatch.platform ) {
		$.jPlayer.platform[ platformMatch.platform ] = true;
		$.jPlayer.platform.mobile = !platformMatch.tablet;
		$.jPlayer.platform.tablet = !!platformMatch.tablet;
	}

	// Internet Explorer (IE) Browser Document Mode Sniffer. Based on code at:
	// http://msdn.microsoft.com/en-us/library/cc288325%28v=vs.85%29.aspx#GetMode
	$.jPlayer.getDocMode = function() {
		var docMode;
		if ($.jPlayer.browser.msie) {
			if (document.documentMode) { // IE8 or later
				docMode = document.documentMode;
			} else { // IE 5-7
				docMode = 5; // Assume quirks mode unless proven otherwise
				if (document.compatMode) {
					if (document.compatMode === "CSS1Compat") {
						docMode = 7; // standards mode
					}
				}
			}
		}
		return docMode;
	};
	$.jPlayer.browser.documentMode = $.jPlayer.getDocMode();

	$.jPlayer.nativeFeatures = {
		init: function() {

			/* Fullscreen function naming influenced by W3C naming.
			 * No support for: Mozilla Proposal: https://wiki.mozilla.org/Gecko:FullScreenAPI
			 */

			var d = document,
				v = d.createElement('video'),
				spec = {
					// http://www.w3.org/TR/fullscreen/
					w3c: [
						'fullscreenEnabled',
						'fullscreenElement',
						'requestFullscreen',
						'exitFullscreen',
						'fullscreenchange',
						'fullscreenerror'
					],
					// https://developer.mozilla.org/en-US/docs/DOM/Using_fullscreen_mode
					moz: [
						'mozFullScreenEnabled',
						'mozFullScreenElement',
						'mozRequestFullScreen',
						'mozCancelFullScreen',
						'mozfullscreenchange',
						'mozfullscreenerror'
					],
					// http://developer.apple.com/library/safari/#documentation/WebKit/Reference/ElementClassRef/Element/Element.html
					// http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/DocumentAdditionsReference/DocumentAdditions/DocumentAdditions.html
					webkit: [
						'',
						'webkitCurrentFullScreenElement',
						'webkitRequestFullScreen',
						'webkitCancelFullScreen',
						'webkitfullscreenchange',
						''
					],
					// http://developer.apple.com/library/safari/#documentation/AudioVideo/Reference/HTMLVideoElementClassReference/HTMLVideoElement/HTMLVideoElement.html
					// https://developer.apple.com/library/safari/samplecode/HTML5VideoEventFlow/Listings/events_js.html#//apple_ref/doc/uid/DTS40010085-events_js-DontLinkElementID_5
					// Events: 'webkitbeginfullscreen' and 'webkitendfullscreen'
					webkitVideo: [
						'webkitSupportsFullscreen',
						'webkitDisplayingFullscreen',
						'webkitEnterFullscreen',
						'webkitExitFullscreen',
						'',
						''
					]
				},
				specOrder = [
					'w3c',
					'moz',
					'webkit',
					'webkitVideo'
				],
				fs, i, il;

			this.fullscreen = fs = {
				support: {
					w3c: !!d[spec.w3c[0]],
					moz: !!d[spec.moz[0]],
					webkit: typeof d[spec.webkit[3]] === 'function',
					webkitVideo: typeof v[spec.webkitVideo[2]] === 'function'
				},
				used: {}
			};

			// Store the name of the spec being used and as a handy boolean.
			for(i = 0, il = specOrder.length; i < il; i++) {
				var n = specOrder[i];
				if(fs.support[n]) {
					fs.spec = n;
					fs.used[n] = true;
					break;
				}
			}

			if(fs.spec) {
				var s = spec[fs.spec];
				fs.api = {
					fullscreenEnabled: true,
					fullscreenElement: function(elem) {
						elem = elem ? elem : d; // Video element required for webkitVideo
						return elem[s[1]];
					},
					requestFullscreen: function(elem) {
						return elem[s[2]]();
					},
					exitFullscreen: function(elem) {
						elem = elem ? elem : d; // Video element required for webkitVideo
						return elem[s[3]]();
					}
				};
				fs.event = {
					fullscreenchange: s[4],
					fullscreenerror: s[5]
				};
			} else {
				fs.api = {
					fullscreenEnabled: false,
					fullscreenElement: function() {
						return null;
					},
					requestFullscreen: function() {},
					exitFullscreen: function() {}
				};
				fs.event = {};
			}
		}
	};
	$.jPlayer.nativeFeatures.init();

	// The keyboard control system.

	// The current jPlayer instance in focus.
	$.jPlayer.focus = null;

	// The list of element node names to ignore with key controls.
	$.jPlayer.keyIgnoreElementNames = "INPUT TEXTAREA";

	// The function that deals with key presses.
	var keyBindings = function(event) {

		var f = $.jPlayer.focus,
			ignoreKey;

		// A jPlayer instance must be in focus. ie., keyEnabled and the last one played.
		if(f) {
			// What generated the key press?
			$.each( $.jPlayer.keyIgnoreElementNames.split(/\s+/g), function(i, name) {
				// The strings should already be uppercase.
				if(event.target.nodeName.toUpperCase() === name.toUpperCase()) {
					ignoreKey = true;
					return false; // exit each.
				}
			});
			if(!ignoreKey) {
				// See if the key pressed matches any of the bindings.
				$.each(f.options.keyBindings, function(action, binding) {
					// The binding could be a null when the default has been disabled. ie., 1st clause in if()
					if(binding && event.which === binding.key && $.isFunction(binding.fn)) {
						event.preventDefault(); // Key being used by jPlayer, so prevent default operation.
						binding.fn(f);
						return false; // exit each.
					}
				});
			}
		}
	};

	$.jPlayer.keys = function(en) {
		var event = "keydown.jPlayer";
		// Remove any binding, just in case enabled more than once.
		$(document.documentElement).unbind(event);
		if(en) {
			$(document.documentElement).bind(event, keyBindings);
		}
	};

	// Enable the global key control handler ready for any jPlayer instance with the keyEnabled option enabled.
	$.jPlayer.keys(true);

	$.jPlayer.prototype = {
		count: 0, // Static Variable: Change it via prototype.
		version: { // Static Object
			script: "2.6.0"
		},
		options: { // Instanced in $.jPlayer() constructor
			solution: "html, cordova", // Valid solutions: html, cordova. Order defines priority. 1st is highest,
			supplied: "mp3", // Defines which formats jPlayer will try and support and the priority by the order. 1st is highest,
			preload: 'metadata',  // HTML5 Spec values: none, metadata, auto.
			volume: 0.8, // The volume. Number 0 to 1.
			muted: false,
			remainingDuration: false, // When true, the remaining time is shown in the duration GUI element.
			toggleDuration: false, // When true, clicks on the duration toggle between the duration and remaining display.
			playbackRate: 1,
			defaultPlaybackRate: 1,
			minPlaybackRate: 0.5,
			maxPlaybackRate: 4,
			wmode: "opaque", // Valid wmode: window, transparent, opaque, direct, gpu. 
			backgroundColor: "#000000", // To define the jPlayer div and Flash background color.
			cssSelectorAncestor: "#jp_container_1",
			cssSelector: { // * denotes properties that should only be required when video media type required. _cssSelector() would require changes to enable splitting these into Audio and Video defaults.
				videoPlay: ".jp-video-play", // *
				play: ".jp-play",
				pause: ".jp-pause",
				stop: ".jp-stop",
				seekBar: ".jp-seek-bar",
				playBar: ".jp-play-bar",
				mute: ".jp-mute",
				unmute: ".jp-unmute",
				volumeBar: ".jp-volume-bar",
				volumeBarValue: ".jp-volume-bar-value",
				volumeMax: ".jp-volume-max",
				playbackRateBar: ".jp-playback-rate-bar",
				playbackRateBarValue: ".jp-playback-rate-bar-value",
				currentTime: ".jp-current-time",
				duration: ".jp-duration",
				title: ".jp-title",
				fullScreen: ".jp-full-screen", // *
				restoreScreen: ".jp-restore-screen", // *
				repeat: ".jp-repeat",
				repeatOff: ".jp-repeat-off",
				gui: ".jp-gui", // The interface used with autohide feature.
				noSolution: ".jp-no-solution" // For error feedback when jPlayer cannot find a solution.
			},
			smoothPlayBar: false, // Smooths the play bar transitions, which affects clicks and short media with big changes per second.
			fullScreen: false, // Native Full Screen
			fullWindow: false,
			autohide: {
				restored: false, // Controls the interface autohide feature.
				full: true, // Controls the interface autohide feature.
				fadeIn: 200, // Milliseconds. The period of the fadeIn anim.
				fadeOut: 600, // Milliseconds. The period of the fadeOut anim.
				hold: 1000 // Milliseconds. The period of the pause before autohide beings.
			},
			loop: false,
			repeat: function(event) { // The default jPlayer repeat event handler
				if(event.jPlayer.options.loop) {
					$(this).unbind(".jPlayerRepeat").bind($.jPlayer.event.ended + ".jPlayer.jPlayerRepeat", function() {
						$(this).jPlayer("play");
					});
				} else {
					$(this).unbind(".jPlayerRepeat");
				}
			},
			nativeVideoControls: {
				// Works well on standard browsers.
				// Phone and tablet browsers can have problems with the controls disappearing.
			},
			noFullWindow: {
				msie: /msie [0-6]\./,
				ipad: /ipad.*?os [0-4]\./,
				iphone: /iphone/,
				ipod: /ipod/,
				android_pad: /android [0-3]\.(?!.*?mobile)/,
				android_phone: /android.*?mobile/,
				blackberry: /blackberry/,
				windows_ce: /windows ce/,
				iemobile: /iemobile/,
				webos: /webos/
			},
			noVolume: {
				ipad: /ipad/,
				iphone: /iphone/,
				ipod: /ipod/,
				android_pad: /android(?!.*?mobile)/,
				android_phone: /android.*?mobile/,
				blackberry: /blackberry/,
				windows_ce: /windows ce/,
				iemobile: /iemobile/,
				webos: /webos/,
				playbook: /playbook/
			},
			timeFormat: {
				// Specific time format for this instance. The supported options are defined in $.jPlayer.timeFormat
				// For the undefined options we use the default from $.jPlayer.timeFormat
			},
			keyEnabled: false, // Enables keyboard controls.
			audioFullScreen: false, // Enables keyboard controls to enter full screen with audio media.
			keyBindings: { // The key control object, defining the key codes and the functions to execute.
				// The parameter, f = $.jPlayer.focus, will be checked truethy before attempting to call any of these functions.
				// Properties may be added to this object, in key/fn pairs, to enable other key controls. EG, for the playlist add-on.
				play: {
					key: 32, // space
					fn: function(f) {
						if(f.status.paused) {
							f.play();
						} else {
							f.pause();
						}
					}
				},
				fullScreen: {
					key: 13, // enter
					fn: function(f) {
						if(f.status.video || f.options.audioFullScreen) {
							f._setOption("fullScreen", !f.options.fullScreen);
						}
					}
				},
				muted: {
					key: 8, // backspace
					fn: function(f) {
						f._muted(!f.options.muted);
					}
				},
				volumeUp: {
					key: 38, // UP
					fn: function(f) {
						f.volume(f.options.volume + 0.1);
					}
				},
				volumeDown: {
					key: 40, // DOWN
					fn: function(f) {
						f.volume(f.options.volume - 0.1);
					}
				}
			},
			verticalVolume: false, // Calculate volume from the bottom of the volume bar. Default is from the left. Also volume affects either width or height.
			verticalPlaybackRate: false,
			globalVolume: false, // Set to make volume and muted changes affect all jPlayer instances with this option enabled
			idPrefix: "jp", // Prefix for the ids of html elements created by jPlayer. For flash, this must not include characters: . - + * / \
			noConflict: "jQuery",
			emulateHtml: false, // Emulates the HTML5 Media element on the jPlayer element.
			consoleAlerts: true, // Alerts are sent to the console.log() instead of alert().
			errorAlerts: false,
			warningAlerts: false
		},
		optionsAudio: {
			size: {
				width: "0px",
				height: "0px",
				cssClass: ""
			},
			sizeFull: {
				width: "0px",
				height: "0px",
				cssClass: ""
			}
		},
		optionsVideo: {
			size: {
				width: "480px",
				height: "270px",
				cssClass: "jp-video-270p"
			},
			sizeFull: {
				width: "100%",
				height: "100%",
				cssClass: "jp-video-full"
			}
		},
		instances: {}, // Static Object
		status: { // Instanced in _init()
			src: "",
			media: {},
			paused: true,
			format: {},
			formatType: "",
			waitForPlay: true, // Same as waitForLoad except in case where preloading.
			waitForLoad: true,
			srcSet: false,
			video: false, // True if playing a video
			seekPercent: 0,
			currentPercentRelative: 0,
			currentPercentAbsolute: 0,
			currentTime: 0,
			duration: 0,
			remaining: 0,
			videoWidth: 0, // Intrinsic width of the video in pixels.
			videoHeight: 0, // Intrinsic height of the video in pixels.
			readyState: 0,
			networkState: 0,
			playbackRate: 1, // Warning - Now both an option and a status property
			ended: 0

/*		Persistant status properties created dynamically at _init():
			width
			height
			cssClass
			nativeVideoControls
			noFullWindow
			noVolume
			playbackRateEnabled // Warning - Technically, we can have both Flash and HTML, so this might not be correct if the Flash is active. That is a niche case.
*/
		},

		internal: { // Instanced in _init()
			ready: false
			// instance: undefined
			// domNode: undefined
			// htmlDlyCmdId: undefined
			// autohideId: undefined
			// cmdsIgnored
		},
		solution: { // Static Object: Defines the solutions built in jPlayer.
			html: true,
			cordova: true
		},
		// 'MPEG-4 support' : canPlayType('video/mp4; codecs="mp4v.20.8"')
		format: { // Static Object
			mp3: {
				codec: 'audio/mpeg; codecs="mp3"',
				cordovaCanPlay: true,
				media: 'audio'
			},
			m4a: { // AAC / MP4
				codec: 'audio/mp4; codecs="mp4a.40.2"',
				cordovaCanPlay: true,
				media: 'audio'
			},
			m3u8a: { // AAC / MP4 / Apple HLS
				codec: 'application/vnd.apple.mpegurl; codecs="mp4a.40.2"',
				cordovaCanPlay: false,
				media: 'audio'
			},
			m3ua: { // M3U
				codec: 'audio/mpegurl',
				cordovaCanPlay: false,
				media: 'audio'
			},
			oga: { // OGG
				codec: 'audio/ogg; codecs="vorbis, opus"',
				cordovaCanPlay: false,
				media: 'audio'
			},
			flac: { // FLAC
				codec: 'audio/x-flac',
				cordovaCanPlay: false,
				media: 'audio'
			},
			wav: { // PCM
				codec: 'audio/wav; codecs="1"',
				cordovaCanPlay: true,
				media: 'audio'
			},
			webma: { // WEBM
				codec: 'audio/webm; codecs="vorbis"',
				cordovaCanPlay: false,
				media: 'audio'
			},
			fla: { // FLV / F4A
				codec: 'audio/x-flv',
				cordovaCanPlay: true,
				media: 'audio'
			},
			rtmpa: { // RTMP AUDIO
				codec: 'audio/rtmp; codecs="rtmp"',
				cordovaCanPlay: true,
				media: 'audio'
			},
			m4v: { // H.264 / MP4
				codec: 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
				cordovaCanPlay: true,
				media: 'video'
			},
			m3u8v: { // H.264 / AAC / MP4 / Apple HLS
				codec: 'application/vnd.apple.mpegurl; codecs="avc1.42E01E, mp4a.40.2"',
				cordovaCanPlay: false,
				media: 'video'
			},
			m3uv: { // M3U
				codec: 'audio/mpegurl',
				cordovaCanPlay: false,
				media: 'video'
			},
			ogv: { // OGG
				codec: 'video/ogg; codecs="theora, vorbis"',
				cordovaCanPlay: false,
				media: 'video'
			},
			webmv: { // WEBM
				codec: 'video/webm; codecs="vorbis, vp8"',
				cordovaCanPlay: false,
				media: 'video'
			},
			flv: { // FLV / F4V
				codec: 'video/x-flv',
				cordovaCanPlay: true,
				media: 'video'
			},
			rtmpv: { // RTMP VIDEO
				codec: 'video/rtmp; codecs="rtmp"',
				cordovaCanPlay: true,
				media: 'video'
			}
		},
		_init: function() {
			var self = this;
			
			this.element.empty();
			
			this.status = $.extend({}, this.status); // Copy static to unique instance.
			this.internal = $.extend({}, this.internal); // Copy static to unique instance.

			// Initialize the time format
			this.options.timeFormat = $.extend({}, $.jPlayer.timeFormat, this.options.timeFormat);

			// On iOS, assume commands will be ignored before user initiates them.
			this.internal.cmdsIgnored = $.jPlayer.platform.ipad || $.jPlayer.platform.iphone || $.jPlayer.platform.ipod;

			this.internal.domNode = this.element.get(0);

			// Add key bindings focus to 1st jPlayer instanced with key control enabled.
			if(this.options.keyEnabled && !$.jPlayer.focus) {
				$.jPlayer.focus = this;
			}

			// A fix for Android where older (2.3) and even some 4.x devices fail to work when changing the *audio* SRC and then playing immediately.
			this.androidFix = {
				setMedia: false, // True when media set
				play: false, // True when a progress event will instruct the media to play
				pause: false, // True when a progress event will instruct the media to pause at a time.
				time: NaN // The play(time) parameter
			};
			if($.jPlayer.platform.android) {
				this.options.preload = this.options.preload !== 'auto' ? 'metadata' : 'auto'; // Default to metadata, but allow auto.
			}

			this.formats = []; // Array based on supplied string option. Order defines priority.
			this.solutions = []; // Array based on solution string option. Order defines priority.
			this.require = {}; // Which media types are required: video, audio.
			
			this.htmlElement = {}; // DOM elements created by jPlayer
			this.html = {}; // In _init()'s this.desired code and setmedia(): Accessed via this[solution], where solution from this.solutions array.
			this.html.audio = {};
			this.html.video = {};
			this.cordova = {};
                        
			this.css = {};
			this.css.cs = {}; // Holds the css selector strings
			this.css.jq = {}; // Holds jQuery selectors. ie., $(css.cs.method)

			this.ancestorJq = []; // Holds jQuery selector of cssSelectorAncestor. Init would use $() instead of [], but it is only 1.4+

			this.options.volume = this._limitValue(this.options.volume, 0, 1); // Limit volume value's bounds.

			// Create the formats array, with prority based on the order of the supplied formats string
			$.each(this.options.supplied.toLowerCase().split(","), function(index1, value1) {
				var format = value1.replace(/^\s+|\s+$/g, ""); //trim
				if(self.format[format]) { // Check format is valid.
					var dupFound = false;
					$.each(self.formats, function(index2, value2) { // Check for duplicates
						if(format === value2) {
							dupFound = true;
							return false;
						}
					});
					if(!dupFound) {
						self.formats.push(format);
					}
				}
			});

			// Create the solutions array, with prority based on the order of the solution string
			$.each(this.options.solution.toLowerCase().split(","), function(index1, value1) {
				var solution = value1.replace(/^\s+|\s+$/g, ""); //trim
				if(self.solution[solution]) { // Check solution is valid.
					var dupFound = false;
					$.each(self.solutions, function(index2, value2) { // Check for duplicates
						if(solution === value2) {
							dupFound = true;
							return false;
						}
					});
					if(!dupFound) {
						self.solutions.push(solution);
					}
				}
			});

			this.internal.instance = "jp_" + this.count;
			this.instances[this.internal.instance] = this.element;

			// Check the jPlayer div has an id and create one if required. Important for Flash to know the unique id for comms.
			if(!this.element.attr("id")) {
				this.element.attr("id", this.options.idPrefix + "_jplayer_" + this.count);
			}

			this.internal.self = $.extend({}, {
				id: this.element.attr("id"),
				jq: this.element
			});
			this.internal.audio = $.extend({}, {
				id: this.options.idPrefix + "_audio_" + this.count,
				jq: undefined
			});
			this.internal.video = $.extend({}, {
				id: this.options.idPrefix + "_video_" + this.count,
				jq: undefined
			});
			this.internal.poster = $.extend({}, {
				id: this.options.idPrefix + "_poster_" + this.count,
				jq: undefined
			});

			// Register listeners defined in the constructor
			$.each($.jPlayer.event, function(eventName,eventType) {
				if(self.options[eventName] !== undefined) {
					self.element.bind(eventType + ".jPlayer", self.options[eventName]); // With .jPlayer namespace.
					self.options[eventName] = undefined; // Destroy the handler pointer copy on the options. Reason, events can be added/removed in other ways so this could be obsolete and misleading.
				}
			});

			// Determine if we require solutions for audio, video or both media types.
			this.require.audio = false;
			this.require.video = false;
			$.each(this.formats, function(priority, format) {
				self.require[self.format[format].media] = true;
			});

			// Now required types are known, finish the options default settings.
			if(this.require.video) {
				this.options = $.extend(true, {},
					this.optionsVideo,
					this.options
				);
			} else {
				this.options = $.extend(true, {},
					this.optionsAudio,
					this.options
				);
			}
			this._setSize(); // update status and jPlayer element size

			// Determine the status for Blocklisted options.
			this.status.nativeVideoControls = this._uaBlocklist(this.options.nativeVideoControls);
			this.status.noFullWindow = this._uaBlocklist(this.options.noFullWindow);
			this.status.noVolume = this._uaBlocklist(this.options.noVolume);

			// Create event handlers if native fullscreen is supported
			if($.jPlayer.nativeFeatures.fullscreen.api.fullscreenEnabled) {
				this._fullscreenAddEventListeners();
			}

			// The native controls are only for video and are disabled when audio is also used.
			this._restrictNativeVideoControls();

			// Create the poster image.
			this.htmlElement.poster = document.createElement('img');
			this.htmlElement.poster.id = this.internal.poster.id;
			this.htmlElement.poster.onload = function() { // Note that this did not work on Firefox 3.6: poster.addEventListener("onload", function() {}, false); Did not investigate x-browser.
				if(!self.status.video || self.status.waitForPlay) {
					self.internal.poster.jq.show();
				}
			};
			this.element.append(this.htmlElement.poster);
			this.internal.poster.jq = $("#" + this.internal.poster.id);
			this.internal.poster.jq.css({'width': this.status.width, 'height': this.status.height});
			this.internal.poster.jq.hide();
			this.internal.poster.jq.bind("click.jPlayer", function() {
				self._trigger($.jPlayer.event.click);
			});
			
			// Generate the required media elements
			this.html.audio.available = false;
			if(this.require.audio) { // If a supplied format is audio
				this.htmlElement.audio = document.createElement('audio');
				this.htmlElement.audio.id = this.internal.audio.id;
				this.html.audio.available = !!this.htmlElement.audio.canPlayType && this._testCanPlayType(this.htmlElement.audio); // Test is for IE9 on Win Server 2008.
			}
			this.html.video.available = false;
			if(this.require.video) { // If a supplied format is video
				this.htmlElement.video = document.createElement('video');
				this.htmlElement.video.id = this.internal.video.id;
				this.html.video.available = !!this.htmlElement.video.canPlayType && this._testCanPlayType(this.htmlElement.video); // Test is for IE9 on Win Server 2008.
			}

			this.cordova.available = window.CordovaInstalled;

			this.html.canPlay = {};
			this.cordova.canPlay = {};
			$.each(this.formats, function(priority, format) {
				self.html.canPlay[format] = self.html[self.format[format].media].available && "" !== self.htmlElement[self.format[format].media].canPlayType(self.format[format].codec);
				self.cordova.canPlay[format] = self.format[format].cordovaCanPlay && self.cordova.available;
			});
			this.html.desired = false;
			this.cordova.desired = false;
			$.each(this.solutions, function(solutionPriority, solution) {
				if(solutionPriority === 0) {
					self[solution].desired = true;
				} else {
					var audioCanPlay = false;
					var videoCanPlay = false;
					$.each(self.formats, function(formatPriority, format) {
						if(self[self.solutions[0]].canPlay[format]) { // The other solution can play
							if(self.format[format].media === 'video') {
								videoCanPlay = true;
							} else {
								audioCanPlay = true;
							}
						}
					});
					self[solution].desired = (self.require.audio && !audioCanPlay) || (self.require.video && !videoCanPlay);
				}
			});
			// This is what jPlayer will support, based on solution and supplied.
			this.html.support = {};
			this.cordova.support = {};
			$.each(this.formats, function(priority, format) {
				self.html.support[format] = self.html.canPlay[format] && self.html.desired;
				self.cordova.support[format] = self.cordova.canPlay[format] && self.cordova.desired;
			});
			// If jPlayer is supporting any format in a solution, then the solution is used.
			this.html.used = false;
			this.cordova.used = false;
			$.each(this.solutions, function(solutionPriority, solution) {
				$.each(self.formats, function(formatPriority, format) {
					if(self[solution].support[format]) {
						self[solution].used = true;
                                                return false;
					}
				});
			});

			// Init solution active state and the event gates to false.
			this._resetActive();
			this._resetGate();

			// Set up the css selectors for the control and feedback entities.
			this._cssSelectorAncestor(this.options.cssSelectorAncestor);
			
			// If neither html nor flash are being used by this browser, then media playback is not possible. Trigger an error event.
			if(!(this.html.used || this.cordova.used)) {
				this._error( {
					type: $.jPlayer.error.NO_SOLUTION, 
					context: "{solution:'" + this.options.solution + "', supplied:'" + this.options.supplied + "'}",
					message: $.jPlayer.errorMsg.NO_SOLUTION,
					hint: $.jPlayer.errorHint.NO_SOLUTION
				});
				if(this.css.jq.noSolution.length) {
					this.css.jq.noSolution.show();
				}
			} else {
				if(this.css.jq.noSolution.length) {
					this.css.jq.noSolution.hide();
				}
			}

			// Add the cordova solution if it is being used.
			if(this.cordova.used) {

			}

			// Setup playbackRate ability before using _addHtmlEventListeners()
			if(this.html.used && !this.cordova.used) { // If only HTML
				// Using the audio element capabilities for playbackRate. ie., Assuming video element is the same.
				this.status.playbackRateEnabled = this._testPlaybackRate('audio');
			} else {
				this.status.playbackRateEnabled = false;
			}

			this._updatePlaybackRate();

			// Add the HTML solution if being used.
			if(this.html.used) {

				// The HTML Audio handlers
				if(this.html.audio.available) {
					this._addHtmlEventListeners(this.htmlElement.audio, this.html.audio);
					this.element.append(this.htmlElement.audio);
					this.internal.audio.jq = $("#" + this.internal.audio.id);
				}

				// The HTML Video handlers
				if(this.html.video.available) {
					this._addHtmlEventListeners(this.htmlElement.video, this.html.video);
					this.element.append(this.htmlElement.video);
					this.internal.video.jq = $("#" + this.internal.video.id);
					if(this.status.nativeVideoControls) {
						this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
					} else {
						this.internal.video.jq.css({'width':'0px', 'height':'0px'}); // Using size 0x0 since a .hide() causes issues in iOS
					}
					this.internal.video.jq.bind("click.jPlayer", function() {
						self._trigger($.jPlayer.event.click);
					});
				}
			}

			// Create the bridge that emulates the HTML Media element on the jPlayer DIV
			if( this.options.emulateHtml ) {
				this._emulateHtmlBridge();
			}

			// Initialize the interface components with the options.
			this._updateNativeVideoControls();
			// The other controls are now setup in _cssSelectorAncestor()
			if(this.css.jq.videoPlay.length) {
				this.css.jq.videoPlay.hide();
			}

			$.jPlayer.prototype.count++; // Change static variable via prototype.
                        
                        // Trigger the ready event.
                        setTimeout( function() {
                                self.internal.ready = true;
                                self.version.flash = "n/a";
                                self._trigger($.jPlayer.event.repeat); // Trigger the repeat event so its handler can initialize itself with the loop option.
                                self._trigger($.jPlayer.event.ready);
                        }, 0);
		},
		destroy: function() {
			// MJP: The background change remains. Would need to store the original to restore it correctly.
			// MJP: The jPlayer element's size change remains.

			// Clear the media to reset the GUI and stop any downloads. Streams on some browsers had persited. (Chrome)
			this.clearMedia();
			// Remove the size/sizeFull cssClass from the cssSelectorAncestor
			this._removeUiClass();
			// Remove the times from the GUI
			if(this.css.jq.currentTime.length) {
				this.css.jq.currentTime.text("");
			}
			if(this.css.jq.duration.length) {
				this.css.jq.duration.text("");
			}
			// Remove any bindings from the interface controls.
			$.each(this.css.jq, function(fn, jq) {
				// Check selector is valid before trying to execute method.
				if(jq.length) {
					jq.unbind(".jPlayer");
				}
			});
			// Remove the click handlers for $.jPlayer.event.click
			this.internal.poster.jq.unbind(".jPlayer");
			if(this.internal.video.jq) {
				this.internal.video.jq.unbind(".jPlayer");
			}
			// Remove the fullscreen event handlers
			this._fullscreenRemoveEventListeners();
			// Remove key bindings
			if(this === $.jPlayer.focus) {
				$.jPlayer.focus = null;
			}
			// Destroy the HTML bridge.
			if(this.options.emulateHtml) {
				this._destroyHtmlBridge();
			}
			this.element.removeData("jPlayer"); // Remove jPlayer data
			this.element.unbind(".jPlayer"); // Remove all event handlers created by the jPlayer constructor
			this.element.empty(); // Remove the inserted child elements
			
			delete this.instances[this.internal.instance]; // Clear the instance on the static instance object
		},
		enable: function() { // Plan to implement
			// options.disabled = false
		},
		disable: function () { // Plan to implement
			// options.disabled = true
		},
		_testCanPlayType: function(elem) {
			// IE9 on Win Server 2008 did not implement canPlayType(), but it has the property.
			try {
				elem.canPlayType(this.format.mp3.codec); // The type is irrelevant.
				return true;
			} catch(err) {
				return false;
			}
		},
		_testPlaybackRate: function(type) {
			// type: String 'audio' or 'video'
			var el, rate = 0.5;
			type = typeof type === 'string' ? type : 'audio';
			el = document.createElement(type);
			// Wrapping in a try/catch, just in case older HTML5 browsers throw and error.
			try {
				if('playbackRate' in el) {
					el.playbackRate = rate;
					return el.playbackRate === rate;
				} else {
					return false;
				}
			} catch(err) {
				return false;
			}
		},
		_uaBlocklist: function(list) {
			// list : object with properties that are all regular expressions. Property names are irrelevant.
			// Returns true if the user agent is matched in list.
			var	ua = navigator.userAgent.toLowerCase(),
				block = false;

			$.each(list, function(p, re) {
				if(re && re.test(ua)) {
					block = true;
					return false; // exit $.each.
				}
			});
			return block;
		},
		_restrictNativeVideoControls: function() {
			// Fallback to noFullWindow when nativeVideoControls is true and audio media is being used. Affects when both media types are used.
			if(this.require.audio) {
				if(this.status.nativeVideoControls) {
					this.status.nativeVideoControls = false;
					this.status.noFullWindow = true;
				}
			}
		},
		_updateNativeVideoControls: function() {
			if(this.html.video.available && this.html.used) {
				// Turn the HTML Video controls on/off
				this.htmlElement.video.controls = this.status.nativeVideoControls;
				// Show/hide the jPlayer GUI.
				this._updateAutohide();
				// For when option changed. The poster image is not updated, as it is dealt with in setMedia(). Acceptable degradation since seriously doubt these options will change on the fly. Can again review later.
				if(this.status.nativeVideoControls && this.require.video) {
					this.internal.poster.jq.hide();
					this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
				} else if(this.status.waitForPlay && this.status.video) {
					this.internal.poster.jq.show();
					this.internal.video.jq.css({'width': '0px', 'height': '0px'});
				}
			}
		},
		_addHtmlEventListeners: function(mediaElement, entity) {
			var self = this;
			mediaElement.preload = this.options.preload;
			mediaElement.muted = this.options.muted;
			mediaElement.volume = this.options.volume;

			if(this.status.playbackRateEnabled) {
				mediaElement.defaultPlaybackRate = this.options.defaultPlaybackRate;
				mediaElement.playbackRate = this.options.playbackRate;
			}

			// Create the event listeners
			// Only want the active entity to affect jPlayer and bubble events.
			// Using entity.gate so that object is referenced and gate property always current
			
			mediaElement.addEventListener("progress", function() {
				if(entity.gate) {
					if(self.internal.cmdsIgnored && this.readyState > 0) { // Detect iOS executed the command
						self.internal.cmdsIgnored = false;
					}
					self.androidFix.setMedia = false; // Disable the fix after the first progress event.
					if(self.androidFix.play) { // Play Android audio - performing the fix.
						self.androidFix.play = false;
						self.play(self.androidFix.time);
					}
					if(self.androidFix.pause) { // Pause Android audio at time - performing the fix.
						self.androidFix.pause = false;
						self.pause(self.androidFix.time);
					}
					self._getHtmlStatus(mediaElement);
					self._updateInterface();
					self._trigger($.jPlayer.event.progress);
				}
			}, false);
			mediaElement.addEventListener("timeupdate", function() {
				if(entity.gate) {
					self._getHtmlStatus(mediaElement);
					self._updateInterface();
					self._trigger($.jPlayer.event.timeupdate);
				}
			}, false);
			mediaElement.addEventListener("durationchange", function() {
				if(entity.gate) {
					self._getHtmlStatus(mediaElement);
					self._updateInterface();
					self._trigger($.jPlayer.event.durationchange);
				}
			}, false);
			mediaElement.addEventListener("play", function() {
				if(entity.gate) {
					self._updateButtons(true);
					self._html_checkWaitForPlay(); // So the native controls update this variable and puts the hidden interface in the correct state. Affects toggling native controls.
					self._trigger($.jPlayer.event.play);
				}
			}, false);
			mediaElement.addEventListener("playing", function() {
				if(entity.gate) {
					self._updateButtons(true);
					self._seeked();
					self._trigger($.jPlayer.event.playing);
				}
			}, false);
			mediaElement.addEventListener("pause", function() {
				if(entity.gate) {
					self._updateButtons(false);
					self._trigger($.jPlayer.event.pause);
				}
			}, false);
			mediaElement.addEventListener("waiting", function() {
				if(entity.gate) {
					self._seeking();
					self._trigger($.jPlayer.event.waiting);
				}
			}, false);
			mediaElement.addEventListener("seeking", function() {
				if(entity.gate) {
					self._seeking();
					self._trigger($.jPlayer.event.seeking);
				}
			}, false);
			mediaElement.addEventListener("seeked", function() {
				if(entity.gate) {
					self._seeked();
					self._trigger($.jPlayer.event.seeked);
				}
			}, false);
			mediaElement.addEventListener("volumechange", function() {
				if(entity.gate) {
					// Read the values back from the element as the Blackberry PlayBook shares the volume with the physical buttons master volume control.
					// However, when tested 6th July 2011, those buttons do not generate an event. The physical play/pause button does though.
					self.options.volume = mediaElement.volume;
					self.options.muted = mediaElement.muted;
					self._updateMute();
					self._updateVolume();
					self._trigger($.jPlayer.event.volumechange);
				}
			}, false);
			mediaElement.addEventListener("ratechange", function() {
				if(entity.gate) {
					self.options.defaultPlaybackRate = mediaElement.defaultPlaybackRate;
					self.options.playbackRate = mediaElement.playbackRate;
					self._updatePlaybackRate();
					self._trigger($.jPlayer.event.ratechange);
				}
			}, false);
			mediaElement.addEventListener("suspend", function() { // Seems to be the only way of capturing that the iOS4 browser did not actually play the media from the page code. ie., It needs a user gesture.
				if(entity.gate) {
					self._seeked();
					self._trigger($.jPlayer.event.suspend);
				}
			}, false);
			mediaElement.addEventListener("ended", function() {
				if(entity.gate) {
					// Order of the next few commands are important. Change the time and then pause.
					// Solves a bug in Firefox, where issuing pause 1st causes the media to play from the start. ie., The pause is ignored.
					if(!$.jPlayer.browser.webkit) { // Chrome crashes if you do this in conjunction with a setMedia command in an ended event handler. ie., The playlist demo.
						self.htmlElement.media.currentTime = 0; // Safari does not care about this command. ie., It works with or without this line. (Both Safari and Chrome are Webkit.)
					}
					self.htmlElement.media.pause(); // Pause otherwise a click on the progress bar will play from that point, when it shouldn't, since it stopped playback.
					self._updateButtons(false);
					self._getHtmlStatus(mediaElement, true); // With override true. Otherwise Chrome leaves progress at full.
					self._updateInterface();
					self._trigger($.jPlayer.event.ended);
				}
			}, false);
			mediaElement.addEventListener("error", function() {
				if(entity.gate) {
					self._updateButtons(false);
					self._seeked();
					if(self.status.srcSet) { // Deals with case of clearMedia() causing an error event.
						clearTimeout(self.internal.htmlDlyCmdId); // Clears any delayed commands used in the HTML solution.
						self.status.waitForLoad = true; // Allows the load operation to try again.
						self.status.waitForPlay = true; // Reset since a play was captured.
						if(self.status.video && !self.status.nativeVideoControls) {
							self.internal.video.jq.css({'width':'0px', 'height':'0px'});
						}
						if(self._validString(self.status.media.poster) && !self.status.nativeVideoControls) {
							self.internal.poster.jq.show();
						}
						if(self.css.jq.videoPlay.length) {
							self.css.jq.videoPlay.show();
						}
						self._error( {
							type: $.jPlayer.error.URL,
							context: self.status.src, // this.src shows absolute urls. Want context to show the url given.
							message: $.jPlayer.errorMsg.URL,
							hint: $.jPlayer.errorHint.URL
						});
					}
				}
			}, false);
			// Create all the other event listeners that bubble up to a jPlayer event from html, without being used by jPlayer.
			$.each($.jPlayer.htmlEvent, function(i, eventType) {
				mediaElement.addEventListener(this, function() {
					if(entity.gate) {
						self._trigger($.jPlayer.event[eventType]);
					}
				}, false);
			});
		},
		_getHtmlStatus: function(media, override) {
			var ct = 0, cpa = 0, sp = 0, cpr = 0;

			// Fixes the duration bug in iOS, where the durationchange event occurs when media.duration is not always correct.
			// Fixes the initial duration bug in BB OS7, where the media.duration is infinity and displays as NaN:NaN due to Date() using inifity.
			if(isFinite(media.duration)) {
				this.status.duration = media.duration;
			}

			ct = media.currentTime;
                        
                        cpa = (this.status.duration > 0) ? 100 * ct / this.status.duration : 0;
			if((typeof media.seekable === "object") && (media.seekable.length > 0)) {
				sp = (this.status.duration > 0) ? 100 * media.seekable.end(media.seekable.length-1) / this.status.duration : 100;
				cpr = (this.status.duration > 0) ? 100 * media.currentTime / media.seekable.end(media.seekable.length-1) : 0; // Duration conditional for iOS duration bug. ie., seekable.end is a NaN in that case.
			} else {
				sp = 100;
				cpr = cpa;
			}
			
			if(override) {
				ct = 0;
				cpr = 0;
				cpa = 0;
			}

			this.status.seekPercent = sp;
			this.status.currentPercentRelative = cpr;
			this.status.currentPercentAbsolute = cpa;
			this.status.currentTime = ct;

			this.status.remaining = this.status.duration - this.status.currentTime;

			this.status.videoWidth = media.videoWidth;
			this.status.videoHeight = media.videoHeight;

			this.status.readyState = media.readyState;
			this.status.networkState = media.networkState;
			this.status.playbackRate = media.playbackRate;
			this.status.ended = media.ended;
		},

                _resetStatus: function() {
			this.status = $.extend({}, this.status, $.jPlayer.prototype.status); // Maintains the status properties that persist through a reset.
		},
		_trigger: function(eventType, error, warning) { // eventType always valid as called using $.jPlayer.event.eventType
			var event = $.Event(eventType);
			event.jPlayer = {};
			event.jPlayer.version = $.extend({}, this.version);
			event.jPlayer.options = $.extend(true, {}, this.options); // Deep copy
			event.jPlayer.status = $.extend(true, {}, this.status); // Deep copy
			event.jPlayer.html = $.extend(true, {}, this.html); // Deep copy
			if(error) {
				event.jPlayer.error = $.extend({}, error);
			}
			if(warning) {
				event.jPlayer.warning = $.extend({}, warning);
			}
			this.element.trigger(event);
		},
		_updateButtons: function(playing) {
			if(playing === undefined) {
				playing = !this.status.paused;
			} else {
				this.status.paused = !playing;
			}
			if(this.css.jq.play.length && this.css.jq.pause.length) {
				if(playing) {
					this.css.jq.play.hide();
					this.css.jq.pause.show();
				} else {
					this.css.jq.play.show();
					this.css.jq.pause.hide();
				}
			}
			if(this.css.jq.restoreScreen.length && this.css.jq.fullScreen.length) {
				if(this.status.noFullWindow) {
					this.css.jq.fullScreen.hide();
					this.css.jq.restoreScreen.hide();
				} else if(this.options.fullWindow) {
					this.css.jq.fullScreen.hide();
					this.css.jq.restoreScreen.show();
				} else {
					this.css.jq.fullScreen.show();
					this.css.jq.restoreScreen.hide();
				}
			}
			if(this.css.jq.repeat.length && this.css.jq.repeatOff.length) {
				if(this.options.loop) {
					this.css.jq.repeat.hide();
					this.css.jq.repeatOff.show();
				} else {
					this.css.jq.repeat.show();
					this.css.jq.repeatOff.hide();
				}
			}
		},
		_updateInterface: function() {
			if(this.css.jq.seekBar.length) {
				this.css.jq.seekBar.width(this.status.seekPercent+"%");
			}
			if(this.css.jq.playBar.length) {
				if(this.options.smoothPlayBar) {
					this.css.jq.playBar.stop().animate({
						width: this.status.currentPercentAbsolute+"%"
					}, 250, "linear");
				} else {
					this.css.jq.playBar.width(this.status.currentPercentRelative+"%");
				}
			}
			var currentTimeText = '';
			if(this.css.jq.currentTime.length) {
				currentTimeText = this._convertTime(this.status.currentTime);
				if(currentTimeText !== this.css.jq.currentTime.text()) {
					this.css.jq.currentTime.text(this._convertTime(this.status.currentTime));
				}
			}
			var durationText = '',
				duration = this.status.duration,
				remaining = this.status.remaining;
			if(this.css.jq.duration.length) {
				if(typeof this.status.media.duration === 'string') {
					durationText = this.status.media.duration;
				} else {
					if(typeof this.status.media.duration === 'number') {
						duration = this.status.media.duration;
						remaining = duration - this.status.currentTime;
					}
					if(this.options.remainingDuration) {
						durationText = (remaining > 0 ? '-' : '') + this._convertTime(remaining);
					} else {
						durationText = this._convertTime(duration);
					}
				}
				if(durationText !== this.css.jq.duration.text()) {
					this.css.jq.duration.text(durationText);
				}
			}
		},
		_convertTime: ConvertTime.prototype.time,
		_seeking: function() {
			if(this.css.jq.seekBar.length) {
				this.css.jq.seekBar.addClass("jp-seeking-bg");
			}
		},
		_seeked: function() {
			if(this.css.jq.seekBar.length) {
				this.css.jq.seekBar.removeClass("jp-seeking-bg");
			}
		},
		_resetGate: function() {
			this.html.audio.gate = false;
			this.html.video.gate = false;
			this.cordova.gate = false;
		},
		_resetActive: function() {
			this.html.active = false;
			this.cordova.active = false;
		},
		_escapeHtml: function(s) {
			return s.split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;').split('"').join('&quot;');
		},
		_qualifyURL: function(url) {
			var el = document.createElement('div');
			el.innerHTML= '<a href="' + this._escapeHtml(url) + '">x</a>';
			return el.firstChild.href;
		},
		_absoluteMediaUrls: function(media) {
			var self = this;
			$.each(media, function(type, url) {
				if(url && self.format[type]) {
					media[type] = self._qualifyURL(url);
				}
			});
			return media;
		},
		setMedia: function(media) {
		
			/*	media[format] = String: URL of format. Must contain all of the supplied option's video or audio formats.
			 *	media.poster = String: Video poster URL.
			 *	media.track = Array: Of objects defining the track element: kind, src, srclang, label, def.
			 *	media.stream = Boolean: * NOT IMPLEMENTED * Designating actual media streams. ie., "false/undefined" for files. Plan to refresh the flash every so often.
			 */

			var	self = this,
				supported = false,
				posterChanged = this.status.media.poster !== media.poster; // Compare before reset. Important for OSX Safari as this.htmlElement.poster.src is absolute, even if original poster URL was relative.

			this._resetMedia();
			this._resetGate();
			this._resetActive();

			// Clear the Android Fix.
			this.androidFix.setMedia = false;
			this.androidFix.play = false;
			this.androidFix.pause = false;

			// Convert all media URLs to absolute URLs.
			media = this._absoluteMediaUrls(media);

			$.each(this.formats, function(formatPriority, format) {
				var isVideo = self.format[format].media === 'video';
				$.each(self.solutions, function(solutionPriority, solution) {
					if(self[solution].support[format] && self._validString(media[format])) { // Format supported in solution and url given for format.
						var isHtml = solution === 'html';

						if(isVideo) {
							if(isHtml) {
								self.html.video.gate = true;
								self._html_setVideo(media);
								self.html.active = true;
							}
							if(self.css.jq.videoPlay.length) {
								self.css.jq.videoPlay.show();
							}
							self.status.video = true;
						} else {
							if(isHtml) {
								self.html.audio.gate = true;
								self._html_setAudio(media);
								self.html.active = true;

								// Setup the Android Fix - Only for HTML audio.
								if($.jPlayer.platform.android) {
									self.androidFix.setMedia = true;
								}
							} else {
                                                                self.cordova.gate = true;
								self._cordova_setAudio(media);
								self.cordova.active = true;
							}
							if(self.css.jq.videoPlay.length) {
								self.css.jq.videoPlay.hide();
							}
							self.status.video = false;
						}
						
						supported = true;
						return false; // Exit $.each
					}
				});
				if(supported) {
					return false; // Exit $.each
				}
			});

			if(supported) {
				if(!(this.status.nativeVideoControls && this.html.video.gate)) {
					// Set poster IMG if native video controls are not being used
					// Note: With IE the IMG onload event occurs immediately when cached.
					// Note: Poster hidden by default in _resetMedia()
					if(this._validString(media.poster)) {
						if(posterChanged) { // Since some browsers do not generate img onload event.
							this.htmlElement.poster.src = media.poster;
						} else {
							this.internal.poster.jq.show();
						}
					}
				}
				if(this.css.jq.title.length) {
					if(typeof media.title === 'string') {
						this.css.jq.title.html(media.title);
						if(this.htmlElement.audio) {
							this.htmlElement.audio.setAttribute('title', media.title);
						}
						if(this.htmlElement.video) {
							this.htmlElement.video.setAttribute('title', media.title);
						}
					}
				}
				this.status.srcSet = true;
				this.status.media = $.extend({}, media);
				this._updateButtons(false);
				this._updateInterface();
				this._trigger($.jPlayer.event.setmedia);
			} else { // jPlayer cannot support any formats provided in this browser
				// Send an error event
				this._error( {
					type: $.jPlayer.error.NO_SUPPORT,
					context: "{supplied:'" + this.options.supplied + "'}",
					message: $.jPlayer.errorMsg.NO_SUPPORT,
					hint: $.jPlayer.errorHint.NO_SUPPORT
				});
			}
		},
		_resetMedia: function() {
			this._resetStatus();
			this._updateButtons(false);
			this._updateInterface();
			this._seeked();
			this.internal.poster.jq.hide();

			clearTimeout(this.internal.htmlDlyCmdId);

			if(this.html.active) {
				this._html_resetMedia();
			} else if(this.cordova.active) {
				this._cordova_resetMedia();
			}
		},
		clearMedia: function() {
			this._resetMedia();

			if(this.html.active) {
				this._html_clearMedia();
			} else if(this.cordova.active) {
				this._cordova_clearMedia();
			}

			this._resetGate();
			this._resetActive();
		},
		load: function() {
			if(this.status.srcSet) {
				if(this.html.active) {
					this._html_load();
				} else if(this.cordova.active) {
					this._cordova_load();
				}
			} else {
				this._urlNotSetError("load");
			}
		},
		focus: function() {
			if(this.options.keyEnabled) {
				$.jPlayer.focus = this;
			}
		},
		play: function(time) {
			time = (typeof time === "number") ? time : NaN; // Remove jQuery event from click handler
			if(this.status.srcSet) {
				this.focus();
				if(this.html.active) {
					this._html_play(time);
				} else if(this.cordova.active) {
					this._cordova_play(time);
				}
			} else {
				this._urlNotSetError("play");
			}
		},
		videoPlay: function() { // Handles clicks on the play button over the video poster
			this.play();
		},
		pause: function(time) {
			time = (typeof time === "number") ? time : NaN; // Remove jQuery event from click handler
			if(this.status.srcSet) {
				if(this.html.active) {
					this._html_pause(time);
				} else if(this.cordova.active) {
					this._cordova_pause(time);
				}
			} else {
				this._urlNotSetError("pause");
			}
		},
		tellOthers: function(command, conditions) {
			var self = this,
				hasConditions = typeof conditions === 'function',
				args = Array.prototype.slice.call(arguments); // Convert arguments to an Array.

			if(typeof command !== 'string') { // Ignore, since no command.
				return; // Return undefined to maintain chaining.
			}
			if(hasConditions) {
				args.splice(1, 1); // Remove the conditions from the arguments
			}

			$.each(this.instances, function() {
				// Remember that "this" is the instance's "element" in the $.each() loop.
				if(self.element !== this) { // Do not tell my instance.
					if(!hasConditions || conditions.call(this.data("jPlayer"), self)) {
						this.jPlayer.apply(this, args);
					}
				}
			});
		},
		pauseOthers: function(time) {
			this.tellOthers("pause", function() {
				// In the conditions function, the "this" context is the other instance's jPlayer object.
				return this.status.srcSet;
			}, time);
		},
		stop: function() {
			if(this.status.srcSet) {
				if(this.html.active) {
					this._html_pause(0);
				} else if(this.cordova.active) {
					this._cordova_pause(0);
				}
			} else {
				this._urlNotSetError("stop");
			}
		},
		playHead: function(p) {
			p = this._limitValue(p, 0, 100);
			if(this.status.srcSet) {
                            if(this.html.active) {
                                    this._html_playHead(p);
                            } else if(this.cordova.active) {
                                    this._cordova_playHead(p);
                            }
			} else {
				this._urlNotSetError("playHead");
			}
		},
		_muted: function(muted) {
			this.mutedWorker(muted);
			if(this.options.globalVolume) {
				this.tellOthers("mutedWorker", function() {
					// Check the other instance has global volume enabled.
					return this.options.globalVolume;
				}, muted);
			}
		},
		mutedWorker: function(muted) {
			this.options.muted = muted;
			if(this.html.used) {
				this._html_setProperty('muted', muted);
			}
			if(this.cordova.used) {
				this._cordova_mute(muted);
			}

			// The HTML solution generates this event from the media element itself.
			if(!this.html.video.gate && !this.html.audio.gate) {
				this._updateMute(muted);
				this._updateVolume(this.options.volume);
				this._trigger($.jPlayer.event.volumechange);
			}
		},
		mute: function(mute) { // mute is either: undefined (true), an event object (true) or a boolean (muted).
			mute = mute === undefined ? true : !!mute;
			this._muted(mute);
		},
		unmute: function(unmute) { // unmute is either: undefined (true), an event object (true) or a boolean (!muted).
			unmute = unmute === undefined ? true : !!unmute;
			this._muted(!unmute);
		},
		_updateMute: function(mute) {
			if(mute === undefined) {
				mute = this.options.muted;
			}
			if(this.css.jq.mute.length && this.css.jq.unmute.length) {
				if(this.status.noVolume) {
					this.css.jq.mute.hide();
					this.css.jq.unmute.hide();
				} else if(mute) {
					this.css.jq.mute.hide();
					this.css.jq.unmute.show();
				} else {
					this.css.jq.mute.show();
					this.css.jq.unmute.hide();
				}
			}
		},
		volume: function(v) {
			this.volumeWorker(v);
			if(this.options.globalVolume) {
				this.tellOthers("volumeWorker", function() {
					// Check the other instance has global volume enabled.
					return this.options.globalVolume;
				}, v);
			}
		},
		volumeWorker: function(v) {
			v = this._limitValue(v, 0, 1);
			this.options.volume = v;

			if(this.html.used) {
				this._html_setProperty('volume', v);
			}
			if(this.cordova.used) {
				this._cordova_volume(v);
			}

			// The HTML solution generates this event from the media element itself.
			if(!this.html.video.gate && !this.html.audio.gate) {
				this._updateVolume(v);
				this._trigger($.jPlayer.event.volumechange);
			}
		},
		volumeBar: function(e) { // Handles clicks on the volumeBar
			if(this.css.jq.volumeBar.length) {
				// Using $(e.currentTarget) to enable multiple volume bars
				var $bar = $(e.currentTarget),
					offset = $bar.offset(),
					x = e.pageX - offset.left,
					w = $bar.width(),
					y = $bar.height() - e.pageY + offset.top,
					h = $bar.height();
				if(this.options.verticalVolume) {
					this.volume(y/h);
				} else {
					this.volume(x/w);
				}
			}
			if(this.options.muted) {
				this._muted(false);
			}
		},
		_updateVolume: function(v) {
			if(v === undefined) {
				v = this.options.volume;
			}
			v = this.options.muted ? 0 : v;

			if(this.status.noVolume) {
				if(this.css.jq.volumeBar.length) {
					this.css.jq.volumeBar.hide();
				}
				if(this.css.jq.volumeBarValue.length) {
					this.css.jq.volumeBarValue.hide();
				}
				if(this.css.jq.volumeMax.length) {
					this.css.jq.volumeMax.hide();
				}
			} else {
				if(this.css.jq.volumeBar.length) {
					this.css.jq.volumeBar.show();
				}
				if(this.css.jq.volumeBarValue.length) {
					this.css.jq.volumeBarValue.show();
					this.css.jq.volumeBarValue[this.options.verticalVolume ? "height" : "width"]((v*100)+"%");
				}
				if(this.css.jq.volumeMax.length) {
					this.css.jq.volumeMax.show();
				}
			}
		},
		volumeMax: function() { // Handles clicks on the volume max
			this.volume(1);
			if(this.options.muted) {
				this._muted(false);
			}
		},
		_cssSelectorAncestor: function(ancestor) {
			var self = this;
			this.options.cssSelectorAncestor = ancestor;
			this._removeUiClass();
			this.ancestorJq = ancestor ? $(ancestor) : []; // Would use $() instead of [], but it is only 1.4+
			if(ancestor && this.ancestorJq.length !== 1) { // So empty strings do not generate the warning.
				this._warning( {
					type: $.jPlayer.warning.CSS_SELECTOR_COUNT,
					context: ancestor,
					message: $.jPlayer.warningMsg.CSS_SELECTOR_COUNT + this.ancestorJq.length + " found for cssSelectorAncestor.",
					hint: $.jPlayer.warningHint.CSS_SELECTOR_COUNT
				});
			}
			this._addUiClass();
			$.each(this.options.cssSelector, function(fn, cssSel) {
				self._cssSelector(fn, cssSel);
			});

			// Set the GUI to the current state.
			this._updateInterface();
			this._updateButtons();
			this._updateAutohide();
			this._updateVolume();
			this._updateMute();
		},
		_cssSelector: function(fn, cssSel) {
			var self = this;
			if(typeof cssSel === 'string') {
				if($.jPlayer.prototype.options.cssSelector[fn]) {
					if(this.css.jq[fn] && this.css.jq[fn].length) {
						this.css.jq[fn].unbind(".jPlayer");
					}
					this.options.cssSelector[fn] = cssSel;
					this.css.cs[fn] = this.options.cssSelectorAncestor + " " + cssSel;

					if(cssSel) { // Checks for empty string
						this.css.jq[fn] = $(this.css.cs[fn]);
					} else {
						this.css.jq[fn] = []; // To comply with the css.jq[fn].length check before its use. As of jQuery 1.4 could have used $() for an empty set. 
					}

					if(this.css.jq[fn].length && this[fn]) {
						var handler = function(e) {
							e.preventDefault();
							self[fn](e);
							$(this).blur();
                                                        return false;
						};
						this.css.jq[fn].bind("click.jPlayer", handler); // Using jPlayer namespace
					}

					if(cssSel && this.css.jq[fn].length !== 1) { // So empty strings do not generate the warning. ie., they just remove the old one.
						this._warning( {
							type: $.jPlayer.warning.CSS_SELECTOR_COUNT,
							context: this.css.cs[fn],
							message: $.jPlayer.warningMsg.CSS_SELECTOR_COUNT + this.css.jq[fn].length + " found for " + fn + " method.",
							hint: $.jPlayer.warningHint.CSS_SELECTOR_COUNT
						});
					}
				} else {
					this._warning( {
						type: $.jPlayer.warning.CSS_SELECTOR_METHOD,
						context: fn,
						message: $.jPlayer.warningMsg.CSS_SELECTOR_METHOD,
						hint: $.jPlayer.warningHint.CSS_SELECTOR_METHOD
					});
				}
			} else {
				this._warning( {
					type: $.jPlayer.warning.CSS_SELECTOR_STRING,
					context: cssSel,
					message: $.jPlayer.warningMsg.CSS_SELECTOR_STRING,
					hint: $.jPlayer.warningHint.CSS_SELECTOR_STRING
				});
			}
		},
		duration: function(e) {
			if(this.options.toggleDuration) {
				this._setOption("remainingDuration", !this.options.remainingDuration);
			}
		},
		seekBar: function(e) { // Handles clicks on the seekBar
			if(this.css.jq.seekBar.length) {
				// Using $(e.currentTarget) to enable multiple seek bars
				var $bar = $(e.currentTarget),
					offset = $bar.offset(),
					x = e.pageX - offset.left,
					w = $bar.width(),
					p = 100 * x / w;
				this.playHead(p);
			}
		},
		playbackRate: function(pbr) {
			this._setOption("playbackRate", pbr);
		},
		playbackRateBar: function(e) { // Handles clicks on the playbackRateBar
			if(this.css.jq.playbackRateBar.length) {
				// Using $(e.currentTarget) to enable multiple playbackRate bars
				var $bar = $(e.currentTarget),
					offset = $bar.offset(),
					x = e.pageX - offset.left,
					w = $bar.width(),
					y = $bar.height() - e.pageY + offset.top,
					h = $bar.height(),
					ratio, pbr;
				if(this.options.verticalPlaybackRate) {
					ratio = y/h;
				} else {
					ratio = x/w;
				}
				pbr = ratio * (this.options.maxPlaybackRate - this.options.minPlaybackRate) + this.options.minPlaybackRate;
				this.playbackRate(pbr);
			}
		},
		_updatePlaybackRate: function() {
			var pbr = this.options.playbackRate,
				ratio = (pbr - this.options.minPlaybackRate) / (this.options.maxPlaybackRate - this.options.minPlaybackRate);
			if(this.status.playbackRateEnabled) {
				if(this.css.jq.playbackRateBar.length) {
					this.css.jq.playbackRateBar.show();
				}
				if(this.css.jq.playbackRateBarValue.length) {
					this.css.jq.playbackRateBarValue.show();
					this.css.jq.playbackRateBarValue[this.options.verticalPlaybackRate ? "height" : "width"]((ratio*100)+"%");
				}
			} else {
				if(this.css.jq.playbackRateBar.length) {
					this.css.jq.playbackRateBar.hide();
				}
				if(this.css.jq.playbackRateBarValue.length) {
					this.css.jq.playbackRateBarValue.hide();
				}
			}
		},
		repeat: function() { // Handle clicks on the repeat button
			this._loop(true);
		},
		repeatOff: function() { // Handle clicks on the repeatOff button
			this._loop(false);
		},
		_loop: function(loop) {
			if(this.options.loop !== loop) {
				this.options.loop = loop;
				this._updateButtons();
				this._trigger($.jPlayer.event.repeat);
			}
		},

		// Options code adapted from ui.widget.js (1.8.7).  Made changes so the key can use dot notation. To match previous getData solution in jPlayer 1.
		option: function(key, value) {
			var options = key;

			 // Enables use: options().  Returns a copy of options object
			if ( arguments.length === 0 ) {
				return $.extend( true, {}, this.options );
			}

			if(typeof key === "string") {
				var keys = key.split(".");

				 // Enables use: options("someOption")  Returns a copy of the option. Supports dot notation.
				if(value === undefined) {

					var opt = $.extend(true, {}, this.options);
					for(var i = 0; i < keys.length; i++) {
						if(opt[keys[i]] !== undefined) {
							opt = opt[keys[i]];
						} else {
							this._warning( {
								type: $.jPlayer.warning.OPTION_KEY,
								context: key,
								message: $.jPlayer.warningMsg.OPTION_KEY,
								hint: $.jPlayer.warningHint.OPTION_KEY
							});
							return undefined;
						}
					}
					return opt;
				}

				 // Enables use: options("someOptionObject", someObject}).  Creates: {someOptionObject:someObject}
				 // Enables use: options("someOption", someValue).  Creates: {someOption:someValue}
				 // Enables use: options("someOptionObject.someOption", someValue).  Creates: {someOptionObject:{someOption:someValue}}

				options = {};
				var opts = options;

				for(var j = 0; j < keys.length; j++) {
					if(j < keys.length - 1) {
						opts[keys[j]] = {};
						opts = opts[keys[j]];
					} else {
						opts[keys[j]] = value;
					}
				}
			}

			 // Otherwise enables use: options(optionObject).  Uses original object (the key)

			this._setOptions(options);

			return this;
		},
		_setOptions: function(options) {
			var self = this;
			$.each(options, function(key, value) { // This supports the 2 level depth that the options of jPlayer has. Would review if we ever need more depth.
				self._setOption(key, value);
			});

			return this;
		},
		_setOption: function(key, value) {
			var self = this;

			// The ability to set options is limited at this time.

			switch(key) {
				case "volume" :
					this.volume(value);
					break;
				case "muted" :
					this._muted(value);
					break;
				case "globalVolume" :
					this.options[key] = value;
					break;
				case "cssSelectorAncestor" :
					this._cssSelectorAncestor(value); // Set and refresh all associations for the new ancestor.
					break;
				case "cssSelector" :
					$.each(value, function(fn, cssSel) {
						self._cssSelector(fn, cssSel); // NB: The option is set inside this function, after further validity checks.
					});
					break;
				case "playbackRate" :
					this.options[key] = value = this._limitValue(value, this.options.minPlaybackRate, this.options.maxPlaybackRate);
					if(this.html.used) {
						this._html_setProperty('playbackRate', value);
					}
					this._updatePlaybackRate();
					break;
				case "defaultPlaybackRate" :
					this.options[key] = value = this._limitValue(value, this.options.minPlaybackRate, this.options.maxPlaybackRate);
					if(this.html.used) {
						this._html_setProperty('defaultPlaybackRate', value);
					}
					this._updatePlaybackRate();
					break;
				case "minPlaybackRate" :
					this.options[key] = value = this._limitValue(value, 0.1, this.options.maxPlaybackRate - 0.1);
					this._updatePlaybackRate();
					break;
				case "maxPlaybackRate" :
					this.options[key] = value = this._limitValue(value, this.options.minPlaybackRate + 0.1, 16);
					this._updatePlaybackRate();
					break;
				case "fullScreen" :
					if(this.options[key] !== value) { // if changed
						var wkv = $.jPlayer.nativeFeatures.fullscreen.used.webkitVideo;
						if(!wkv || wkv && !this.status.waitForPlay) {
							if(!wkv) { // No sensible way to unset option on these devices.
								this.options[key] = value;
							}
							if(value) {
								this._requestFullscreen();
							} else {
								this._exitFullscreen();
							}
							if(!wkv) {
								this._setOption("fullWindow", value);
							}
						}
					}
					break;
				case "fullWindow" :
					if(this.options[key] !== value) { // if changed
						this._removeUiClass();
						this.options[key] = value;
						this._refreshSize();
					}
					break;
				case "size" :
					if(!this.options.fullWindow && this.options[key].cssClass !== value.cssClass) {
						this._removeUiClass();
					}
					this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
					this._refreshSize();
					break;
				case "sizeFull" :
					if(this.options.fullWindow && this.options[key].cssClass !== value.cssClass) {
						this._removeUiClass();
					}
					this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
					this._refreshSize();
					break;
				case "autohide" :
					this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
					this._updateAutohide();
					break;
				case "loop" :
					this._loop(value);
					break;
				case "remainingDuration" :
					this.options[key] = value;
					this._updateInterface();
					break;
				case "toggleDuration" :
					this.options[key] = value;
					break;
				case "nativeVideoControls" :
					this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
					this.status.nativeVideoControls = this._uaBlocklist(this.options.nativeVideoControls);
					this._restrictNativeVideoControls();
					this._updateNativeVideoControls();
					break;
				case "noFullWindow" :
					this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
					this.status.nativeVideoControls = this._uaBlocklist(this.options.nativeVideoControls); // Need to check again as noFullWindow can depend on this flag and the restrict() can override it.
					this.status.noFullWindow = this._uaBlocklist(this.options.noFullWindow);
					this._restrictNativeVideoControls();
					this._updateButtons();
					break;
				case "noVolume" :
					this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
					this.status.noVolume = this._uaBlocklist(this.options.noVolume);
					this._updateVolume();
					this._updateMute();
					break;
				case "emulateHtml" :
					if(this.options[key] !== value) { // To avoid multiple event handlers being created, if true already.
						this.options[key] = value;
						if(value) {
							this._emulateHtmlBridge();
						} else {
							this._destroyHtmlBridge();
						}
					}
					break;
				case "timeFormat" :
					this.options[key] = $.extend({}, this.options[key], value); // store a merged copy of it, incase not all properties changed.
					break;
				case "keyEnabled" :
					this.options[key] = value;
					if(!value && this === $.jPlayer.focus) {
						$.jPlayer.focus = null;
					}
					break;
				case "keyBindings" :
					this.options[key] = $.extend(true, {}, this.options[key], value); // store a merged DEEP copy of it, incase not all properties changed.
					break;
				case "audioFullScreen" :
					this.options[key] = value;
					break;
			}

			return this;
		},
		// End of: (Options code adapted from ui.widget.js)

		_refreshSize: function() {
			this._setSize(); // update status and jPlayer element size
			this._addUiClass(); // update the ui class
			this._updateSize(); // update internal sizes
			this._updateButtons();
			this._updateAutohide();
			this._trigger($.jPlayer.event.resize);
		},
		_setSize: function() {
			// Determine the current size from the options
			if(this.options.fullWindow) {
				this.status.width = this.options.sizeFull.width;
				this.status.height = this.options.sizeFull.height;
				this.status.cssClass = this.options.sizeFull.cssClass;
			} else {
				this.status.width = this.options.size.width;
				this.status.height = this.options.size.height;
				this.status.cssClass = this.options.size.cssClass;
			}

			// Set the size of the jPlayer area.
			this.element.css({'width': this.status.width, 'height': this.status.height});
		},
		_addUiClass: function() {
			if(this.ancestorJq.length) {
				this.ancestorJq.addClass(this.status.cssClass);
			}
		},
		_removeUiClass: function() {
			if(this.ancestorJq.length) {
				this.ancestorJq.removeClass(this.status.cssClass);
			}
		},
		_updateSize: function() {
			// The poster uses show/hide so can simply resize it.
			this.internal.poster.jq.css({'width': this.status.width, 'height': this.status.height});

			// Video html or flash resized if necessary at this time, or if native video controls being used.
			if(!this.status.waitForPlay && this.status.video || this.html.video.available && this.html.used && this.status.nativeVideoControls) {
				this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
			}
		},
		_updateAutohide: function() {
			var	self = this,
				event = "mousemove.jPlayer",
				namespace = ".jPlayerAutohide",
				eventType = event + namespace,
				handler = function() {
					self.css.jq.gui.fadeIn(self.options.autohide.fadeIn, function() {
						clearTimeout(self.internal.autohideId);
						self.internal.autohideId = setTimeout( function() {
							self.css.jq.gui.fadeOut(self.options.autohide.fadeOut);
						}, self.options.autohide.hold);
					});
				};

			if(this.css.jq.gui.length) {

				// End animations first so that its callback is executed now.
				// Otherwise an in progress fadeIn animation still has the callback to fadeOut again.
				this.css.jq.gui.stop(true, true);

				// Removes the fadeOut operation from the fadeIn callback.
				clearTimeout(this.internal.autohideId);

				this.element.unbind(namespace);
				this.css.jq.gui.unbind(namespace);

				if(!this.status.nativeVideoControls) {
					if(this.options.fullWindow && this.options.autohide.full || !this.options.fullWindow && this.options.autohide.restored) {
						this.element.bind(eventType, handler);
						this.css.jq.gui.bind(eventType, handler);
						this.css.jq.gui.hide();
					} else {
						this.css.jq.gui.show();
					}
				} else {
					this.css.jq.gui.hide();
				}
			}
		},
		fullScreen: function() {
			this._setOption("fullScreen", true);
		},
		restoreScreen: function() {
			this._setOption("fullScreen", false);
		},
		_fullscreenAddEventListeners: function() {
			var self = this,
				fs = $.jPlayer.nativeFeatures.fullscreen;

			if(fs.api.fullscreenEnabled) {
				if(fs.event.fullscreenchange) {
					// Create the event handler function and store it for removal.
					if(typeof this.internal.fullscreenchangeHandler !== 'function') {
						this.internal.fullscreenchangeHandler = function() {
							self._fullscreenchange();
						};
					}
					document.addEventListener(fs.event.fullscreenchange, this.internal.fullscreenchangeHandler, false);
				}
				// No point creating handler for fullscreenerror.
				// Either logic avoids fullscreen occurring (w3c/moz), or their is no event on the browser (webkit).
			}
		},
		_fullscreenRemoveEventListeners: function() {
			var fs = $.jPlayer.nativeFeatures.fullscreen;
			if(this.internal.fullscreenchangeHandler) {
				document.removeEventListener(fs.event.fullscreenchange, this.internal.fullscreenchangeHandler, false);
			}
		},
		_fullscreenchange: function() {
			// If nothing is fullscreen, then we cannot be in fullscreen mode.
			if(this.options.fullScreen && !$.jPlayer.nativeFeatures.fullscreen.api.fullscreenElement()) {
				this._setOption("fullScreen", false);
			}
		},
		_requestFullscreen: function() {
			// Either the container or the jPlayer div
			var e = this.ancestorJq.length ? this.ancestorJq[0] : this.element[0],
				fs = $.jPlayer.nativeFeatures.fullscreen;

			// This method needs the video element. For iOS and Android.
			if(fs.used.webkitVideo) {
				e = this.htmlElement.video;
			}

			if(fs.api.fullscreenEnabled) {
				fs.api.requestFullscreen(e);
			}
		},
		_exitFullscreen: function() {

			var fs = $.jPlayer.nativeFeatures.fullscreen,
				e;

			// This method needs the video element. For iOS and Android.
			if(fs.used.webkitVideo) {
				e = this.htmlElement.video;
			}

			if(fs.api.fullscreenEnabled) {
				fs.api.exitFullscreen(e);
			}
		},
		_html_initMedia: function(media) {
			// Remove any existing track elements
			var $media = $(this.htmlElement.media).empty();

			// Create any track elements given with the media, as an Array of track Objects.
			$.each(media.track || [], function(i,v) {
				var track = document.createElement('track');
				track.setAttribute("kind", v.kind ? v.kind : "");
				track.setAttribute("src", v.src ? v.src : "");
				track.setAttribute("srclang", v.srclang ? v.srclang : "");
				track.setAttribute("label", v.label ? v.label : "");
				if(v.def) {
					track.setAttribute("default", v.def);
				}
				$media.append(track);
			});

			this.htmlElement.media.src = this.status.src;

			if(this.options.preload !== 'none') {
				this._html_load(); // See function for comments
			}
			this._trigger($.jPlayer.event.timeupdate); // The flash generates this event for its solution.
		},
		_html_setFormat: function(media) {
			var self = this;
			// Always finds a format due to checks in setMedia()
			$.each(this.formats, function(priority, format) {
				if(self.html.support[format] && media[format]) {
					self.status.src = media[format];
					self.status.format[format] = true;
					self.status.formatType = format;
					return false;
				}
			});
		},
		_html_setAudio: function(media) {
			this._html_setFormat(media);
			this.htmlElement.media = this.htmlElement.audio;
			this._html_initMedia(media);
		},
		_html_setVideo: function(media) {
			this._html_setFormat(media);
			if(this.status.nativeVideoControls) {
				this.htmlElement.video.poster = this._validString(media.poster) ? media.poster : "";
			}
			this.htmlElement.media = this.htmlElement.video;
			this._html_initMedia(media);
		},
		_html_resetMedia: function() {
			if(this.htmlElement.media) {
				if(this.htmlElement.media.id === this.internal.video.id && !this.status.nativeVideoControls) {
					this.internal.video.jq.css({'width':'0px', 'height':'0px'});
				}
				this.htmlElement.media.pause();
			}
		},
		_html_clearMedia: function() {
			if(this.htmlElement.media) {
				this.htmlElement.media.src = "about:blank";
				// The following load() is only required for Firefox 3.6 (PowerMacs).
				// Recent HTMl5 browsers only require the src change. Due to changes in W3C spec and load() effect.
				this.htmlElement.media.load(); // Stops an old, "in progress" download from continuing the download. Triggers the loadstart, error and emptied events, due to the empty src. Also an abort event if a download was in progress.
			}
		},
		_html_load: function() {
			// This function remains to allow the early HTML5 browsers to work, such as Firefox 3.6
			// A change in the W3C spec for the media.load() command means that this is no longer necessary.
			// This command should be removed and actually causes minor undesirable effects on some browsers. Such as loading the whole file and not only the metadata.
			if(this.status.waitForLoad) {
				this.status.waitForLoad = false;
				this.htmlElement.media.load();
			}
			clearTimeout(this.internal.htmlDlyCmdId);
		},
		_html_play: function(time) {
			var self = this,
				media = this.htmlElement.media;

			this.androidFix.pause = false; // Cancel the pause fix.

			this._html_load(); // Loads if required and clears any delayed commands.

			// Setup the Android Fix.
			if(this.androidFix.setMedia) {
				this.androidFix.play = true;
				this.androidFix.time = time;

			} else if(!isNaN(time)) {

				// Attempt to play it, since iOS has been ignoring commands
				if(this.internal.cmdsIgnored) {
					media.play();
				}

				try {
					// !media.seekable is for old HTML5 browsers, like Firefox 3.6.
					// Checking seekable.length is important for iOS6 to work with setMedia().play(time)
					if(!media.seekable || typeof media.seekable === "object" && media.seekable.length > 0) {
						media.currentTime = time;
						media.play();
					} else {
						throw 1;
					}
				} catch(err) {
					this.internal.htmlDlyCmdId = setTimeout(function() {
						self.play(time);
					}, 250);
					return; // Cancel execution and wait for the delayed command.
				}
			} else {
				media.play();
			}
			this._html_checkWaitForPlay();
		},
		_html_pause: function(time) {
			var self = this,
				media = this.htmlElement.media;

			this.androidFix.play = false; // Cancel the play fix.

			if(time > 0) { // We do not want the stop() command, which does pause(0), causing a load operation.
				this._html_load(); // Loads if required and clears any delayed commands.
			} else {
				clearTimeout(this.internal.htmlDlyCmdId);
			}

			// Order of these commands is important for Safari (Win) and IE9. Pause then change currentTime.
			media.pause();

			// Setup the Android Fix.
			if(this.androidFix.setMedia) {
				this.androidFix.pause = true;
				this.androidFix.time = time;

			} else if(!isNaN(time)) {
				try {
					if(!media.seekable || typeof media.seekable === "object" && media.seekable.length > 0) {
						media.currentTime = time;
					} else {
						throw 1;
					}
				} catch(err) {
					this.internal.htmlDlyCmdId = setTimeout(function() {
						self.pause(time);
					}, 250);
					return; // Cancel execution and wait for the delayed command.
				}
			}
			if(time > 0) { // Avoids a setMedia() followed by stop() or pause(0) hiding the video play button.
				this._html_checkWaitForPlay();
			}
		},
		_html_playHead: function(percent) {
			var self = this,
				media = this.htmlElement.media;

			this._html_load(); // Loads if required and clears any delayed commands.

			// This playHead() method needs a refactor to apply the android fix.

			try {
				if(typeof media.seekable === "object" && media.seekable.length > 0) {
					media.currentTime = percent * media.seekable.end(media.seekable.length-1) / 100;
				} else if(media.duration > 0 && !isNaN(media.duration)) {
					media.currentTime = percent * media.duration / 100;
				} else {
					throw "e";
				}
			} catch(err) {
				this.internal.htmlDlyCmdId = setTimeout(function() {
					self.playHead(percent);
				}, 250);
				return; // Cancel execution and wait for the delayed command.
			}
			if(!this.status.waitForLoad) {
				this._html_checkWaitForPlay();
			}
		},
		_html_checkWaitForPlay: function() {
			if(this.status.waitForPlay) {
				this.status.waitForPlay = false;
				if(this.css.jq.videoPlay.length) {
					this.css.jq.videoPlay.hide();
				}
				if(this.status.video) {
					this.internal.poster.jq.hide();
					this.internal.video.jq.css({'width': this.status.width, 'height': this.status.height});
				}
			}
		},
		_html_setProperty: function(property, value) {
			if(this.html.audio.available) {
				this.htmlElement.audio[property] = value;
			}
			if(this.html.video.available) {
				this.htmlElement.video[property] = value;
			}
		},
		_cordova_setAudio: function(media) {
                    var self = this;
                    $.each(this.formats, function(priority, format) {
                        if(self.cordova.support[format] && media[format]) {
                                self.status.src = media[format];
                                self.status.format[format] = true;
                                self.status.formatType = format;
                                return false;
                        }
                    });
                    this._cordova_load();
                    if(this.options.preload === 'auto') {
                        this.status.waitForLoad = false;
                    }
		},
		_cordova_resetMedia: function() {
			if (this.internal.mediaObj) {
                            this.internal.mediaObj.stop();                        
                        }
                        this.internal.mediaObj = null;
                        if (this.cordova.updateInterval) {
                            clearInterval(this.cordova.updateInterval);
                        }
		},
		_cordova_clearMedia: function() {
			this._cordova_resetMedia();
		},
		_cordova_load: function() {
                    this.internal.mediaObj = new Media(this.status.src, function() {
                    
                        }, function(msg) {
                            Helix.Utils.statusMessage("Error Loading Media", msg, "fatal");
                        });
                    this.status.waitForLoad = false;
		},
                _getCordovaStatus: function(duration, ct) {
			var cpa = 0, sp = 0, cpr = 0;

                        if (ct < -0) {
                            this.status.ended = 0;
                            this.status.seekPercent = 0;
                            this.status.currentPercentRelative = 0;
                            this.status.currentPercentAbsolute = 0;
                            this.status.currentTime = 0;

                            this.status.remaining = 0;
                            return;
                        }

                        this.status.duration = duration;
                        cpa = (this.status.duration > 0) ? 100 * ct / this.status.duration : 0;
                        sp = 100;
                        cpr = cpa;

			this.status.seekPercent = sp;
			this.status.currentPercentRelative = cpr;
			this.status.currentPercentAbsolute = cpa;
			this.status.currentTime = ct;

			this.status.remaining = this.status.duration - this.status.currentTime;
			this.status.ended = false;
		},
		_cordova_play: function(time) {
                    this.internal.mediaObj.play();
                    this._updateButtons(true);
                    
                    var _self = this;
                    this.cordova.updateInterval = setInterval(function() {
                        if (!_self.internal.mediaObj) {
                            clearInterval(_self.cordova.updateInterval);
                        } else {
                            _self.internal.mediaObj.getCurrentPosition(function(pos) {
                                _self._getCordovaStatus(_self.internal.mediaObj.getDuration(), pos);
                                if (pos < 0) {
                                    _self._updateButtons(false);
                                    clearInterval(_self.cordova.updateInterval);
                                } else {
                                    _self.status.currentTime = pos;
                                }
                                _self._updateInterface();
                            });
                        }
                    }, 1000);
		},
		_cordova_pause: function(time) {
                    this.internal.mediaObj.pause();
                    if (time == 0) {
                       this._getCordovaStatus(this.internal.mediaObj.getDuration(), 0);
                       this._updateInterface();
                       this.internal.mediaObj.seekTo(time * 1000);
                    }
                    this._updateButtons(false);
                    clearInterval(this.cordova.updateInterval);
		},
		_cordova_playHead: function(p) {
                    var dur = this.internal.mediaObj.getDuration();
                    var seekSecs = Math.floor((p / 100) * dur);
                    // seekTo takes msecs as a parameter
                    this.internal.mediaObj.seekTo(seekSecs * 1000);
                    this._getCordovaStatus(dur, seekSecs)
                    this._updateInterface();
                    this._updateButtons(true);
		},
		_cordova_checkWaitForPlay: function() {
                    if(this.status.waitForPlay) {
                            this.status.waitForPlay = false;
                            if(this.css.jq.videoPlay.length) {
                                    this.css.jq.videoPlay.hide();
                            }
                            if(this.status.video) {
                                    this.internal.poster.jq.hide();
                            }
                    }
		},
		_cordova_volume: function(v) {
                    this.internal.mediaObj.setVolume(v);
		},
		_cordova_mute: function(m) {
                    this.internal.mediaObj.setVolume(0.0);
		},
		_getCordovaPluginVersion: function() {
                    return parseFloat(window.CordovaVersion + "." + window.CordovaRevision);
		},
		_checkForCordova: function (version) {
                    var cdvOk = false;
                    if(this._getCordovaPluginVersion() >= version) {
                            cdvOk = true;
                    }
                    return cdvOk;
		},
		_validString: function(url) {
			return (url && typeof url === "string"); // Empty strings return false
		},
		_limitValue: function(value, min, max) {
			return (value < min) ? min : ((value > max) ? max : value);
		},
		_urlNotSetError: function(context) {
			this._error( {
				type: $.jPlayer.error.URL_NOT_SET,
				context: context,
				message: $.jPlayer.errorMsg.URL_NOT_SET,
				hint: $.jPlayer.errorHint.URL_NOT_SET
			});
		},
		_error: function(error) {
			this._trigger($.jPlayer.event.error, error);
			if(this.options.errorAlerts) {
				this._alert("Error!" + (error.message ? "\n" + error.message : "") + (error.hint ? "\n" + error.hint : "") + "\nContext: " + error.context);
			}
		},
		_warning: function(warning) {
			this._trigger($.jPlayer.event.warning, undefined, warning);
			if(this.options.warningAlerts) {
				this._alert("Warning!" + (warning.message ? "\n" + warning.message : "") + (warning.hint ? "\n" + warning.hint : "") + "\nContext: " + warning.context);
			}
		},
		_alert: function(message) {
			var msg = "jPlayer " + this.version.script + " : id='" + this.internal.self.id +"' : " + message;
			if(!this.options.consoleAlerts) {
				alert(msg);
			} else if(window.console && window.console.log) {
				window.console.log(msg);
			}
		},
		_emulateHtmlBridge: function() {
			var self = this;

			// Emulate methods on jPlayer's DOM element.
			$.each( $.jPlayer.emulateMethods.split(/\s+/g), function(i, name) {
				self.internal.domNode[name] = function(arg) {
					self[name](arg);
				};

			});

			// Bubble jPlayer events to its DOM element.
			$.each($.jPlayer.event, function(eventName,eventType) {
				var nativeEvent = true;
				$.each( $.jPlayer.reservedEvent.split(/\s+/g), function(i, name) {
					if(name === eventName) {
						nativeEvent = false;
						return false;
					}
				});
				if(nativeEvent) {
					self.element.bind(eventType + ".jPlayer.jPlayerHtml", function() { // With .jPlayer & .jPlayerHtml namespaces.
						self._emulateHtmlUpdate();
						var domEvent = document.createEvent("Event");
						domEvent.initEvent(eventName, false, true);
						self.internal.domNode.dispatchEvent(domEvent);
					});
				}
				// The error event would require a special case
			});

			// IE9 has a readyState property on all elements. The document should have it, but all (except media) elements inherit it in IE9. This conflicts with Popcorn, which polls the readyState.
		},
		_emulateHtmlUpdate: function() {
			var self = this;

			$.each( $.jPlayer.emulateStatus.split(/\s+/g), function(i, name) {
				self.internal.domNode[name] = self.status[name];
			});
			$.each( $.jPlayer.emulateOptions.split(/\s+/g), function(i, name) {
				self.internal.domNode[name] = self.options[name];
			});
		},
		_destroyHtmlBridge: function() {
			var self = this;

			// Bridge event handlers are also removed by destroy() through .jPlayer namespace.
			this.element.unbind(".jPlayerHtml"); // Remove all event handlers created by the jPlayer bridge. So you can change the emulateHtml option.

			// Remove the methods and properties
			var emulated = $.jPlayer.emulateMethods + " " + $.jPlayer.emulateStatus + " " + $.jPlayer.emulateOptions;
			$.each( emulated.split(/\s+/g), function(i, name) {
				delete self.internal.domNode[name];
			});
		}
	};

	$.jPlayer.error = {
		NO_SOLUTION: "e_no_solution",
		NO_SUPPORT: "e_no_support",
		URL: "e_url",
		URL_NOT_SET: "e_url_not_set",
		VERSION: "e_version"
	};

	$.jPlayer.errorMsg = {
		NO_SOLUTION: "No solution can be found by jPlayer in this browser. Neither HTML nor Flash can be used.", // Used in: _init()
		NO_SUPPORT: "It is not possible to play any media format provided in setMedia() on this browser using your current options.", // Used in: setMedia()
		URL: "Media URL could not be loaded.", // Used in: jPlayerFlashEvent() and _addHtmlEventListeners()
		URL_NOT_SET: "Attempt to issue media playback commands, while no media url is set.", // Used in: load(), play(), pause(), stop() and playHead()
		VERSION: "jPlayer " + $.jPlayer.prototype.version.script + " needs Jplayer.swf version " + $.jPlayer.prototype.version.needFlash + " but found " // Used in: jPlayerReady()
	};

	$.jPlayer.errorHint = {
		NO_SOLUTION: "Review the jPlayer options: support and supplied.",
		NO_SUPPORT: "Video or audio formats defined in the supplied option are missing.",
		URL: "Check media URL is valid.",
		URL_NOT_SET: "Use setMedia() to set the media URL.",
		VERSION: "Update jPlayer files."
	};

	$.jPlayer.warning = {
		CSS_SELECTOR_COUNT: "e_css_selector_count",
		CSS_SELECTOR_METHOD: "e_css_selector_method",
		CSS_SELECTOR_STRING: "e_css_selector_string",
		OPTION_KEY: "e_option_key"
	};

	$.jPlayer.warningMsg = {
		CSS_SELECTOR_COUNT: "The number of css selectors found did not equal one: ",
		CSS_SELECTOR_METHOD: "The methodName given in jPlayer('cssSelector') is not a valid jPlayer method.",
		CSS_SELECTOR_STRING: "The methodCssSelector given in jPlayer('cssSelector') is not a String or is empty.",
		OPTION_KEY: "The option requested in jPlayer('option') is undefined."
	};

	$.jPlayer.warningHint = {
		CSS_SELECTOR_COUNT: "Check your css selector and the ancestor.",
		CSS_SELECTOR_METHOD: "Check your method name.",
		CSS_SELECTOR_STRING: "Check your css selector is a string.",
		OPTION_KEY: "Check your option name."
	};
}));
